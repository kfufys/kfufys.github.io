<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Console 调试技巧</title>
    <url>https://kfufys.github.io/posts/b66155b1.html</url>
    <content><![CDATA[<img src="https://kfufys.github.io/posts/b66155b1/1.jpg" alt="head-img" width="1200">

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说到 <code>console</code>，很多人的第一反应肯定是 <code>console.log</code>，它既简单又直接！然而，在处理复杂问题时，这种方式往往效率低下。本文分享 20 个 <code>console</code> 的调试小技巧，帮您更快速地找出并解决问题。</p>
<h3 id="1-样式轰炸"><a href="#1-样式轰炸" class="headerlink" title="1. 样式轰炸"></a>1. 样式轰炸</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这段代码使用了 console.log 的样式功能，通过传入特定的 CSS 样式字符串，</span></span><br><span class="line"><span class="comment">// 可以为输出的文本添加自定义样式，达到醒目的效果，这里创建了一个带有渐变背景、</span></span><br><span class="line"><span class="comment">// 白色文字、圆角和内边距的“VIP调试模式”样式，以及一个后续的灰色文字样式用于显示版本号。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="string">&#x27;%cVIP调试模式%c v2.0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;background:linear-gradient(45deg,#ff6b6b,#4ecdc4);color:white;padding:4px 8px;border-radius:3px;&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;color:#666;margin-left:8px;&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h3 id="2-动态模板"><a href="#2-动态模板" class="headerlink" title="2. 动态模板"></a>2. 动态模板</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个包含用户信息的对象，然后利用模板字符串结合当前时间，</span></span><br><span class="line"><span class="comment">// 在控制台输出一条包含用户名称、等级以及执行操作信息的日志，方便跟踪用户行为及操作时间。</span></span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">level</span>: <span class="string">&#x27;VIP&#x27;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toISOString()&#125;</span>] <span class="subst">$&#123;user.name&#125;</span> (<span class="subst">$&#123;user.level&#125;</span>) 执行了支付操作`</span>);</span><br><span class="line"><span class="comment">// 输出示例：[2023-12-25T09:30:00Z] Alice (VIP) 执行了支付操作</span></span><br></pre></td></tr></table></figure>


<h3 id="3-树形结构解析"><a href="#3-树形结构解析" class="headerlink" title="3. 树形结构解析"></a>3. 树形结构解析</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以一种结构化、易读的方式在控制台输出用户数据树，使用特定样式突出显示树的标题，</span></span><br><span class="line"><span class="comment">// 数据树包含用户 ID、个人资料（姓名、地址，地址又细分城市和区）以及订单列表等信息，方便查看数据层级关系。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;%c▸ 用户数据树&#x27;</span>, <span class="string">&#x27;color:#48bb78;font-weight:bold&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1001</span>,</span><br><span class="line">  <span class="attr">profile</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">      <span class="attr">city</span>: <span class="string">&#x27;上海&#x27;</span>,</span><br><span class="line">      <span class="attr">district</span>: <span class="string">&#x27;浦东&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">orders</span>: [<span class="string">&#x27;#2023-1001&#x27;</span>, <span class="string">&#x27;#2023-1002&#x27;</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="4-表格魔法升级"><a href="#4-表格魔法升级" class="headerlink" title="4. 表格魔法升级"></a>4. 表格魔法升级</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于加密货币数据数组，先对每个数据项进行处理，添加一个表示价格趋势的字段（根据 24 小时价格变化判断上升或下降），</span></span><br><span class="line"><span class="comment">// 然后使用 console.table 将处理后的数据以表格形式输出，使数据对比更加直观清晰。</span></span><br><span class="line"><span class="keyword">const</span> cryptoData = [</span><br><span class="line">  &#123; <span class="attr">coin</span>: <span class="string">&#x27;BTC&#x27;</span>, <span class="attr">price</span>: <span class="number">42000</span>, <span class="attr">change24h</span>: <span class="string">&#x27;+5.2%&#x27;</span>, <span class="attr">volatility</span>: <span class="string">&#x27;high&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">coin</span>: <span class="string">&#x27;ETH&#x27;</span>, <span class="attr">price</span>: <span class="number">2300</span>, <span class="attr">change24h</span>: <span class="string">&#x27;-1.8%&#x27;</span>, <span class="attr">volatility</span>: <span class="string">&#x27;medium&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">coin</span>: <span class="string">&#x27;SOL&#x27;</span>, <span class="attr">price</span>: <span class="number">98</span>, <span class="attr">change24h</span>: <span class="string">&#x27;+12.6%&#x27;</span>, <span class="attr">volatility</span>: <span class="string">&#x27;high&#x27;</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">table</span>(cryptoData.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> (&#123;</span><br><span class="line">...item,</span><br><span class="line">  <span class="string">&#x27;价格趋势&#x27;</span>: item.<span class="property">change24h</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;+&#x27;</span>)? <span class="string">&#x27;↑&#x27;</span> : <span class="string">&#x27;↓&#x27;</span></span><br><span class="line">&#125;)));</span><br></pre></td></tr></table></figure>


<h3 id="5-生命周期标记"><a href="#5-生命周期标记" class="headerlink" title="5. 生命周期标记"></a>5. 生命周期标记</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 console.groupCollapsed 和 console.groupEnd 来创建一个可折叠的分组，</span></span><br><span class="line"><span class="comment">// 用于标记 API 请求流程的不同阶段，如请求发起、响应接收、数据处理等，每个阶段用不同颜色突出显示关键信息，</span></span><br><span class="line"><span class="comment">// 方便在控制台快速了解整个请求生命周期的状态。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupCollapsed</span>(<span class="string">&#x27;%c🔄 API请求流程追踪&#x27;</span>, <span class="string">&#x27;color:#4299e1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;%c▶️ 请求发起&#x27;</span>, <span class="string">&#x27;color:#48bb78&#x27;</span>, &#123; <span class="attr">url</span>: <span class="string">&#x27;/api/users&#x27;</span>, <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;%c⏳ 响应接收&#x27;</span>, <span class="string">&#x27;color:#ed8936&#x27;</span>, &#123; <span class="attr">status</span>: <span class="number">200</span>, <span class="attr">time</span>: <span class="string">&#x27;320ms&#x27;</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;%c✅ 数据处理&#x27;</span>, <span class="string">&#x27;color:#48bb78&#x27;</span>, &#123; <span class="attr">processedItems</span>: <span class="number">15</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupEnd</span>();</span><br></pre></td></tr></table></figure>


<h3 id="6-调用栈快照"><a href="#6-调用栈快照" class="headerlink" title="6. 调用栈快照"></a>6. 调用栈快照</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在函数内部使用 console.trace，当执行到这一行时，会输出完整的调用栈信息，</span></span><br><span class="line"><span class="comment">// 显示函数是如何被调用的，经过了哪些路径，对于排查函数调用逻辑和定位问题根源非常有用。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processOrder</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">trace</span>(<span class="string">&#x27;订单处理流程追踪&#x27;</span>);</span><br><span class="line">  <span class="comment">// 其他处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出完整的调用栈信息</span></span><br></pre></td></tr></table></figure>


<h3 id="7-内存监控"><a href="#7-内存监控" class="headerlink" title="7. 内存监控"></a>7. 内存监控</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先获取初始的 JavaScript 堆内存使用量，执行一些内存密集型操作后，</span></span><br><span class="line"><span class="comment">// 通过计算前后内存使用量的差值并转换为 KB 单位，输出内存使用量的变化情况，以便监控内存消耗是否合理。</span></span><br><span class="line"><span class="keyword">const</span> initialMemory = performance.<span class="property">memory</span>.<span class="property">usedJSHeapSize</span>;</span><br><span class="line"><span class="comment">// 执行内存密集型操作</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内存使用量变化:&#x27;</span>, </span><br><span class="line">  (performance.<span class="property">memory</span>.<span class="property">usedJSHeapSize</span> - initialMemory) / <span class="number">1024</span> + <span class="string">&#x27; KB&#x27;</span>);</span><br></pre></td></tr></table></figure>


<h3 id="8-复合性能测试"><a href="#8-复合性能测试" class="headerlink" title="8. 复合性能测试"></a>8. 复合性能测试</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 console.time 和 console.timeEnd 来测量一段包含多个异步操作（如 Promise.all 中的多个异步任务）的复合操作的执行时间，</span></span><br><span class="line"><span class="comment">// 同时使用 console.timeLog 在操作的关键阶段记录时间点，方便了解各个阶段的耗时情况，精准定位性能瓶颈。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;复合操作&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">timeLog</span>(<span class="string">&#x27;复合操作&#x27;</span>, <span class="string">&#x27;阶段1完成&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetchData</span>(),</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">timeLog</span>(<span class="string">&#x27;复合操作&#x27;</span>, <span class="string">&#x27;阶段2完成&#x27;</span>),</span><br><span class="line">  <span class="title function_">processData</span>()</span><br><span class="line">]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;复合操作&#x27;</span>);</span><br></pre></td></tr></table></figure>


<h3 id="9-条件断言"><a href="#9-条件断言" class="headerlink" title="9. 条件断言"></a>9. 条件断言</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 console.assert 进行条件断言，如果条件不满足（这里是用户年龄大于 18 岁），</span></span><br><span class="line"><span class="comment">// 则按照指定的红色醒目的样式输出错误信息，包含期望年龄和实际年龄，用于快速验证数据的合法性。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">assert</span>(</span><br><span class="line">  user.<span class="property">age</span> &gt; <span class="number">18</span>, </span><br><span class="line">  <span class="string">&#x27;%c年龄验证失败&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;color:red;font-weight:bold&#x27;</span>,</span><br><span class="line">  &#123; <span class="attr">requiredAge</span>: <span class="number">18</span>, <span class="attr">actualAge</span>: user.<span class="property">age</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h3 id="10-环境感知日志"><a href="#10-环境感知日志" class="headerlink" title="10. 环境感知日志"></a>10. 环境感知日志</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据当前 Node.js 环境变量（NODE_ENV）来决定是否输出日志，</span></span><br><span class="line"><span class="comment">// 在开发环境下，将 console.log 绑定并正常输出日志，而在生产环境下，</span></span><br><span class="line"><span class="comment">// 提供一个空函数替代，实现自动静默，避免在生产环境输出不必要的调试信息。</span></span><br><span class="line"><span class="keyword">const</span> debug = &#123;</span><br><span class="line">  <span class="attr">log</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span> </span><br><span class="line">  ? <span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>) </span><br><span class="line">    : <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">debug.<span class="title function_">log</span>(<span class="string">&#x27;开发环境专属日志&#x27;</span>); <span class="comment">// 生产环境自动静默</span></span><br></pre></td></tr></table></figure>


<h3 id="11-数据快照对比"><a href="#11-数据快照对比" class="headerlink" title="11. 数据快照对比"></a>11. 数据快照对比</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先将状态数据序列化为字符串保存起来，在状态修改后，通过自定义的 diff 函数（假设已定义）对比修改前后的数据，</span></span><br><span class="line"><span class="comment">// 并在控制台输出状态变更差异，有助于跟踪数据的变化情况，排查因数据变更引发的问题。</span></span><br><span class="line"><span class="keyword">const</span> before = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(state);</span><br><span class="line"><span class="comment">// 状态修改操作</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;状态变更差异:&#x27;</span>, <span class="title function_">diff</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(before), state));</span><br></pre></td></tr></table></figure>


<h3 id="12-日志分类过滤"><a href="#12-日志分类过滤" class="headerlink" title="12. 日志分类过滤"></a>12. 日志分类过滤</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个日志记录器对象，包含不同分类的日志方法，如网络、安全、支付等，</span></span><br><span class="line"><span class="comment">// 每个方法在调用 console.log 时添加对应的分类前缀，方便在控制台根据分类筛选和查看日志，</span></span><br><span class="line"><span class="comment">// 这里演示了记录支付请求发起的日志，包含金额信息。</span></span><br><span class="line"><span class="keyword">const</span> logger = &#123;</span><br><span class="line">  <span class="attr">network</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[NET]&#x27;</span>,...args),</span><br><span class="line">  <span class="attr">security</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[SEC]&#x27;</span>,...args),</span><br><span class="line">  <span class="attr">payment</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[PAY]&#x27;</span>,...args)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">logger.<span class="title function_">payment</span>(<span class="string">&#x27;支付请求发起&#x27;</span>, &#123; <span class="attr">amount</span>: <span class="number">99.9</span> &#125;);</span><br></pre></td></tr></table></figure>


<h3 id="13-交互式调试"><a href="#13-交互式调试" class="headerlink" title="13. 交互式调试"></a>13. 交互式调试</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在控制台输出一个包含加密数据和检查函数的对象，用户点击该输出信息时，</span></span><br><span class="line"><span class="comment">// 可以通过调用检查函数（这里是解密数据函数 decryptData）来查看详细信息，实现交互式调试体验。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击查看详情：&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: encryptedData,</span><br><span class="line">  <span class="attr">inspect</span>: <span class="function">() =&gt;</span> <span class="title function_">decryptData</span>(encryptedData)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="14-日志持久化"><a href="#14-日志持久化" class="headerlink" title="14. 日志持久化"></a>14. 日志持久化</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存原始的 console.log 方法，并重写 console.log，</span></span><br><span class="line"><span class="comment">// 在新的 console.log 中，先执行原始的输出操作，再将日志信息发送到日志服务器（假设 sendToLogServer 函数已实现），</span></span><br><span class="line"><span class="comment">// 确保日志不仅在控制台可见，还能持久化存储以供后续分析。</span></span><br><span class="line"><span class="keyword">const</span> originalLog = <span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span> = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">originalLog</span>(...args);</span><br><span class="line">  <span class="title function_">sendToLogServer</span>(args); <span class="comment">// 发送到日志服务器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="15-性能热力图"><a href="#15-性能热力图" class="headerlink" title="15. 性能热力图"></a>15. 性能热力图</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 console.timeStamp 在关键的性能节点（如渲染开始、DOM 更新）记录时间戳，</span></span><br><span class="line"><span class="comment">// 之后可以在浏览器的 Performance 面板查看这些时间戳，以可视化的方式分析页面性能瓶颈，优化渲染流程。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeStamp</span>(<span class="string">&#x27;渲染开始&#x27;</span>);</span><br><span class="line"><span class="comment">// 渲染逻辑</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeStamp</span>(<span class="string">&#x27;DOM更新&#x27;</span>);</span><br><span class="line"><span class="comment">// 更新逻辑</span></span><br><span class="line"><span class="comment">// 在浏览器Performance面板查看时间戳</span></span><br></pre></td></tr></table></figure>


<h3 id="16-内存泄漏检测"><a href="#16-内存泄漏检测" class="headerlink" title="16. 内存泄漏检测"></a>16. 内存泄漏检测</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个数组来存储组件实例的引用，在组件构造函数中，每创建一个实例就将其添加到数组中，</span></span><br><span class="line"><span class="comment">// 并通过 console.count 记录实例创建的次数，同时定期检查数组中实例的数量，</span></span><br><span class="line"><span class="comment">// 如果数量持续增加，可能存在内存泄漏问题，方便及时排查。</span></span><br><span class="line"><span class="keyword">let</span> instances = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    instances.<span class="title function_">push</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">count</span>(<span class="string">&#x27;实例创建&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定期检查实例数量</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;存活实例:&#x27;</span>, instances.<span class="property">length</span>), <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>


<h3 id="17-源码映射调试"><a href="#17-源码映射调试" class="headerlink" title="17. 源码映射调试"></a>17. 源码映射调试</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 webpack 配置中启用 source-map，这使得在调试时能够将打包后的代码映射回原始的源代码，</span></span><br><span class="line"><span class="comment">// 方便在浏览器调试工具或 IDE 中直接查看和调试原始代码，而不是混淆后的代码，提高调试效率。</span></span><br><span class="line"><span class="comment">// 配合webpack配置</span></span><br><span class="line"><span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span>,</span><br></pre></td></tr></table></figure>


<h3 id="18-调试器集成"><a href="#18-调试器集成" class="headerlink" title="18. 调试器集成"></a>18. 调试器集成</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在函数开头使用 console.log 输出进入函数的信息，然后使用 debugger 语句，</span></span><br><span class="line"><span class="comment">// 当代码执行到这里时，会暂停执行，等待调试器（如浏览器开发者工具或 IDE 调试功能）连接，</span></span><br><span class="line"><span class="comment">// 方便深入调试函数内部复杂的运算逻辑。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">complexCalculation</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进入计算函数&#x27;</span>);</span><br><span class="line">  <span class="keyword">debugger</span>; <span class="comment">// 配合IDE断点使用</span></span><br><span class="line">  <span class="comment">// 复杂运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="19-日志分级控制"><a href="#19-日志分级控制" class="headerlink" title="19. 日志分级控制"></a>19. 日志分级控制</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个日志级别对象，包含调试、信息、警告、错误等级别，</span></span><br><span class="line"><span class="comment">// 然后创建一个 Logger 类，在构造函数中接收一个日志级别参数，</span></span><br><span class="line"><span class="comment">// 类中的 debug 方法根据当前设置的级别决定是否输出调试信息，实现灵活的日志分级管理。</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">LOG_LEVEL</span> = &#123;</span><br><span class="line">  <span class="attr">DEBUG</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">INFO</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">WARN</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">ERROR</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">level = LOG_LEVEL.INFO</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">level</span> = level;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">debug</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">level</span> &lt;= <span class="variable constant_">LOG_LEVEL</span>.<span class="property">DEBUG</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[DEBUG]&#x27;</span>,...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="20-敏感信息过滤"><a href="#20-敏感信息过滤" class="headerlink" title="20. 敏感信息过滤"></a>20. 敏感信息过滤</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个安全日志函数，它接收数据对象，先深度克隆数据，</span></span><br><span class="line"><span class="comment">// 然后删除可能包含敏感信息的字段（如密码、令牌），最后返回过滤后的安全数据，</span></span><br><span class="line"><span class="comment">// 并在控制台输出，确保敏感信息不会意外泄露。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">safeLog</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> filtered = _.<span class="title function_">cloneDeep</span>(data);</span><br><span class="line">  <span class="keyword">delete</span> filtered.<span class="property">password</span>;</span><br><span class="line">  <span class="keyword">delete</span> filtered.<span class="property">token</span>;</span><br><span class="line">  <span class="keyword">return</span> filtered;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户数据:&#x27;</span>, <span class="title function_">safeLog</span>(userData));</span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong>注意</strong>：所有调试代码应在开发环境使用，生产环境需通过构建工具自动移除。 </p>
</blockquote>
]]></content>
      <categories>
        <category>Console</category>
      </categories>
      <tags>
        <tag>Console</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>DeepSeek 本地部署教程</title>
    <url>https://kfufys.github.io/posts/4b037ad9.html</url>
    <content><![CDATA[<img src="https://kfufys.github.io/posts/4b037ad9/1.png" alt="deepseek" width="1200">

<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><h4 id="1-背景分析"><a href="#1-背景分析" class="headerlink" title="1. 背景分析"></a>1. 背景分析</h4><p>DeepSeek 作为国产开源大模型，近期因在线服务压力过大，本地部署需求激增。本教程将结合全网优质资源，手把手教你完成从环境配置到交互界面搭建的全流程，即使是零基础用户也能轻松掌握。</p>
<h4 id="2-为什么要本地部署-DeepSeek？"><a href="#2-为什么要本地部署-DeepSeek？" class="headerlink" title="2. 为什么要本地部署 DeepSeek？"></a>2. 为什么要本地部署 DeepSeek？</h4><p>在本地部署 DeepSeek 有以下几个优势：</p>
<ol>
<li><strong>隐私性高</strong>：数据都在本地运行，无需上传到云端，避免数据泄露风险。</li>
<li><strong>稳定性强</strong>：不受网络波动影响，模型运行更加稳定。</li>
<li><strong>可定制性强</strong>：可以根据需求调整模型参数，满足个性化需求。</li>
</ol>
<h3 id="二、部署前准备"><a href="#二、部署前准备" class="headerlink" title="二、部署前准备"></a>二、部署前准备</h3><h4 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h4><table> 
 <thead> 
  <tr> 
   <th>硬件类型</th> 
   <th>最低配置</th> 
   <th>推荐配置</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td><strong>显卡</strong></td> 
   <td>NVIDIA GTX 1060 (6GB显存)</td> 
   <td>RTX 4080 (16GB显存)</td> 
  </tr> 
  <tr> 
   <td><strong>内存</strong></td> 
   <td>16GB</td> 
   <td>32GB</td> 
  </tr> 
  <tr> 
   <td><strong>存储</strong></td> 
   <td>50GB可用空间</td> 
   <td>SSD固态硬盘</td> 
  </tr> 
  <tr> 
   <td><strong>系统</strong></td> 
   <td>Windows 10 / macOS 12 / Ubuntu 20.04</td> 
   <td>Windows 11</td> 
  </tr> 
 </tbody> 
</table>

<blockquote>
<p>📌 注意事项：</p>
<ul>
<li>AMD 显卡用户需安装 25.1.1 版本驱动并配合 LM Studio 使用</li>
</ul>
</blockquote>
<h3 id="三、核心部署流程"><a href="#三、核心部署流程" class="headerlink" title="三、核心部署流程"></a>三、核心部署流程</h3><h4 id="1-安装-Ollama-框架"><a href="#1-安装-Ollama-框架" class="headerlink" title="1. 安装 Ollama 框架"></a>1. 安装 Ollama 框架</h4><blockquote>
<p>因部署本地 Deepseek 软件官网下载速度较慢，这里有下载好的软件包：</p>
<ul>
<li><strong>主链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly93d3cuMTIzODY1LmNvbS9zLzRDakJqdi01c3NmaA==">https://www.123865.com/s/4CjBjv-5ssfh<i class="fa fa-external-link-alt"></i></span></li>
<li><strong>备用链接</strong>：<span class="exturl" data-url="aHR0cDovL2tmdWZ5cy50b3A6MTIxMjEvcy8yV2lQ">http://kfufys.top:12121/s/2WiP<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<h5 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1 下载安装包"></a>1.1 下载安装包</h5><p>访问 <span class="exturl" data-url="aHR0cHM6Ly9vbGxhbWEuY29tL2Rvd25sb2Fk">Ollama官网<i class="fa fa-external-link-alt"></i></span> → 选择对应系统版本下载（Windows用户建议安装到C盘）</p>
<img src="https://kfufys.github.io/posts/4b037ad9/2.png" alt="download ollama" width="1200">

<p>下载完成后双击运行安装包，下一步，下一步即可。</p>
<h5 id="1-2-验证是否安装成功"><a href="#1-2-验证是否安装成功" class="headerlink" title="1.2 验证是否安装成功"></a>1.2 验证是否安装成功</h5><p>win+R 打开 <code>cmd</code> 命令行，执行命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ollama -v</span><br></pre></td></tr></table></figure>

<img src="https://kfufys.github.io/posts/4b037ad9/5.png" alt="ollama version" width="1200">

<p>如果显示 <code>Ollama</code> 版本号，说明安装成功。</p>
<h5 id="1-3-选择-deepseek-大模型版本"><a href="#1-3-选择-deepseek-大模型版本" class="headerlink" title="1.3 选择 deepseek 大模型版本"></a>1.3 选择 deepseek 大模型版本</h5><p>ollama 安装成功以后，在官网搜索 deepseek，选择 <code>deepseek-r1</code>，如图所示：  </p>
<img src="https://kfufys.github.io/posts/4b037ad9/3.png" alt="deepseek-r1_1" width="1200">

<img src="https://kfufys.github.io/posts/4b037ad9/4.png" alt="deepseek-r1_2" width="1200">

<p>DeepSeek 不同参数版本介绍：</p>
<table> 
 <thead> 
  <tr> 
   <th>模型参数规模</th> 
   <th>典型用途</th> 
   <th>CPU 建议</th> 
   <th>GPU 建议</th> 
   <th>内存建议 (RAM)</th> 
   <th>磁盘空间建议</th> 
   <th>适用场景</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td><strong>1.5b (15亿)</strong></td> 
   <td>小型推理、轻量级任务</td> 
   <td>4核以上 (Intel i5 / AMD Ryzen 5)</td> 
   <td>可选，入门级 GPU (如 NVIDIA GTX 1650, 4GB 显存)</td> 
   <td>8GB</td> 
   <td>10GB 以上 SSD</td> 
   <td>小型 NLP 任务、文本生成、简单分类</td> 
  </tr> 
  <tr> 
   <td><strong>7b (70亿)</strong></td> 
   <td>中等推理、通用任务</td> 
   <td>6核以上 (Intel i7 / AMD Ryzen 7)</td> 
   <td>中端 GPU (如 NVIDIA RTX 3060, 12GB 显存)</td> 
   <td>16GB</td> 
   <td>20GB 以上 SSD</td> 
   <td>中等规模 NLP、对话系统、文本分析</td> 
  </tr> 
  <tr> 
   <td><strong>14b (140亿)</strong></td> 
   <td>中大型推理、复杂任务</td> 
   <td>8核以上 (Intel i9 / AMD Ryzen 9)</td> 
   <td>高端 GPU (如 NVIDIA RTX 3090, 24GB 显存)</td> 
   <td>32GB</td> 
   <td>50GB 以上 SSD</td> 
   <td>复杂 NLP、多轮对话、知识问答</td> 
  </tr> 
  <tr> 
   <td><strong>32b (320亿)</strong></td> 
   <td>大型推理、高性能任务</td> 
   <td>12核以上 (Intel Xeon / AMD Threadripper)</td> 
   <td>高性能 GPU (如 NVIDIA A100, 40GB 显存)</td> 
   <td>64GB</td> 
   <td>100GB 以上 SSD</td> 
   <td>大规模 NLP、多模态任务、研究用途</td> 
  </tr> 
  <tr> 
   <td><strong>70b (700亿)</strong></td> 
   <td>超大规模推理、研究任务</td> 
   <td>16核以上 (服务器级 CPU)</td> 
   <td>多 GPU 并行 (如 2x NVIDIA A100, 80GB 显存)</td> 
   <td>128GB</td> 
   <td>200GB 以上 SSD</td> 
   <td>超大规模模型、研究、企业级应用</td> 
  </tr> 
  <tr> 
   <td><strong>671b (6710亿)</strong></td> 
   <td>超大规模训练、企业级任务</td> 
   <td>服务器级 CPU (如 AMD EPYC / Intel Xeon)</td> 
   <td>多 GPU 集群 (如 8x NVIDIA A100, 320GB 显存)</td> 
   <td>256GB 或更高</td> 
   <td>1TB 以上 NVMe SSD</td> 
   <td>超大规模训练、企业级 AI 平台</td> 
  </tr> 
 </tbody> 
</table>

<p>根据你本地电脑的配置选择合适的参数，例如我们选择 <code>1.5b</code>这个参数，运行代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ollama run deepseek-r1:<span class="number">1.</span>5b</span><br></pre></td></tr></table></figure>

<p>等待下载完毕，下载完成后就可以愉快的在本地使用大模型了，如图所示：</p>
<img src="https://kfufys.github.io/posts/4b037ad9/6.png" alt="ollama session" width="1200"> 

<h4 id="2-可视化部署-Web-UI"><a href="#2-可视化部署-Web-UI" class="headerlink" title="2. 可视化部署 Web UI"></a>2. 可视化部署 Web UI</h4><p>使用命令行进行对话很不方便，可以使用一些 UI 工具来更方便的和 deepseek 进行交互。</p>
<h5 id="2-1-常用-AI-UI-工具"><a href="#2-1-常用-AI-UI-工具" class="headerlink" title="2.1 常用 AI UI 工具"></a>2.1 常用 AI UI 工具</h5><table> 
 <thead> 
  <tr> 
   <th>工具</th> 
   <th>描述</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td><strong><span class="exturl" data-url="aHR0cHM6Ly9jaGF0Ym94YWkuYXBwL3po">Chatbox<i class="fa fa-external-link-alt"></i></span></strong></td> 
   <td>一个支持多种流行LLM模型的桌面客户端，可在 Windows、Mac 和 Linux 上使用</td> 
  </tr> 
  <tr> 
   <td><strong><span class="exturl" data-url="aHR0cHM6Ly9jaGVycnktYWkuY29tLw==">Cherry Studio<i class="fa fa-external-link-alt"></i></span></strong></td> 
   <td>一款为创造者而生的桌面版 AI 助手</td> 
  </tr> 
  <tr> 
   <td><strong><span class="exturl" data-url="aHR0cHM6Ly9hbnl0aGluZ2xsbS5jb20v">AnythingLLM<i class="fa fa-external-link-alt"></i></span></strong></td> 
   <td>一款全方位AI应用程序。与您的文档聊天，使用AI代理，高度可配置，多用户，无需繁琐的设置。</td> 
  </tr> 
 </tbody> 
</table>

<p>这里我们使用 ChatBox 调用 DeepSeek 进行交互，其他工具使用方式类似。</p>
<h5 id="2-2-ChatBox-使用示例"><a href="#2-2-ChatBox-使用示例" class="headerlink" title="2.2 ChatBox 使用示例"></a>2.2 ChatBox 使用示例</h5><blockquote>
<p>ChatBox 官网地址：<span class="exturl" data-url="aHR0cHM6Ly9jaGF0Ym94YWkuYXBwL3po">https://chatboxai.app/zh<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>下载自己操作系统的安装包，进行安装。</p>
<img src="https://kfufys.github.io/posts/4b037ad9/7.png" alt="ChatBox" width="1200"> 

<p>安装完 Chatbox 之后就是配置 DeepSeek 到 Chatbox 了，如图：</p>
<img src="https://kfufys.github.io/posts/4b037ad9/8.png" alt="Config ChatBox_1" width="1200"> 

<p>配置 AI 模型提供方，这里选择 Ollama，如图：</p>
<img src="https://kfufys.github.io/posts/4b037ad9/9.png" alt="Config ChatBox_2" width="1200"> 

<p>选择 deepseek 模型</p>
<img src="https://kfufys.github.io/posts/4b037ad9/10.png" alt="Config ChatBox_3" width="1200"> 

<p>配置完成以后就可以在界面上和本地 deepseek 模型进行聊天交互了，如图：</p>
<img src="https://kfufys.github.io/posts/4b037ad9/11.png" alt="Config ChatBox_4" width="1200"> 

<p>至此，已完成了 DeepSeek-R1 的本地部署，小白也能轻松搞定，快来试试吧，开启你的本地大模型之旅！</p>
]]></content>
      <categories>
        <category>AI工具</category>
      </categories>
      <tags>
        <tag>AIGC</tag>
        <tag>DeepSeek</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Next 主题个性化配置教程</title>
    <url>https://kfufys.github.io/posts/9aae07a1.html</url>
    <content><![CDATA[<img src="https://kfufys.github.io/posts/9aae07a1/8.png" alt="head-img" width="1200">

<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>因为本人是比较喜欢简约风格的，所以整个网站UI界面都是<code>简约风格</code>的，一个好的博客，应该让人一眼就能看清楚技术分类，文章也应该就是文章，让人能够最好的阅读你的博客，这才是我们应该做的，所以我的配置教程满满干货，没有太多花里胡哨的东西。接下来跟我一起来做吧：</p>
<h3 id="二、开发工具"><a href="#二、开发工具" class="headerlink" title="二、开发工具"></a>二、开发工具</h3><blockquote>
<p><a href="https://git-scm.cn"><strong>Git</strong></a> –&gt; 推送更新，本地修改推至远程库后自动部署。</p>
<p><a href="https://nodejs.org/zh-cn"><strong>Node.js</strong></a> –&gt; 免费、开源、跨平台的 JavaScript 运行时环境。</p>
<p><a href="https://github.com"><strong>GitHub</strong></a> –&gt; 负责托管代码与展示内容。</p>
<p><a href="https://www.dcloud.io/hbuilderx.html"><strong>HBuilderX</strong></a> –&gt; DCloud 推出的一款支持 HTML5 的 Web 开发 IDE。</p>
<p><a href="https://www.microsoft.com/en-us/edge/download"><strong>EDGE</strong> 浏览器 F12 开发者选项</a> –&gt;帮助开发者调试和检查 Web 页面。</p>
</blockquote>
<h3 id="三、Hexo-部署"><a href="#三、Hexo-部署" class="headerlink" title="三、Hexo 部署"></a>三、Hexo 部署</h3><blockquote>
<p>部署方式请参考：<a href="https://kfufys.github.io/posts/60795.html"><strong>基于GitHub+hexo部署静态Blog</strong></a></p>
</blockquote>
<h3 id="四、配置文件说明"><a href="#四、配置文件说明" class="headerlink" title="四、配置文件说明"></a>四、配置文件说明</h3><p>Hexo 中有两份重要的配置文件，其名称都是 <code>_config.yml</code>。</p>
<ul>
<li>位于站点根目录的 <code>_config.yml</code>，主要配置 Hexo 本身。</li>
<li>位于主题目录的 <code>_config.yml</code>，主要配置主题相关的参数。</li>
</ul>
<p>为了描述方便，在以下教程中，将前者称为 <code>站点配置文件</code>， 后者称为 <code>主题配置文件</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">站点配置文件 --&gt; /hexo/_config.yml</span><br><span class="line">主题配置文件 --&gt; /hexo/themes/next/_config.yml</span><br></pre></td></tr></table></figure>


<h3 id="五、开始配置"><a href="#五、开始配置" class="headerlink" title="五、开始配置"></a>五、开始配置</h3><h4 id="1-配置站点名、作者昵称和站点描述等内容"><a href="#1-配置站点名、作者昵称和站点描述等内容" class="headerlink" title="1. 配置站点名、作者昵称和站点描述等内容"></a>1. 配置站点名、作者昵称和站点描述等内容</h4><p>打开站点配置文件，搜索 <code>Site</code>，找到如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title:  # 站点标题</span><br><span class="line">subtitle:   # 站点副标题</span><br><span class="line">description:    # 站点描述 </span><br><span class="line">keywords:   # 站点关键字</span><br><span class="line">author:     # 站长</span><br><span class="line">language:   # 站点语言，例如：中文（zh-CN）</span><br><span class="line">timezone:   # 站点时区，例如：上海（Asia/Shanghai）</span><br></pre></td></tr></table></figure>

<p>根据注释修改配置。</p>
<h4 id="2-新建标签及分类界面"><a href="#2-新建标签及分类界面" class="headerlink" title="2. 新建标签及分类界面"></a>2. 新建标签及分类界面</h4><p>打开主题配置文件，搜索 <code>menu</code>，找到如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  #tags: /tags/ || tags</span><br><span class="line">  #categories: /categories/ || th</span><br><span class="line">  #archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /<span class="number">404</span>/ || heartbeat</span><br></pre></td></tr></table></figure>

<p>把 tags 和 categories 前面的 <code>#</code> 删除。</p>
<h4 id="3-切换主题"><a href="#3-切换主题" class="headerlink" title="3. 切换主题"></a>3. 切换主题</h4><p>在主题配置文件 <code>/next/_config.yml</code> 中查找：<code>scheme</code>，找到如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br></pre></td></tr></table></figure>

<p>选择你喜欢的一种样式（<code>scheme</code>），去掉前面的 <code>#</code>，推荐 <code>Gemini</code> 主题。</p>
<h4 id="4-隐藏网页底部-powered-By-Hexo-强力驱动"><a href="#4-隐藏网页底部-powered-By-Hexo-强力驱动" class="headerlink" title="4. 隐藏网页底部 powered By Hexo &#x2F; 强力驱动"></a>4. 隐藏网页底部 powered By Hexo &#x2F; 强力驱动</h4><p>打开 <code>themes/next/layout/\_partials/footer.njk</code> 文件，找到如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.footer.powered.enable %&#125;</span><br><span class="line">    &lt;div class=<span class="string">&quot;powered-by&quot;</span>&gt;&#123;#</span><br><span class="line">    #&#125;&#123;&#123; __(<span class="string">&#x27;footer.powered&#x27;</span>, <span class="string">&#x27;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot;&#x27;</span> + nofollow + <span class="string">&#x27; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&#x27;</span>) &#125;&#125;&#123;% <span class="keyword">if</span> theme.footer.powered.version %&#125; v&#123;&#123; hexo_env(<span class="string">&#x27;version&#x27;</span>) &#125;&#125;&#123;% endif %&#125;&#123;#</span><br><span class="line">    #&#125;&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">if</span> theme.footer.powered.enable and theme.footer.theme.enable %&#125;</span><br><span class="line">    &lt;span class=<span class="string">&quot;post-meta-divider&quot;</span>&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">if</span> theme.footer.theme.enable %&#125;</span><br><span class="line">    &lt;div class=<span class="string">&quot;theme-info&quot;</span>&gt;&#123;#</span><br><span class="line">    #&#125;&#123;&#123; __(<span class="string">&#x27;footer.theme&#x27;</span>) &#125;&#125; – &#123;#</span><br><span class="line">    #&#125;&lt;a class=<span class="string">&quot;theme-link&quot;</span> target=<span class="string">&quot;_blank&quot;</span>&#123;&#123; nofollow &#125;&#125; href=<span class="string">&quot;https://theme-next.org&quot;</span>&gt;&#123;#</span><br><span class="line">    #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;#</span><br><span class="line">    #&#125;&lt;/a&gt;&#123;% <span class="keyword">if</span> theme.footer.theme.version %&#125; v&#123;&#123; version &#125;&#125;&#123;% endif %&#125;&#123;#</span><br><span class="line">    #&#125;&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>把这段代码首尾分别加上：<code>&lt;!--</code> 和 <code>--&gt;</code>，或者直接删除。</p>
<h4 id="5-添加文章阴影"><a href="#5-添加文章阴影" class="headerlink" title="5. 添加文章阴影"></a>5. 添加文章阴影</h4><p>打开 <code>/themes/next/source/css/\_custom/custom.styl</code> 文件，添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.post &#123;</span><br><span class="line">    margin-top: 60px;</span><br><span class="line">    margin-bottom: 60px;</span><br><span class="line">    padding: 25px;</span><br><span class="line">    -webkit-box-shadow: <span class="number">0</span> <span class="number">0</span> 5px <span class="title function_">rgba</span><span class="params">(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, <span class="number">.5</span>)</span>;</span><br><span class="line">    -moz-box-shadow: <span class="number">0</span> <span class="number">0</span> 5px <span class="title function_">rgba</span><span class="params">(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">.5</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-浏览页面显示当前浏览进度"><a href="#6-浏览页面显示当前浏览进度" class="headerlink" title="6. 浏览页面显示当前浏览进度"></a>6. 浏览页面显示当前浏览进度</h4><p>打开 <code>themes/next/\_config.yml</code> 文件，搜索 <code>scrollpercent</code>，把 false 改为 <code>true</code>。</p>
<p><strong>效果图</strong>：</p>
<img src="https://kfufys.github.io/posts/9aae07a1/1.png" alt="View progress rendering" width="1200">


<h4 id="7-Local-Search-本地搜索"><a href="#7-Local-Search-本地搜索" class="headerlink" title="7. Local Search 本地搜索"></a>7. Local Search 本地搜索</h4><p>安装插件 <code>hexo-generator-searchdb</code>，按 <code>win+r</code> 快捷键输入 <code>cmd</code> 回车，打开命令行工具，执行以下命令:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>修改站点配置文件，新增以下内容到任意位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#本地搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>编辑主题配置文件，启用本地搜索功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>效果图</strong>：</p>
<img src="https://kfufys.github.io/posts/9aae07a1/3.png" alt="Local search1" width="1200">
<br><br>
<img src="https://kfufys.github.io/posts/9aae07a1/2.png" alt="Local search2" width="1200">


<h4 id="8-设置网站图标"><a href="#8-设置网站图标" class="headerlink" title="8. 设置网站图标"></a>8. 设置网站图标</h4><p>你可以制作或找一个喜欢的图标，在 <a href="https://www.zhanid.com/tool/ico.html"><strong>ZHANID</strong></a> 转换成 ico 图标，下载到本地 <code>/themes/next/source/images</code> 文件夹里，并且修改主题配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  #small: /images/favicon-16x16-next.png</span><br><span class="line">  #medium: /images/favicon.ico</span><br><span class="line">  #apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  #safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /manifest.json</span><br></pre></td></tr></table></figure>

<p>去掉 <code>medium</code> 前面的 <code>#</code>。</p>
<p><strong>效果图</strong>：</p>
<img src="https://kfufys.github.io/posts/9aae07a1/4.png" alt="Website Icons" width="1200">


<h4 id="9-文章底部的-号的标签，改为图标"><a href="#9-文章底部的-号的标签，改为图标" class="headerlink" title="9. 文章底部的 # 号的标签，改为图标"></a>9. 文章底部的 <code>#</code> 号的标签，改为图标</h4><p>打开 <code>/themes/next/layout/_macro/post.swig</code> 文件，修改以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rel=<span class="string">&#x27;tag&#x27;</span>&gt;#</span><br><span class="line"># 改为：</span><br><span class="line">rel=<span class="string">&#x27;tag&#x27;</span>&gt;&lt;i class=<span class="string">&quot;fa fa-tag&quot;</span>&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure>

<p><strong>效果图</strong>：</p>
<img src="https://kfufys.github.io/posts/9aae07a1/5.png" alt="tags Icons" width="1200">


<h4 id="10-文章分享功能"><a href="#10-文章分享功能" class="headerlink" title="10. 文章分享功能"></a>10. 文章分享功能</h4><p>打开<code>themes/next/_config.yml</code> 搜索关键字<code>needmoreshare2</code> 修改为下面设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">needmoreshare2:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  postbottom:</span><br><span class="line">    enable: <span class="literal">true</span></span><br><span class="line">    options:</span><br><span class="line">      iconStyle: <span class="keyword">default</span></span><br><span class="line">      boxForm: horizontal</span><br><span class="line">      #位置</span><br><span class="line">      position: bottomCenter</span><br><span class="line">      #可分享网站</span><br><span class="line">      networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span><br><span class="line">  <span class="type">float</span>:</span><br><span class="line">    enable: <span class="literal">true</span></span><br><span class="line">    options:</span><br><span class="line">      iconStyle: <span class="keyword">default</span></span><br><span class="line">      boxForm: vertical</span><br><span class="line">      #位置</span><br><span class="line">      position: topRight</span><br><span class="line">       #可分享网站</span><br><span class="line">      networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span><br></pre></td></tr></table></figure>


<h4 id="11-文章加密访问"><a href="#11-文章加密访问" class="headerlink" title="11. 文章加密访问"></a>11. 文章加密访问</h4><p>打开 <code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code> 文件，插入代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;&#123;&#123; page.password &#125;&#125;&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (prompt(<span class="string">&#x27;请输入文章密码&#x27;</span>) !== <span class="string">&#x27;&#123;&#123; page.password &#125;&#125;&#x27;</span>)&#123;</span><br><span class="line">            alert(<span class="string">&#x27;密码错误！&#x27;</span>);</span><br><span class="line">            history.back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>写文章时在 Front-matter 部分加入 <code>password</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="comment">// title: Hexo-Next 主题个性化配置教程</span></span><br><span class="line"><span class="comment">// copyright: true</span></span><br><span class="line"><span class="comment">// tags:</span></span><br><span class="line"><span class="comment">//   - 教程</span></span><br><span class="line"><span class="comment">//   - 个性化</span></span><br><span class="line"><span class="comment">//   - Hexo-Next</span></span><br><span class="line"><span class="comment">//   - Blog Themes</span></span><br><span class="line"><span class="comment">// categories: Themes 配置</span></span><br><span class="line"><span class="comment">// abbrlink: 9aae07a1</span></span><br><span class="line"><span class="comment">// date: 2025-02-17 08:46:47</span></span><br><span class="line"><span class="comment">// updated: 2025-02-17 08:46:47</span></span><br><span class="line"><span class="comment">// description:</span></span><br><span class="line">password: <span class="number">123456</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>


<h4 id="12-增加文章字数统计及阅读时长功能"><a href="#12-增加文章字数统计及阅读时长功能" class="headerlink" title="12. 增加文章字数统计及阅读时长功能"></a>12. 增加文章字数统计及阅读时长功能</h4><p>安装插件 <code>hexo-wordcount</code> ，执行以下命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>

<p>在主题配置文件中搜索 <code>symbols_count_time</code>，修改成如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https:<span class="comment">//github.com/next-theme/hexo-word-counter</span></span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: <span class="literal">true</span></span><br><span class="line">  item_text_post: <span class="literal">true</span> # 文章字数统计</span><br><span class="line">  item_text_total: <span class="literal">true</span> # 站点总字数统计</span><br><span class="line">  # 平均单词长度（单词的计数）。默认值:<span class="number">4</span>。CN≈<span class="number">2</span> EN≈<span class="number">5</span> 俄文≈<span class="number">6</span></span><br><span class="line">  awl: <span class="number">2</span></span><br><span class="line">  # 每分钟的单词。默认值:<span class="number">275</span>。缓慢≈<span class="number">200</span> 正常≈<span class="number">275</span> 快≈<span class="number">350</span></span><br><span class="line">  wpm: <span class="number">275</span></span><br></pre></td></tr></table></figure>


<h4 id="13-文章置顶功能"><a href="#13-文章置顶功能" class="headerlink" title="13. 文章置顶功能"></a>13. 文章置顶功能</h4><p>移除默认安装的插件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br></pre></td></tr></table></figure>

<p>安装新插件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>

<p>写需要置顶的文章时，在 Front-matter 区域，加上一行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">top: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>如果置顶多篇，怎么控制顺序呢？</strong></p>
<p><strong>答</strong>：设置top的值（大的在前面）。</p>
</blockquote>
<p>例如（文章 b 会显示在文章 a 的前面）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Post a.md</span><br><span class="line">title: a</span><br><span class="line">top: <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># Post b.md</span><br><span class="line">title: b</span><br><span class="line">top: <span class="number">10</span></span><br></pre></td></tr></table></figure>


<h4 id="14-设置置顶图标"><a href="#14-设置置顶图标" class="headerlink" title="14. 设置置顶图标"></a>14. 设置置顶图标</h4><p>打开 <code>/themes/next/layout/_macro/post.swig</code> 文件，在 <code>&lt;div class=&quot;post-meta&quot;&gt;</code> 下方，插入如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> post.top %&#125;</span><br><span class="line">    &lt;i class=<span class="string">&quot;fa fa-thumb-tack&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">    &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class="line">    &lt;span class=<span class="string">&quot;post-meta-divider&quot;</span>&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>


<h4 id="15-修改-Read-More-按钮样式"><a href="#15-修改-Read-More-按钮样式" class="headerlink" title="15. 修改 Read More 按钮样式"></a>15. 修改 <code>Read More</code> 按钮样式</h4><p>修改 <code>themes\next\source\css\_custom\custom.styl</code> 文件，加入自定义样式代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Read More按钮样式</span></span><br><span class="line">.post-button .btn &#123;</span><br><span class="line">    color: #<span class="number">555</span> !important;</span><br><span class="line">    background-color: rgb(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">    font-size: 15px;</span><br><span class="line">    box-shadow: inset 0px 0px 10px 0px <span class="title function_">rgba</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.35</span>)</span>;</span><br><span class="line">    border: none !important;</span><br><span class="line">    transition-property: unset;</span><br><span class="line">    padding: 0px 15px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.post-button .btn:hover &#123;</span><br><span class="line">    color: rgb(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>) !important;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">    font-size: 15px;</span><br><span class="line">    box-shadow: inset 0px 0px 10px 0px <span class="title function_">rgba</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.35</span>)</span>;</span><br><span class="line">    background-image: linear-gradient(90deg, #a166ab <span class="number">0</span>%, #ef4e7b <span class="number">25</span>%, #f37055 <span class="number">50</span>%, #ef4e7b <span class="number">75</span>%, #a166ab <span class="number">100</span>%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果图</strong>：</p>
<img src="https://kfufys.github.io/posts/9aae07a1/6.png" alt="Read More" width="1200">


<h4 id="16-修改阅读全文前显示文字数量即位置"><a href="#16-修改阅读全文前显示文字数量即位置" class="headerlink" title="16. 修改阅读全文前显示文字数量即位置"></a>16. 修改阅读全文前显示文字数量即位置</h4><p>打开 <code>themes/next/_config.yml</code> 文件，搜索 <code>auto_excerpt</code>， 修改 <code>length</code> 即可修改阅读全文前显示文字数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  length: <span class="number">150</span></span><br></pre></td></tr></table></figure>

<p>或者在文章中加入 <code>&lt;!-- more --&gt;</code> 自定义在 <code>Read More</code>按钮之前要显示的内容。</p>
<h4 id="17-修改链接文字样式"><a href="#17-修改链接文字样式" class="headerlink" title="17. 修改链接文字样式"></a>17. 修改链接文字样式</h4><p>打开 <code>themes\next\source\css\_common\components\post\post.styl</code> 文件，添加以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">     color: #0593d3;</span><br><span class="line">     border-bottom: none;</span><br><span class="line">     &amp;:hover &#123;</span><br><span class="line">        color: #ff106c;</span><br><span class="line">        text-decoration: underline;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="18-头像设置圆形，停留旋转效果"><a href="#18-头像设置圆形，停留旋转效果" class="headerlink" title="18. 头像设置圆形，停留旋转效果"></a>18. 头像设置圆形，停留旋转效果</h4><p>修改 <code>themes\next\source\css\_common\components\sidebar\sidebar-author.styl</code> 文件，新增以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.site-author-image &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin: <span class="number">0</span> auto;</span><br><span class="line">  padding: $site-author-image-padding;</span><br><span class="line">  max-width: $site-author-image-width;</span><br><span class="line">  height: $site-author-image-height;</span><br><span class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  <span class="comment">//设置圆形</span></span><br><span class="line">+  border-radius: <span class="number">50</span>%;</span><br><span class="line">+  transition: 2s all;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//旋转</span></span><br><span class="line">+ .site-author-image:hover&#123;</span><br><span class="line">+   transform: rotate(360deg);</span><br><span class="line">+ &#125;</span><br></pre></td></tr></table></figure>


<h4 id="19-文章添加阴影效果-文章边框"><a href="#19-文章添加阴影效果-文章边框" class="headerlink" title="19. 文章添加阴影效果(文章边框)"></a>19. 文章添加阴影效果(文章边框)</h4><p>打开 <code>themes/next/source/css/_custom/custom.styl</code> 文件，新增以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.post &#123;</span><br><span class="line">  margin-top: 60px;</span><br><span class="line">  margin-bottom: 60px;</span><br><span class="line">  padding: 25px;</span><br><span class="line">  -webkit-box-shadow: <span class="number">0</span> <span class="number">0</span> 5px <span class="title function_">rgba</span><span class="params">(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, <span class="number">.5</span>)</span>;</span><br><span class="line">  -moz-box-shadow: <span class="number">0</span> <span class="number">0</span> 5px <span class="title function_">rgba</span><span class="params">(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">.5</span>)</span>;</span><br><span class="line"> &#125; ​​</span><br></pre></td></tr></table></figure>

<h4 id="20-近期文章"><a href="#20-近期文章" class="headerlink" title="20. 近期文章"></a>20. 近期文章</h4><p>打开 <code>themes/next/layout/_macro/sidebar.swig</code> 文件，找到 <code>theme.social</code> 板块代码，在该板块最后的<code>end if</code> 后隔一行添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;# recent posts #&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.recent_posts %&#125;</span><br><span class="line">  &lt;div class=<span class="string">&quot;links-of-blogroll motion-element &#123;&#123; &quot;</span>links-of-blogroll-<span class="string">&quot; + theme.recent_posts_layout  &#125;&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;links-of-blogroll-title&quot;</span>&gt;</span><br><span class="line">      &lt;!-- modify icon to fire by szw --&gt;</span><br><span class="line">      &lt;i class=<span class="string">&quot;fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot;</span> aria-hidden=<span class="string">&quot;true&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">      &#123;&#123; theme.recent_posts_title &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;ul class=<span class="string">&quot;links-of-blogroll-list&quot;</span>&gt;</span><br><span class="line">      &#123;% <span class="type">set</span> <span class="variable">posts</span> <span class="operator">=</span> site.posts.sort(<span class="string">&#x27;-date&#x27;</span>) %&#125;</span><br><span class="line">      &#123;% <span class="keyword">for</span> post in posts.slice(<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;5&#x27;</span>) %&#125;</span><br><span class="line">        &lt;li class=<span class="string">&quot;recent_posts_li&quot;</span>&gt;</span><br><span class="line">          &lt;a href=<span class="string">&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;</span> title=<span class="string">&quot;&#123;&#123; post.title &#125;&#125;&quot;</span> target=<span class="string">&quot;_blank&quot;</span>&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      &#123;% endfor %&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>打开 <code>themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl</code> 文件，添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">li.recent_posts_li &#123;</span><br><span class="line">    text-align: cengter;</span><br><span class="line">    display: block;</span><br><span class="line">    word-<span class="keyword">break</span>: keep-all;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>themes/next/_config.yml</code> 文件中添加下方代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 近期文章设置</span><br><span class="line">recent_posts_title: 近期文章</span><br><span class="line">recent_posts_layout: block</span><br><span class="line">recent_posts: <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<h4 id="21-添加代码块复制按钮"><a href="#21-添加代码块复制按钮" class="headerlink" title="21. 添加代码块复制按钮"></a>21. 添加代码块复制按钮</h4><blockquote>
<p><strong>说明</strong>：Next6 中自带了复制代码按钮，Next5 需要自己手动配置。</p>
</blockquote>
<p>在主题配置文件中搜索 <code>codeblock</code>，把默认配置改为如下配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # All available themes: https:<span class="comment">//theme-next.js.org/highlight/</span></span><br><span class="line">  theme:</span><br><span class="line">    light: <span class="keyword">default</span></span><br><span class="line">    dark: stackoverflow-dark</span><br><span class="line">  prism:</span><br><span class="line">    light: prism</span><br><span class="line">    dark: prism-dark</span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: enable</span><br><span class="line">    show_result: <span class="literal">true</span></span><br><span class="line">    # Available values: <span class="keyword">default</span> | flat | mac</span><br><span class="line">    style: mac</span><br><span class="line">  # Fold code block</span><br><span class="line">  fold:</span><br><span class="line">    enable: <span class="literal">false</span></span><br><span class="line">    height: <span class="number">500</span></span><br></pre></td></tr></table></figure>


<h4 id="22-添加加载特效"><a href="#22-添加加载特效" class="headerlink" title="22. 添加加载特效"></a>22. 添加加载特效</h4><p>在主题配置文件中搜索 <code>pace</code>，找的如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Progress bar in the top during page loading.</span><br><span class="line"># For more information: https:<span class="comment">//github.com/CodeByZach/pace</span></span><br><span class="line">pace:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  # All available colors:</span><br><span class="line">  # black | blue | green | orange | pink | purple | red | silver | white | yellow</span><br><span class="line">  color: silver</span><br><span class="line">  # All available themes:</span><br><span class="line">  # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span><br><span class="line">  # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span><br><span class="line">  theme: flash</span><br></pre></td></tr></table></figure>

<p>根据注释进行修改。</p>
<h4 id="23-添加到顶部按钮"><a href="#23-添加到顶部按钮" class="headerlink" title="23. 添加到顶部按钮"></a>23. 添加到顶部按钮</h4><p>在主题配置文件中搜索 <code>back2top</code> ，把 <code>enable</code> 参数值设为 <code>true</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: <span class="literal">false</span></span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="24-修改文章链接"><a href="#24-修改文章链接" class="headerlink" title="24. 修改文章链接"></a>24. 修改文章链接</h4><blockquote>
<p>优化 Hexo 永久链接格式常用的插件有 <a href="https://github.com/ohroy/hexo-abbrlink"><strong>hexo-abbrlink</strong></a> 和 <a href="https://github.com/rozbo/hexo-abbrlink2"><strong>hexo-abbrlink2</strong></a> 两款插件</p>
</blockquote>
<p>在 Hexo 根目录打开终端安装插件（<code>hexo-abbrlink</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 使用 npm 安装插件</span><br><span class="line">npm install hexo-abbrlink --save</span><br><span class="line"># 使用 yarn 安装插件</span><br><span class="line">yarn add hexo-abbrlink</span><br></pre></td></tr></table></figure>

<p>修改 Hexo 的站点配置文件的 <code>permalink</code> 字段，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">permalink: posts/:abbrlink/  #文章结尾不带 .html</span><br><span class="line"># 或者</span><br><span class="line">permalink: posts/:abbrlink.html  #文章结尾带 .html</span><br></pre></td></tr></table></figure>

<p>然后在 Hexo 的站点配置文件里增加 hexo-abbrlink 插件的配置代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># hexo-abbrlink</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32      #支持crc16和crc32算法（默认crc16）</span><br><span class="line">  rep: hex        #支持dec和hex值（默认dec）</span><br><span class="line">  drafts: <span class="literal">false</span>   #(<span class="literal">true</span>)Process draft,(<span class="literal">false</span>)Do not process draft. <span class="literal">false</span>(<span class="keyword">default</span>) </span><br><span class="line">  # Generate categories from directory-tree</span><br><span class="line">  # depth: the max_depth of directory-tree you want to generate, should &gt; <span class="number">0</span></span><br><span class="line">  auto_category:</span><br><span class="line">     enable: <span class="literal">true</span>  #<span class="literal">true</span>(<span class="keyword">default</span>)</span><br><span class="line">     depth:        #<span class="number">3</span>(<span class="keyword">default</span>)</span><br><span class="line">     over_write: <span class="literal">false</span> </span><br><span class="line">  auto_title: <span class="literal">false</span> #enable auto title, it can auto fill the title by path</span><br><span class="line">  auto_date: <span class="literal">false</span> #enable auto date, it can auto fill the date by time today</span><br><span class="line">  force: <span class="literal">false</span> #enable force mode,in <span class="built_in">this</span> mode, the plugin will ignore the cache, and calc the abbrlink <span class="keyword">for</span> every post even it already had abbrlink.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认情况下，新建文章后，abbrlink 插件会自动使用算法生成唯一的永久链接，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#crc16 &amp; hex</span><br><span class="line">https:<span class="comment">//localhost/posts/66c8.html</span></span><br><span class="line"># crc16 &amp; dec</span><br><span class="line">https:<span class="comment">//localhost/posts/65535.html</span></span><br><span class="line"># crc32 &amp; hex</span><br><span class="line">https:<span class="comment">//localhost/posts/8ddf18fb.html</span></span><br><span class="line"># crc32 &amp; dec</span><br><span class="line">https:<span class="comment">//localhost/posts/1690090958.html</span></span><br></pre></td></tr></table></figure>

<p>也可以在文章的 <code>front-matter</code> 部分手动填写 abbrlink 字段的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">title: 优化 Hexo 的永久链接</span><br><span class="line">toc: <span class="literal">true</span></span><br><span class="line">abbrlink: hexo-permalinks #注意这部分</span><br><span class="line">date: <span class="number">2020</span>-<span class="number">06</span>-<span class="number">07</span> <span class="number">23</span>:<span class="number">35</span>:<span class="number">40</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>局限性</strong>: <code>crc16 算法</code> 生成的最大文章数量为 65535，不过这个对绝大多数人都几乎没影响，如果一个 abbrlink 的值已存在，那么它会尝试其他可用的值。</p>
</blockquote>
<h4 id="25-页脚添加访客量"><a href="#25-页脚添加访客量" class="headerlink" title="25. 页脚添加访客量"></a>25. 页脚添加访客量</h4><p>在 footer 模板文件（<code>themes/next/layout/_partials/footer.swig</code>）底部添加以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;powered-by&quot;</span>&gt;</span><br><span class="line">    &lt;script async src=<span class="string">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;i class=<span class="string">&quot;fa fa-user-md&quot;</span>&gt;&lt;/i&gt;</span><br><span class="line">    &lt;span id=<span class="string">&quot;busuanzi_container_site_uv&quot;</span>&gt;</span><br><span class="line">        本站访客数:&lt;span id=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;span class=<span class="string">&quot;post-meta-divider&quot;</span>&gt;|&lt;/span&gt;</span><br><span class="line">    &lt;span id=<span class="string">&quot;busuanzi_container_site_pv&quot;</span>&gt;</span><br><span class="line">        本站访问量&lt;span id=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>


<h4 id="26-各版块透明度修改"><a href="#26-各版块透明度修改" class="headerlink" title="26. 各版块透明度修改"></a>26. 各版块透明度修改</h4><h5 id="26-1-内容板块透明化"><a href="#26-1-内容板块透明化" class="headerlink" title="26.1 内容板块透明化"></a>26.1 内容板块透明化</h5><p>博客根目录 <code>themes\next\source\css_schemes\Pisces_layout.styl</code> 文件 <code>.content-wrap</code> 标签下 <code>background: white</code> 修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">background: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.7</span>); <span class="comment">//0.7是透明度</span></span><br></pre></td></tr></table></figure>

<p>博客根目录 <code>themes\next\source\css_schemes\Gemini\index.styl</code> 文件 <code>.post-block</code> 标签下的 <code>background: white</code> 修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">background: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.7</span>); <span class="comment">//0.7是透明度</span></span><br></pre></td></tr></table></figure>

<h5 id="26-2-分页板块透明化"><a href="#26-2-分页板块透明化" class="headerlink" title="26.2 分页板块透明化"></a>26.2 分页板块透明化</h5><p>博客根目录 <code>themes\next\source\css_schemes\Gemini\index.styl</code> 文件 <code>.pagination</code> 标签下的 <code>background: white</code> 修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">background: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.7</span>); <span class="comment">//0.7是透明度</span></span><br></pre></td></tr></table></figure>

<h5 id="26-3-菜单栏板块透明化"><a href="#26-3-菜单栏板块透明化" class="headerlink" title="26.3 菜单栏板块透明化"></a>26.3 菜单栏板块透明化</h5><p>博客根目录 <code>themes\next\source\css_schemes\Pisces_layout.styl</code> 文件 <code>.header-inner</code> 标签下 <code>background: white</code> 修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">background: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.7</span>); <span class="comment">//0.7是透明度</span></span><br></pre></td></tr></table></figure>

<p>博客根目录 <code>themes\next\source\css_schemes\Pisces_sidebar.styl</code> 文件 <code>.sidebar</code> 标签下增加一行:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">opacity: <span class="number">0.7</span>; <span class="comment">// 0.7透明度自己选择</span></span><br></pre></td></tr></table></figure>

<h5 id="26-4-站点概况背景"><a href="#26-4-站点概况背景" class="headerlink" title="26.4 站点概况背景"></a>26.4 站点概况背景</h5><p>博客根目录 <code>themes\next\source\css_schemes\Pisces_sidebar.styl</code> 文件 <code>.sidebar-inner</code> 标签下 <code>background: white</code> 修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">background: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.7</span>); <span class="comment">//0.7是透明度</span></span><br></pre></td></tr></table></figure>
<p>然后修改博客根目录 <code>themes\next\source\css_schemes\Pisces_layout.styl</code> 文件 <code>.sidebar</code> 标签下 <code>background: $body-bg-color</code> 修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">background: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.7</span>); <span class="comment">//0.7是透明度</span></span><br></pre></td></tr></table></figure>

<h5 id="26-5-评论区背景"><a href="#26-5-评论区背景" class="headerlink" title="26.5 评论区背景"></a>26.5 评论区背景</h5><p>博客根目录 <code>themes\next\source\css_schemes\Gemini\index.styl</code> 文件 <code>.comments</code> 标签下的 <code>background: white</code> 修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">background: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.7</span>); <span class="comment">//0.7是透明度</span></span><br></pre></td></tr></table></figure>


<h4 id="27-更改默认-Google-字体库"><a href="#27-更改默认-Google-字体库" class="headerlink" title="27. 更改默认 Google 字体库"></a>27. 更改默认 Google 字体库</h4><blockquote>
<p>访问网站总是会耗费一大部分的时间在加载 <code>google</code> 字体库上, 而且经常加载不成功。我们可以用国内的 <code>CDN库</code> 来替代主题中的 <code>google</code> 字体库。</p>
</blockquote>
<p>打开主题配置文件，搜索 <code>Font Settings</code> 字体库设置板块，把字体库服务器 <code>host</code> 改为国内CDN库（<a href="fonts.useso.com">fonts.useso.com</a>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Uri of fonts host, e.g. https:<span class="comment">//fonts.googleapis.com (Default).</span></span><br><span class="line">#host:</span><br><span class="line">host: fonts.useso.com</span><br></pre></td></tr></table></figure>


<h4 id="28-设置头像"><a href="#28-设置头像" class="headerlink" title="28. 设置头像"></a>28. 设置头像</h4><p>把头像图片放至 <code>themes/next/source/images/</code> 文件夹下，打开 <code>themes/next/</code> 下的 <code>_config.yml</code>，查找 <code>Sidebar Avatar</code>。修改 <code>url</code> 的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the <span class="keyword">default</span> image and set the url here.</span><br><span class="line">  url: /images/favicon.svg</span><br><span class="line">  # If <span class="literal">true</span>, the avatar will be displayed in circle.</span><br><span class="line">  rounded: <span class="literal">true</span></span><br><span class="line">  # If <span class="literal">true</span>, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<h4 id="29-文章末尾添加版权声明"><a href="#29-文章末尾添加版权声明" class="headerlink" title="29. 文章末尾添加版权声明"></a>29. 文章末尾添加版权声明</h4><p>打开 <code>themes/next/</code> 下的 <code>_config.yml</code> 文件，查找 <code>creative_commons</code>，进行以下修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: <span class="literal">false</span></span><br><span class="line">  post: <span class="literal">true</span>  # 将<span class="literal">false</span>改为<span class="literal">true</span>即可显示版权信息</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure>


<h4 id="30-配置代码块样式"><a href="#30-配置代码块样式" class="headerlink" title="30. 配置代码块样式"></a>30. 配置代码块样式</h4><p>在主题配置文件中，搜索 <code>highlight</code>根据注释修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">      enable: <span class="literal">true</span> #是否开启代码高亮</span><br><span class="line">      line_number: <span class="literal">false</span> #是否增加代码行号</span><br><span class="line">      auto_detect: <span class="literal">true</span> #自动判断代码语言</span><br><span class="line">      tab_replace:</span><br></pre></td></tr></table></figure>


<h4 id="31-站点地图"><a href="#31-站点地图" class="headerlink" title="31. 站点地图"></a>31. 站点地图</h4><blockquote>
<p>站点地图的作用向搜索引擎提供你的网站的概要，给你的网站做 SEO。</p>
</blockquote>
<p>安装插件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>

<p>在站点配置文件中添加配置项：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">plugins: hexo-generator-sitemap</span><br></pre></td></tr></table></figure>

<p>修改主题配置文件，将对应注释打开：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">    sitemap: /sitemap.xml || sitemap</span><br></pre></td></tr></table></figure>

<p>执行命令重新生成源文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo g</span><br></pre></td></tr></table></figure>

<p>上述操作顺利的话，可以发现首页左侧边栏多了一项站点地图，点进去可以看到以 xml 格式组织的你的所有文章的 url。</p>
<h4 id="32-广告"><a href="#32-广告" class="headerlink" title="32. 广告"></a>32. 广告</h4><p>这里主要针对谷歌广告来说。</p>
<h5 id="32-1-开通账号"><a href="#32-1-开通账号" class="headerlink" title="32.1 开通账号"></a>32.1 开通账号</h5><p>众所周知，谷歌是全球最大的广告中间商，让你可以出卖流量来换小钱。具体做法是将你有流量的位置告诉谷歌，他会根据浏览你网站的用户行为来动态给他们推广告。</p>
<p>你可以在这里：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9hZHNlbnNl">https://www.google.com/adsense<i class="fa fa-external-link-alt"></i></span> 开通，将你的网站提交，然后谷歌会给你审核。</p>
<h5 id="32-2-嵌入代码"><a href="#32-2-嵌入代码" class="headerlink" title="32.2 嵌入代码"></a>32.2 嵌入代码</h5><p>有个问题，如何兼顾页面美观性和广告数量、大小和位置间的平衡呢？这是个见仁见智的事情，推荐的做法主要有三点：</p>
<h6 id="32-2-1-只做展示广告。"><a href="#32-2-1-只做展示广告。" class="headerlink" title="32.2.1 只做展示广告。"></a>32.2.1 只做展示广告。</h6><p>谷歌广告类型提供了三种。推荐选择展示广告，因为位置、大小可以受我们可以严格控制。</p>
<img src="https://kfufys.github.io/posts/9aae07a1/7.png" alt="guanggao" width="1200">

<h6 id="32-2-2-限制广告尺寸。"><a href="#32-2-2-限制广告尺寸。" class="headerlink" title="32.2.2 限制广告尺寸。"></a>32.2.2 限制广告尺寸。</h6><p>在定义广告的时候，在右侧边栏可以定义广告尺寸，如果是自适应的不好控制其页面上的呈现方式。我们可以限制到很小：<code>280px * 100px</code>，并且只放一个。</p>
<h6 id="32-2-3-挑选放置位置。"><a href="#32-2-3-挑选放置位置。" class="headerlink" title="32.2.3 挑选放置位置。"></a>32.2.3 挑选放置位置。</h6><p>推荐选在侧边栏最下面，并且用分割线隔开，这里需要自定义一些样式。定义css 可以新建一个自己的样式集：<code>themes/next/source/css/_my/mycss.styl</code> ，然后在 <code>themes/next/source/css/main.styl</code> 中引用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@import</span> <span class="string">&quot;_my/mycss&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>只增加了一个样式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.sidebar-ads &#123;</span><br><span class="line">  border-top: 1px dotted #ccc;</span><br><span class="line">  width: <span class="number">100</span>%;</span><br><span class="line">  height: 100px;</span><br><span class="line">  padding-top: 15px;</span><br><span class="line">  margin-bottom: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="33-修改站点页脚"><a href="#33-修改站点页脚" class="headerlink" title="33. 修改站点页脚"></a>33. 修改站点页脚</h4><p>在主题配置文件中修改网站页脚信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># themes\next\_config.yml</span><br><span class="line"></span><br><span class="line">footer:  # 底部信息区</span><br><span class="line">  since: <span class="number">2018</span>  # 建站时间</span><br><span class="line">  icon:</span><br><span class="line">    name: heart   # 图标名称</span><br><span class="line">    animated: <span class="literal">true</span>   # 开启动画</span><br><span class="line">    color: <span class="string">&quot;#ff0000&quot;</span>   # 图标颜色</span><br><span class="line"></span><br><span class="line">  powered:</span><br><span class="line">    enable: <span class="literal">false</span>  # 隐藏由 Hexo 强力驱动</span><br><span class="line">    version: <span class="literal">false</span>  # 隐藏 Hexo 版本号</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    enable: <span class="literal">false</span>  # 隐藏所用的主题名称</span><br><span class="line">    version: <span class="literal">false</span>  # 隐藏主题版本号</span><br></pre></td></tr></table></figure>


<h4 id="34-修改文章-meta-信息"><a href="#34-修改文章-meta-信息" class="headerlink" title="34. 修改文章 meta 信息"></a>34. 修改文章 meta 信息</h4><p>默认主题下， 标题下方会显示文章的创建时间、文章的修改时间、文章分类信息等元数据，用户可以在主题配置文件中自定义设置需要显示的 meta 元信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># themes\next\_config.yml</span><br><span class="line">post_meta:</span><br><span class="line">  item_text: <span class="literal">true</span>  # 显示文字说明</span><br><span class="line">  created_at: <span class="literal">true</span>  # 显示文章创建时间</span><br><span class="line">  updated_at:</span><br><span class="line">    enabled: <span class="literal">false</span>  # 隐藏文章修改时间</span><br><span class="line">    another_day: <span class="literal">true</span>  # 只有当修改时间和创建时间不是同一天的时候才显示</span><br><span class="line">  categories: <span class="literal">false</span>  # 隐藏分类信息</span><br></pre></td></tr></table></figure>

<hr>
<p>以上就是这期文章的全部内容了，希望可以帮到各位！！！</p>
]]></content>
      <categories>
        <category>Themes 配置</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>个性化</tag>
        <tag>Hexo-Next</tag>
        <tag>Blog Themes</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA数据结构期末DemoCode</title>
    <url>https://kfufys.github.io/posts/43449.html</url>
    <content><![CDATA[<img src="https://kfufys.github.io/posts/43449/1.png" alt="head-img" width="1200">

<h3 id="题目一：顺序表-删除x-y间值"><a href="#题目一：顺序表-删除x-y间值" class="headerlink" title="题目一：顺序表_删除x~y间值"></a><strong>题目一：顺序表_删除<code>x~y</code>间值</strong></h3><p><strong>问题描述：已知线性表采用顺序存储结构<code>SeqList</code>，编写算法删除值在<code>x~y</code>之间的所有结点：</strong></p>
<p><code>SeqDelTest.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.kfufys.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@project</span>: JavaDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kfufys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/12/27 20:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 测试删除指定范围内的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeqDelTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个容量为10的顺序表</span></span><br><span class="line">        top.kfufys.demo01.<span class="type">SeqList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeqList</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加测试数据</span></span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">10</span>);</span><br><span class="line">        list.add(<span class="number">15</span>);</span><br><span class="line">        list.add(<span class="number">20</span>);</span><br><span class="line">        list.add(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印原始列表</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Original list: &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义删除范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法删除范围内的元素</span></span><br><span class="line">        list.removeInRange(x, y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印删除元素后的列表</span></span><br><span class="line">        System.out.println(<span class="string">&quot;List after removing elements in range &quot;</span> + x + <span class="string">&quot; to &quot;</span> + y + <span class="string">&quot;: &quot;</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SeqList.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.kfufys.demo01;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SeqList类代表一个顺序表，即一个线性数据结构</span></span><br><span class="line"><span class="comment"> * 它允许在列表的末尾添加元素，并在指定范围内删除元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeqList</span> &#123;</span><br><span class="line">    <span class="comment">// data数组存储顺序表中的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] data;</span><br><span class="line">    <span class="comment">// size变量记录当前顺序表中元素的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个指定容量的顺序表</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 顺序表的初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeqList</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向顺序表中添加一个元素如果顺序表已满，则先调整大小</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要添加的元素值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == data.length) &#123;</span><br><span class="line">            resize();</span><br><span class="line">        &#125;</span><br><span class="line">        data[size++] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从顺序表中删除指定范围内的所有元素</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 范围的起始值（包含）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y 范围的结束值（包含）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 如果x大于y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeInRange</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;x should not be greater than y&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] &lt; x || data[i] &gt; y) &#123;</span><br><span class="line">                data[newSize++] = data[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回顺序表中元素的数量</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 顺序表的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取顺序表中指定位置的元素</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定位置的元素值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引超出范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index out of bounds&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整顺序表的大小，当顺序表满时自动调用</span></span><br><span class="line"><span class="comment">     * 它会创建一个更大（当前长度的两倍）的新数组，并将原数组的内容复制到新数组中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] newData = <span class="keyword">new</span> <span class="title class_">int</span>[data.length * <span class="number">2</span>];</span><br><span class="line">        System.arraycopy(data, <span class="number">0</span>, newData, <span class="number">0</span>, size);</span><br><span class="line">        data = newData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写toString方法，以便于顺序表的字符串表示</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 顺序表的字符串表示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            sb.append(data[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果展示：</strong></p>
<img src="https://kfufys.github.io/posts/43449/demo01.png" alt="Demo01.png" width="1200">



<h3 id="题目二：顺序栈实现-进制转换"><a href="#题目二：顺序栈实现-进制转换" class="headerlink" title="题目二：顺序栈实现_进制转换"></a><strong>题目二：顺序栈实现_进制转换</strong></h3><p><strong>问题描述：已知栈使用顺序存储结构<code>Seqstack</code>，编写算法<code>conversion</code>实现进制转换：</strong></p>
<p><code>ConversionTest.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.kfufys.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@project</span> JavaDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kfufys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/12/27 20:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 已知栈使用顺序存储结构`Seqstack`，编写算法`conversion`实现进制转换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConversionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义要转换的十进制数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">228</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义要转换到的进制为2（二进制）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 调用Conversion类的conversion方法进行进制转换，并打印结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;十进制 &quot;</span> + number + <span class="string">&quot; 转换为 &quot;</span> + base + <span class="string">&quot; 进制: &quot;</span> + Conversion.conversion(number, base));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将进制更改为8（八进制）</span></span><br><span class="line">        base = <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// 调用Conversion类的conversion方法进行进制转换，并打印结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;十进制 &quot;</span> + number + <span class="string">&quot; 转换为 &quot;</span> + base + <span class="string">&quot; 进制: &quot;</span> + Conversion.conversion(number, base));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将进制更改为16（十六进制）</span></span><br><span class="line">        base = <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// 调用Conversion类的conversion方法进行进制转换，并打印结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;十进制 &quot;</span> + number + <span class="string">&quot; 转换为 &quot;</span> + base + <span class="string">&quot; 进制: &quot;</span> + Conversion.conversion(number, base));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Conversion.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.kfufys.demo02;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 十进制转二进制、八进制、十六进制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Conversion</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将十进制数转换为指定进制的字符串表示。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number 要转换的十进制数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base   要转换到的进制（例如，2表示二进制，8表示八进制，16表示十六进制）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转换后的字符串表示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">conversion</span><span class="params">(<span class="type">int</span> number, <span class="type">int</span> base)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查进制是否在有效范围内（2到16之间）</span></span><br><span class="line">        <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;进制必须在2到16之间&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个顺序栈来存储转换过程中的余数</span></span><br><span class="line">        SeqStack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">SeqStack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 定义一个字符串，包含所有可能的字符（0-9, A-F）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">digits</span> <span class="operator">=</span> <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用do-while循环进行进制转换</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 计算当前数字除以目标进制的余数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> number % base;</span><br><span class="line">            <span class="comment">// 将余数对应的字符压入栈中</span></span><br><span class="line">            stack.push(digits.charAt(remainder));</span><br><span class="line">            <span class="comment">// 更新数字为除以目标进制后的商</span></span><br><span class="line">            number /= base;</span><br><span class="line">        &#125; <span class="keyword">while</span> (number &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个StringBuilder对象来构建最终的转换结果</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 从栈中弹出所有字符并添加到StringBuilder中</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            result.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回转换后的字符串表示</span></span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SeqStack.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.kfufys.demo02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.EmptyStackException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺序栈 (SeqStack) 的实现，使用泛型 T 来存储元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeqStack</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 默认容量大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储栈元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> T[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈顶指针，初始值为 -1 表示空栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，初始化一个默认容量的顺序栈。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeqStack</span><span class="params">()</span> &#123;</span><br><span class="line">        elements = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_CAPACITY];</span><br><span class="line">        top = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查栈是否为空。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果栈为空返回 true，否则返回 false。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素压入栈中。如果栈已满，则自动扩展容量。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 要压入栈中的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (top == elements.length - <span class="number">1</span>) &#123;</span><br><span class="line">            resize(elements.length * <span class="number">2</span>); <span class="comment">// 当栈满时，将容量扩大一倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        elements[++top] = item; <span class="comment">// 将元素添加到栈顶，并更新栈顶指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出栈顶元素。如果栈为空，则抛出 EmptyStackException。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 栈顶元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> EmptyStackException 如果栈为空。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">item</span> <span class="operator">=</span> elements[top]; <span class="comment">// 获取栈顶元素</span></span><br><span class="line">        elements[top--] = <span class="literal">null</span>; <span class="comment">// 更新栈顶指针并避免对象游离</span></span><br><span class="line">        <span class="keyword">if</span> (top &gt; <span class="number">0</span> &amp;&amp; top == elements.length / <span class="number">4</span>) &#123;</span><br><span class="line">            resize(elements.length / <span class="number">2</span>); <span class="comment">// 当栈容量超过四分之一且非空时，将容量减半</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看栈顶元素但不弹出。如果栈为空，则抛出 EmptyStackException。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 栈顶元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> EmptyStackException 如果栈为空。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elements[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整栈的容量。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newCapacity 新的容量大小。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">        T[] newElements = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">        System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, top + <span class="number">1</span>); <span class="comment">// 复制现有元素到新数组</span></span><br><span class="line">        elements = newElements; <span class="comment">// 更新引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果展示：</strong></p>
<img src="https://kfufys.github.io/posts/43449/demo02.png" alt="Demo02.png" width="1200">



<h3 id="题目三：顺序表-删除最小值结点"><a href="#题目三：顺序表-删除最小值结点" class="headerlink" title="题目三：顺序表_删除最小值结点"></a><strong>题目三：顺序表_删除最小值结点</strong></h3><p><strong>问题描述：已知线性表采用顺序存储结构<code>SeqList</code>，编写算法，删除值最小的结点：</strong></p>
<p><code>TestSeqList.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.kfufys.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@project</span>: JavaDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kfufys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2024/12/27 21:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 顺序表_删除最小值结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSeqList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个顺序表对象</span></span><br><span class="line">        <span class="type">SeqList</span> <span class="variable">seqList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeqList</span>();</span><br><span class="line">        <span class="comment">// 添加一些元素到顺序表中</span></span><br><span class="line">        seqList.add(<span class="number">5</span>);</span><br><span class="line">        seqList.add(<span class="number">3</span>);</span><br><span class="line">        seqList.add(<span class="number">8</span>);</span><br><span class="line">        seqList.add(<span class="number">1</span>);</span><br><span class="line">        seqList.add(<span class="number">7</span>);</span><br><span class="line">        <span class="comment">// 打印删除最小元素之前的顺序表内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除最小元素之前：&quot;</span>);</span><br><span class="line">        seqList.printList();</span><br><span class="line">        <span class="comment">// 删除顺序表中的最小元素</span></span><br><span class="line">        seqList.removeMin();</span><br><span class="line">        <span class="comment">// 打印删除最小元素之后的顺序表内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;删除最小元素之后：&quot;</span>);</span><br><span class="line">        seqList.printList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SeqList.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.kfufys.demo03;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SeqList类代表一个顺序表，即一个线性数据结构</span></span><br><span class="line"><span class="comment"> * 它允许在列表的末尾添加元素，并在指定范围内删除元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeqList</span> &#123;</span><br><span class="line">    <span class="comment">// data数组存储顺序表中的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] data;</span><br><span class="line">    <span class="comment">// size变量记录当前顺序表中元素的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个指定容量的顺序表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeqList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>]; <span class="comment">// 初始化默认容量为10</span></span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向顺序表中添加一个元素如果顺序表已满，则先调整大小</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要添加的元素值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == data.length) &#123;</span><br><span class="line">            resize();</span><br><span class="line">        &#125;</span><br><span class="line">        data[size++] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从顺序表中删除指定范围内的所有元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 范围的起始值（包含）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y 范围的结束值（包含）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 如果x大于y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeInRange</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;x should not be greater than y&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] &lt; x || data[i] &gt; y) &#123;</span><br><span class="line">                data[newSize++] = data[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回顺序表中元素的数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 顺序表的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取顺序表中指定位置的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定位置的元素值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引超出范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index out of bounds&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整顺序表的大小，当顺序表满时自动调用</span></span><br><span class="line"><span class="comment">     * 它会创建一个更大（当前长度的两倍）的新数组，并将原数组的内容复制到新数组中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] newData = <span class="keyword">new</span> <span class="title class_">int</span>[data.length * <span class="number">2</span>];</span><br><span class="line">        System.arraycopy(data, <span class="number">0</span>, newData, <span class="number">0</span>, size);</span><br><span class="line">        data = newData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写toString方法，以便于顺序表的字符串表示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 顺序表的字符串表示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            sb.append(data[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除顺序表中值最小的结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果顺序表为空，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录最小值的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> data[<span class="number">0</span>]; <span class="comment">// 记录最小值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历顺序表，找到最小值及其索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] &lt; minValue) &#123;</span><br><span class="line">                minValue = data[i]; <span class="comment">// 更新最小值</span></span><br><span class="line">                minIndex = i; <span class="comment">// 更新最小值的索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除最小值</span></span><br><span class="line">        remove(minIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除指定索引的元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 要删除的元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果索引超出范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;索引: &quot;</span> + index + <span class="string">&quot;, 大小: &quot;</span> + size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            data[i] = data[i + <span class="number">1</span>]; <span class="comment">// 将后续元素向前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        data[--size] = <span class="number">0</span>; <span class="comment">// 更新元素数量并避免对象游离</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印顺序表中的所有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.toString()); <span class="comment">// 使用重写的toString方法打印顺序表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果展示：</strong></p>
<img src="https://kfufys.github.io/posts/43449/demo03.png" alt="Demo03.png" width="1200">



<h3 id="题目四：稀疏矩阵转置"><a href="#题目四：稀疏矩阵转置" class="headerlink" title="题目四：稀疏矩阵转置"></a><strong>题目四：稀疏矩阵转置</strong></h3><p><strong>问题描述：编写算法<code>TransMatrix</code>实现稀疏矩阵的转置：</strong></p>
<p><code>SparseMatrixTransposeTest.java</code></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.kfufys.demo04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kfufys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@project</span>: JavaDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/12/27 21:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 该类用于演示如何对稀疏矩阵进行转置操作，稀疏矩阵是一种特殊的数据结构，主要用于减少存储空间和提高计算效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseMatrixTransposeTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主函数入口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 命令行参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化稀疏矩阵，以三元组形式表示非零元素的位置和值</span></span><br><span class="line">        Triple[] matrix = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Triple</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Triple</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Triple</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Triple</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 打印原始稀疏矩阵</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Original Sparse Matrix:&quot;</span>);</span><br><span class="line">        TransMatrix.printMatrix(matrix);</span><br><span class="line">        <span class="comment">// 执行稀疏矩阵的转置操作</span></span><br><span class="line">        Triple[] transposedMatrix = TransMatrix.transpose(matrix);</span><br><span class="line">        <span class="comment">// 打印转置后的稀疏矩阵</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Transposed Sparse Matrix:&quot;</span>);</span><br><span class="line">        TransMatrix.printMatrix(transposedMatrix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Triple.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.kfufys.demo04;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Triple 类用于表示一个三元组，主要用于存储矩阵元素的行位置、列位置和值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Triple</span> &#123;</span><br><span class="line">    <span class="comment">// 表示矩阵元素的行位置</span></span><br><span class="line">    <span class="type">int</span> row;</span><br><span class="line">    <span class="comment">// 表示矩阵元素的列位置</span></span><br><span class="line">    <span class="type">int</span> col;</span><br><span class="line">    <span class="comment">// 表示矩阵元素的值</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个新的 Triple 实例。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row   矩阵元素的行位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col   矩阵元素的列位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 矩阵元素的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Triple</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.row = row;</span><br><span class="line">        <span class="built_in">this</span>.col = col;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TransMatrix.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.kfufys.demo04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.kfufys.demo04.Triple;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TransMatrix类提供了矩阵转置的功能，特别适用于稀疏矩阵。</span></span><br><span class="line"><span class="comment"> * 稀疏矩阵是指大部分元素为零的矩阵。通过使用Triple数组表示矩阵，</span></span><br><span class="line"><span class="comment"> * 可以有效地存储和操作这些矩阵。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransMatrix</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对稀疏矩阵进行转置。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 代表原始矩阵的Triple数组，每个Triple对象包含行索引、列索引和值。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转置后的矩阵，以Triple数组形式返回。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Triple[] transpose(Triple[] matrix) &#123;</span><br><span class="line">        <span class="comment">// 确定矩阵的列数（即转置后矩阵的行数）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numCols</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Triple triple : matrix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (triple.col &gt; numCols) &#123;</span><br><span class="line">                numCols = triple.col;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        numCols++; <span class="comment">// 列索引从0开始，因此需要加1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化结果矩阵和辅助数组</span></span><br><span class="line">        Triple[] result = <span class="keyword">new</span> <span class="title class_">Triple</span>[matrix.length]; <span class="comment">// 存储转置后的矩阵</span></span><br><span class="line">        <span class="type">int</span>[] colSizes = <span class="keyword">new</span> <span class="title class_">int</span>[numCols];           <span class="comment">// 统计每列的元素个数</span></span><br><span class="line">        <span class="type">int</span>[] colIndices = <span class="keyword">new</span> <span class="title class_">int</span>[numCols];         <span class="comment">// 记录每列元素在转置矩阵中的起始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计每列的元素个数</span></span><br><span class="line">        <span class="keyword">for</span> (Triple triple : matrix) &#123;</span><br><span class="line">            colSizes[triple.col]++; <span class="comment">// 每遇到一个元素，对应列的计数加1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算每列元素在转置矩阵中的起始位置</span></span><br><span class="line">        colIndices[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一列的起始位置总是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; numCols; i++) &#123;</span><br><span class="line">            colIndices[i] = colIndices[i - <span class="number">1</span>] + colSizes[i - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 当前列的起始位置等于前一列的起始位置加上前一列的元素个数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成转置矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (Triple triple : matrix) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> colIndices[triple.col]; <span class="comment">// 获取当前列的起始位置</span></span><br><span class="line">            result[index] = <span class="keyword">new</span> <span class="title class_">Triple</span>(triple.col, triple.row, triple.value);</span><br><span class="line">            <span class="comment">// 创建新的Triple对象，交换行列索引，并赋值给结果数组</span></span><br><span class="line">            colIndices[triple.col]++; <span class="comment">// 更新当前列的起始位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印矩阵。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 要打印的矩阵，以Triple数组形式表示。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMatrix</span><span class="params">(Triple[] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Triple triple : matrix) &#123;</span><br><span class="line">            System.out.println(triple.row + <span class="string">&quot; &quot;</span> + triple.col + <span class="string">&quot; &quot;</span> + triple.value);</span><br><span class="line">            <span class="comment">// 打印每一行的行索引、列索引和值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果展示：</strong></p>
<img src="https://kfufys.github.io/posts/43449/demo04.png" alt="Demo04.png" width="1200">



<h3 id="题目五：递归建立二叉树"><a href="#题目五：递归建立二叉树" class="headerlink" title="题目五：递归建立二叉树"></a><strong>题目五：递归建立二叉树</strong></h3><p><strong>问题描述：编写算法，使用递归方式建立二叉树：</strong></p>
<p><code>BinaryTreeBuilder.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.kfufys.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kfufys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@project</span>: JavaDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024/12/27 21:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 二叉树构建和遍历的主类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主方法，程序入口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 命令行参数（本程序未使用）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 BinaryTree 类中的静态方法 buildTree() 构建二叉树，并将根节点赋值给 root 变量</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> BinaryTree.buildTree();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印提示信息，表示接下来将进行中序遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构建的二叉树的中序遍历结果:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 BinaryTree 类中的静态方法 inorderTraversal() 对二叉树进行中序遍历并打印结果</span></span><br><span class="line">        BinaryTree.inorderTraversal(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TreeNode.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.kfufys.demo05;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树节点类，表示二叉树中的一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点存储的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向左子节点的引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向右子节点的引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，用于初始化一个新的二叉树节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化节点的值</span></span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="comment">// 初始化左右子节点为 null，表示当前节点没有子节点</span></span><br><span class="line">        <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BinaryTree.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.kfufys.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树类，包含构建二叉树和中序遍历的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建二叉树的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回构建好的二叉树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 提示用户输入节点值，并读取输入</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入节点值（输入 -1 表示空节点）: &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> getValidInput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果输入值为 -1，表示该节点为空，返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (value == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则，创建一个新的 TreeNode 节点并初始化其值</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归构建左子树</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入节点 &quot;</span> + value + <span class="string">&quot; 的左子节点值（输入 -1 表示空节点）: &quot;</span>);</span><br><span class="line">        root.left = buildTree();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归构建右子树</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入节点 &quot;</span> + value + <span class="string">&quot; 的右子节点值（输入 -1 表示空节点）: &quot;</span>);</span><br><span class="line">        root.right = buildTree();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValidInput</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!scanner.hasNextInt()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入错误，请输入有效的整数。&quot;</span>);</span><br><span class="line">            scanner.next(); <span class="comment">// 清除错误输入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历二叉树的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为空，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        inorderTraversal(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问当前节点，打印节点值</span></span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历右子树</span></span><br><span class="line">        inorderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果展示：</strong></p>
<img src="https://kfufys.github.io/posts/43449/demo05.png" alt="Demo05.png" width="1200">

<hr>
<center><span> - - Done - - </span></center>
]]></content>
      <categories>
        <category>期末复习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>期末复习</tag>
        <tag>DemoCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Gemini 2.0 怎么用?</title>
    <url>https://kfufys.github.io/posts/2266.html</url>
    <content><![CDATA[<img src="https://kfufys.github.io/posts/2266/1.png" alt="head.png">

<p>最近，<code>Google</code>悄然发布了<code>Gemini 2.0</code>，一款功能强大的AI助手，而且完全免费！</p>
<p>相比<code>ChatGPT Plus</code>每月<code>20</code>美元的订阅费，这简直是给数字时代的生产力工作者送来的一份大礼。</p>
<p>让我们一起来看看这款<code>AI</code>助手究竟有多强大，以及如何充分利用它提升工作效率。</p>
<h2 id="一、核心功能：远超想象的生产力工具"><a href="#一、核心功能：远超想象的生产力工具" class="headerlink" title="一、核心功能：远超想象的生产力工具"></a><strong>一、核心功能：远超想象的生产力工具</strong></h2><h3 id="1-超强的文本处理能力："><a href="#1-超强的文本处理能力：" class="headerlink" title="1. 超强的文本处理能力："></a><strong>1. 超强的文本处理能力：</strong></h3><p><code>Gemini 2.0</code>最令人印象深刻的是它对文字的理解和生成能力。无论是写文案、做内容规划，还是进行文本分析，它都能精准理解你的需求。</p>
<p>实际体验：我让它帮我写一篇小红书笔记，只需简单说明主题，它就能生成一篇地道的种草文，连常用的表情符号都安排得恰到好处。(文后有具体的代码示范)</p>
<h3 id="2-屌炸天的实时音视频通话："><a href="#2-屌炸天的实时音视频通话：" class="headerlink" title="2. 屌炸天的实时音视频通话："></a><strong>2. 屌炸天的实时音视频通话：</strong></h3><p>这可能是最革命性的功能 - 你可以直接与AI进行视频通话！想象一下：</p>
<ul>
<li>做菜时遇到问题？打开摄像头让AI指导 </li>
<li>学习编程卡壳？共享屏幕让AI帮你分析代码 </li>
<li>健身动作不标准？AI可以实时纠正你的姿势</li>
</ul>
<h3 id="3-超长上下文理解"><a href="#3-超长上下文理解" class="headerlink" title="3.  超长上下文理解"></a><strong>3.  超长上下文理解</strong></h3><p>支持<code>200</code>万<code>token</code>的上下文处理能力</p>
<blockquote>
<p>一本像《红楼梦》这样经典的中文小说，字数约为百万字，转换为<code>token</code>后可能需要约<code>100</code>万<code>token</code>。因此，<code>200</code>万<code>token</code>大约可以处理<code>2</code>本这样的长篇小说，或者<code>10</code>到<code>20</code>本字数较少的普通小说<br>这意味着什么？</p>
</blockquote>
<p><strong>你可以：</strong></p>
<ul>
<li>上传整本电子书请它总结 </li>
<li>导入长篇论文让它分析 </li>
<li>输入完整项目文档进行梳理</li>
</ul>
<h2 id="二、上手指南：三步开启AI效率之旅"><a href="#二、上手指南：三步开启AI效率之旅" class="headerlink" title="二、上手指南：三步开启AI效率之旅"></a><strong>二、上手指南：三步开启AI效率之旅</strong></h2><h3 id="第一步：访问平台"><a href="#第一步：访问平台" class="headerlink" title="第一步：访问平台"></a><strong>第一步：访问平台</strong></h3><p>打开<code>Google AI Studio</code>（<span class="exturl" data-url="aHR0cHM6Ly9haXN0dWRpby5nb29nbGUuY29tL2FwcC9wcm9tcHRzL25ld19jaGF0JUVGJUJDJTg5">https://aistudio.google.com/app/prompts/new_chat）<i class="fa fa-external-link-alt"></i></span><br><strong>注意：</strong>需要确保网络环境流畅</p>
<img src="https://kfufys.github.io/posts/2266/2.png" alt="2.png">

<h3 id="第二步：选择模型"><a href="#第二步：选择模型" class="headerlink" title="第二步：选择模型"></a><strong>第二步：选择模型</strong></h3><ul>
<li><p>推荐选择<code>Gemini experimental 1206</code>模型，这是目前性能最强的版本 </p>
</li>
<li><p>如果追求速度，可以选择<code>Gemini 2.0 Flash</code>版本</p>
</li>
</ul>
<img src="https://kfufys.github.io/posts/2266/3.png" alt="3.png">

<h3 id="第三步：开始使用"><a href="#第三步：开始使用" class="headerlink" title="第三步：开始使用"></a><strong>第三步：开始使用</strong></h3><ul>
<li>文字对话：直接输入问题即可 </li>
<li>视频通话：点击左上角”实时流”按钮 </li>
<li>视频分析：选择<code>starter apps</code>中的视频分析器</li>
</ul>
<p><strong>通过屏幕共享提示获取实时回答的例子:</strong>  </p>
<img src="https://kfufys.github.io/posts/2266/4.png" alt="4.png">



<h2 id="三、使用技巧：让AI更懂你"><a href="#三、使用技巧：让AI更懂你" class="headerlink" title="三、使用技巧：让AI更懂你"></a><strong>三、使用技巧：让AI更懂你</strong></h2><ul>
<li><strong>提问技巧：</strong>明确你的目标、提供具体场景、适当补充细、分步骤提问</li>
</ul>
<ul>
<li><p>如果你需要更多场景更多加精确的提示词可以使用<code>Prompt集合</code>这个免费的提示词微信小程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#小程序://Prompt集合/uILcjIITicfkqFC</span><br></pre></td></tr></table></figure>

<ul>
<li>视频通话目前仅支持英文回答，但是他可以听得懂中文 ，  可配合翻译软件使用 ，  如遇到日语回复，输入”Please speak in English”即可</li>
</ul>
</li>
</ul>
<h2 id="四、实用场景推荐"><a href="#四、实用场景推荐" class="headerlink" title="四、实用场景推荐"></a><strong>四、实用场景推荐</strong></h2><ul>
<li><p><strong>内容创作者：</strong>文案撰写、选题规划、视频脚本 </p>
</li>
<li><p><strong>程序开发者：</strong>代码审查、问题诊断、算法优化 </p>
</li>
<li><p><strong>学习者：</strong>课程笔记整理、知识点讲解、习题解析</p>
</li>
</ul>
<h2 id="五、实战示例，代码展示"><a href="#五、实战示例，代码展示" class="headerlink" title="五、实战示例，代码展示"></a><strong>五、实战示例，代码展示</strong></h2><p><code>Gemini 2.0 API </code>目前提供了官方 <code>sdk</code>  地址:  <code>https://ai.google.dev/gemini-api/docs/sdks</code></p>
<p><strong>下面是 python的示范:</strong></p>
<h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1.  安装依赖"></a><strong>1.  安装依赖</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install google-genai</span><br></pre></td></tr></table></figure>

<h3 id="2-导入必要库"><a href="#2-导入必要库" class="headerlink" title="2.  导入必要库"></a><strong>2.  导入必要库</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> google <span class="keyword">import</span> genai</span><br><span class="line"><span class="keyword">from</span> google.genai <span class="keyword">import</span> types</span><br></pre></td></tr></table></figure>

<h3 id="3-初始化客户端"><a href="#3-初始化客户端" class="headerlink" title="3.  初始化客户端"></a><strong>3.  初始化客户端</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用API密钥初始化</span></span><br><span class="line">client = genai.Client(api_key=<span class="string">&#x27;YOUR_API_KEY&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h3 id="4-基础使用方法"><a href="#4-基础使用方法" class="headerlink" title="4.  基础使用方法"></a><strong>4.  基础使用方法</strong></h3><p><strong>4.1 简单文本生成：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础文本生成</span></span><br><span class="line">response = client.models.generate_content(</span><br><span class="line">    model=<span class="string">&#x27;gemini-1.5-pro-002&#x27;</span>,  <span class="comment"># 选择模型版本</span></span><br><span class="line">    contents=<span class="string">&#x27;用简单的话解释什么是人工智能&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

<p><strong>4.2 结构化提示：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用结构化提示获得更精确的回答</span></span><br><span class="line">prompt = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">分析以下产品的优缺点:</span></span><br><span class="line"><span class="string">产品：智能手表</span></span><br><span class="line"><span class="string">要求：</span></span><br><span class="line"><span class="string">1. 列出3个主要优点</span></span><br><span class="line"><span class="string">2. 列出2个主要缺点</span></span><br><span class="line"><span class="string">3. 给出总体评价</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">response = client.models.generate_content(</span><br><span class="line">    model=<span class="string">&#x27;gemini-1.5-pro-002&#x27;</span>,</span><br><span class="line">    contents=prompt</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

<p><strong>4.3 多轮对话：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建聊天会话</span></span><br><span class="line">chat = client.models.start_chat(model=<span class="string">&#x27;gemini-1.5-pro-002&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送消息并获取回复</span></span><br><span class="line">response = chat.send_message(<span class="string">&quot;你好，我想学习Python编程&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续对话</span></span><br><span class="line">response = chat.send_message(<span class="string">&quot;可以给我一个简单的开始项目吗？&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

<h3 id="5-高级功能"><a href="#5-高级功能" class="headerlink" title="5. 高级功能"></a><strong>5. 高级功能</strong></h3><p><strong>5.1  图片分析：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_image</span>(<span class="params">image_path, prompt</span>):</span><br><span class="line">    image = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line">    response = client.models.generate_content(</span><br><span class="line">        model=<span class="string">&#x27;gemini-1.5-pro-002&#x27;</span>,</span><br><span class="line">        contents=[</span><br><span class="line">            <span class="string">&quot;分析这张图片&quot;</span>,</span><br><span class="line">            image</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> response.text</span><br></pre></td></tr></table></figure>

<p><strong>5.2 代码生成与分析：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码生成示例</span></span><br><span class="line">code_prompt = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">用Python写一个简单的网络爬虫，要求：</span></span><br><span class="line"><span class="string">1. 使用requests库</span></span><br><span class="line"><span class="string">2. 获取网页标题</span></span><br><span class="line"><span class="string">3. 包含错误处理</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">response = client.models.generate_content(</span><br><span class="line">    model=<span class="string">&#x27;gemini-1.5-pro-002&#x27;</span>,</span><br><span class="line">    contents=code_prompt</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

<p><strong>5.3 参数控制：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用生成参数控制输出</span></span><br><span class="line">response = client.models.generate_content(</span><br><span class="line">    model=<span class="string">&#x27;gemini-1.5-pro-002&#x27;</span>,</span><br><span class="line">    contents=<span class="string">&#x27;写一个短故事&#x27;</span>,</span><br><span class="line">    generation_config=&#123;</span><br><span class="line">        <span class="string">&#x27;temperature&#x27;</span>: <span class="number">0.7</span>,  <span class="comment"># 控制创造性</span></span><br><span class="line">        <span class="string">&#x27;max_output_tokens&#x27;</span>: <span class="number">500</span>,  <span class="comment"># 控制长度</span></span><br><span class="line">        <span class="string">&#x27;top_p&#x27;</span>: <span class="number">0.8</span>,  <span class="comment"># 控制多样性</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h2 id="六、最佳实践"><a href="#六、最佳实践" class="headerlink" title="六、最佳实践"></a><strong>六、最佳实践</strong></h2><h3 id="1-错误处理"><a href="#1-错误处理" class="headerlink" title="1.  错误处理"></a><strong>1.  错误处理</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = client.models.generate_content(</span><br><span class="line">        model=<span class="string">&#x27;gemini-1.5-pro-002&#x27;</span>,</span><br><span class="line">        contents=<span class="string">&#x27;你的提示词&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;发生错误: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-流式输出"><a href="#2-流式输出" class="headerlink" title="2.  流式输出"></a><strong>2.  流式输出</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取流式响应</span></span><br><span class="line">response = client.models.generate_content(</span><br><span class="line">    model=<span class="string">&#x27;gemini-1.5-pro-002&#x27;</span>,</span><br><span class="line">    contents=<span class="string">&#x27;写一篇文章&#x27;</span>,</span><br><span class="line">    stream=<span class="literal">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="3-逐步打印响应"><a href="#3-逐步打印响应" class="headerlink" title="3.  逐步打印响应"></a><strong>3.  逐步打印响应</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> response:</span><br><span class="line">    <span class="built_in">print</span>(chunk.text, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="小红书种草文案"><a href="#小红书种草文案" class="headerlink" title="小红书种草文案"></a><strong>小红书种草文案</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写一篇小红书种草文案</span></span><br><span class="line">prompt = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">请以种草博主的身份写一篇小红书文案，主题是某个生产力工具。要求：</span></span><br><span class="line"><span class="string">1. 标题吸引人</span></span><br><span class="line"><span class="string">2. 内容真实可信</span></span><br><span class="line"><span class="string">3. 加入表情符号</span></span><br><span class="line"><span class="string">4. 分点描述优势</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gemini回复示例</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">💫革命性效率工具｜我用它一周省下10小时 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上周发现了一个神器，真的让我的工作效率直接起飞！🚀 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">先说重点：</span></span><br><span class="line"><span class="string">✨完全免费</span></span><br><span class="line"><span class="string">✨界面超简洁</span></span><br><span class="line"><span class="string">✨上手只需5分钟</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">从此再也不用每天: </span></span><br><span class="line"><span class="string">📝手动整理笔记</span></span><br><span class="line"><span class="string">📊费力做数据分析</span></span><br><span class="line"><span class="string">📅纠结日程安排</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#效率工具 #工作技巧 #职场神器</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>


<h3 id="代码审查示例"><a href="#代码审查示例" class="headerlink" title="代码审查示例"></a><strong>代码审查示例</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 让Gemini审查代码</span></span><br><span class="line">code_review_prompt = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">请审查以下Python代码，指出潜在问题和优化建议：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def calculate_average(numbers):</span></span><br><span class="line"><span class="string">    total = 0</span></span><br><span class="line"><span class="string">    count = 0</span></span><br><span class="line"><span class="string">    for num in numbers:</span></span><br><span class="line"><span class="string">        total += num</span></span><br><span class="line"><span class="string">        count += 1</span></span><br><span class="line"><span class="string">    return total/count</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data = [1,2,3,4,5]</span></span><br><span class="line"><span class="string">result = calculate_average(data)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gemini可能的回复</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">代码审查结果：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 错误处理：</span></span><br><span class="line"><span class="string">- 需添加空列表检查</span></span><br><span class="line"><span class="string">- 应处理除零异常</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. 性能优化：</span></span><br><span class="line"><span class="string">- 可使用sum()和len()替代循环</span></span><br><span class="line"><span class="string">- count变量可直接用len()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">优化后的代码：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def calculate_average(numbers):</span></span><br><span class="line"><span class="string">    if not numbers:</span></span><br><span class="line"><span class="string">        raise ValueError(&quot;Cannot calculate average of empty list&quot;)</span></span><br><span class="line"><span class="string">    return sum(numbers) / len(numbers)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 使用示例</span></span><br><span class="line"><span class="string">try:</span></span><br><span class="line"><span class="string">    data = [1,2,3,4,5]</span></span><br><span class="line"><span class="string">    result = calculate_average(data)</span></span><br><span class="line"><span class="string">    print(f&quot;Average: &#123;result&#125;&quot;)</span></span><br><span class="line"><span class="string">except ValueError as e:</span></span><br><span class="line"><span class="string">    print(f&quot;Error: &#123;e&#125;&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>


<h3 id="数据分析示例"><a href="#数据分析示例" class="headerlink" title="数据分析示例"></a><strong>数据分析示例</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 让Gemini分析数据</span></span><br><span class="line">data_analysis_prompt = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">分析以下销售数据，生成可视化代码：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sales_data = &#123;</span></span><br><span class="line"><span class="string">    &#x27;Jan&#x27;: 1200,</span></span><br><span class="line"><span class="string">    &#x27;Feb&#x27;: 1500,</span></span><br><span class="line"><span class="string">    &#x27;Mar&#x27;: 1300,</span></span><br><span class="line"><span class="string">    &#x27;Apr&#x27;: 1800</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gemini生成的可视化代码示例</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">import matplotlib.pyplot as plt</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 数据准备</span></span><br><span class="line"><span class="string">months = list(sales_data.keys())</span></span><br><span class="line"><span class="string">sales = list(sales_data.values())</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 创建柱状图</span></span><br><span class="line"><span class="string">plt.figure(figsize=(10, 6))</span></span><br><span class="line"><span class="string">plt.bar(months, sales, color=&#x27;skyblue&#x27;)</span></span><br><span class="line"><span class="string">plt.title(&#x27;Monthly Sales Performance&#x27;)</span></span><br><span class="line"><span class="string">plt.xlabel(&#x27;Month&#x27;)</span></span><br><span class="line"><span class="string">plt.ylabel(&#x27;Sales Amount&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 添加数值标签</span></span><br><span class="line"><span class="string">for i, v in enumerate(sales):</span></span><br><span class="line"><span class="string">    plt.text(i, v + 30, str(v), ha=&#x27;center&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">plt.show()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>


<p>建议读者在实际使用时：</p>
<ul>
<li>先理解代码逻辑 </li>
<li>根据自己的需求修改参数 </li>
<li>注意错误处理 </li>
<li>适当添加日志记录</li>
</ul>
<h3 id="最后的建议："><a href="#最后的建议：" class="headerlink" title="最后的建议："></a><strong>最后的建议：</strong></h3><p>虽然<code>Gemini 2.0</code>目前完全免费，但免费的好时光可能不会太久。建议大家趁早上手，熟悉各项功能，把它变成你的得力助手。</p>
<p><strong>记住：</strong>工具再好，也需要正确的使用方法。建议先从简单的任务开始，逐步探索更复杂的功能，这样能更好地发挥AI助手的潜力。</p>
]]></content>
      <categories>
        <category>AI工具</category>
      </categories>
      <tags>
        <tag>AIGC</tag>
        <tag>教程</tag>
        <tag>Google</tag>
        <tag>Gemini</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 简写技巧</title>
    <url>https://kfufys.github.io/posts/c5860ba2.html</url>
    <content><![CDATA[<img src="https://kfufys.github.io/posts/c5860ba2/1.png" alt="head-img" width="1200">

<h3 id="一、三元运算符简化条件判断"><a href="#一、三元运算符简化条件判断" class="headerlink" title="一、三元运算符简化条件判断"></a>一、三元运算符简化条件判断</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">    result = <span class="string">&#x27;yes&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = <span class="string">&#x27;no&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = someCondition? <span class="string">&#x27;yes&#x27;</span> : <span class="string">&#x27;no&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：当遇到简单的二选一条件判断时，使用三元运算符可以将多行代码浓缩为一行，使逻辑更加清晰简洁，避免了繁琐的 <code>if - else</code> 结构。</p>
</blockquote>
<h3 id="二、空值合并运算符"><a href="#二、空值合并运算符" class="headerlink" title="二、空值合并运算符"></a>二、空值合并运算符</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = user.<span class="property">name</span>!== <span class="literal">null</span> &amp;&amp; user.<span class="property">name</span>!== <span class="literal">undefined</span>? user.<span class="property">name</span> : <span class="string">&#x27;default&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = user.<span class="property">name</span>?? <span class="string">&#x27;default&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：在处理可能为空值（<code>null</code> 或 <code>undefined</code>）的变量时，以往需要双重判断，现在使用空值合并运算符，能直接简洁地指定默认值。</p>
</blockquote>
<h3 id="三、可选链操作符"><a href="#三、可选链操作符" class="headerlink" title="三、可选链操作符"></a>三、可选链操作符</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> street = user &amp;&amp; user.<span class="property">address</span> &amp;&amp; user.<span class="property">address</span>.<span class="property">street</span>;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> street = user?.<span class="property">address</span>?.<span class="property">street</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：当访问嵌套对象的深层属性时，为了防止中间某个属性不存在导致报错，传统写法需要层层判断。有了可选链操作符，代码更加简洁直观，它会在属性不存在时返回 <code>undefined</code>，而不会引发错误。</p>
</blockquote>
<h3 id="四、数组去重"><a href="#四、数组去重" class="headerlink" title="四、数组去重"></a>四、数组去重</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> arr.<span class="title function_">indexOf</span>(item) === index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unique</span> = arr =&gt; [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：对于去除数组中的重复元素，传统方法使用 <code>filter</code> 结合 <code>indexOf</code> 来判断，较为复杂。利用 ES6 的 <code>Set</code> 数据结构，它会自动去除重复值，再通过扩展运算符将其转换回数组，短短一行代码就搞定，简洁高效。</p>
</blockquote>
<h3 id="五、快速取整"><a href="#五、快速取整" class="headerlink" title="五、快速取整"></a>五、快速取整</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> floor = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">4.9</span>);</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> floor = ~~<span class="number">4.9</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：在需要将浮点数向下取整时，除了使用 <code>Math.floor</code> 方法，还可以用双波浪线操作符，它利用了位运算的特性，能快速实现取整功能，在一些性能要求较高且简单取整场景下很实用，不过要注意它对负数的处理稍有不同。</p>
</blockquote>
<h3 id="六、合并对象"><a href="#六、合并对象" class="headerlink" title="六、合并对象"></a>六、合并对象</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merged = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1, obj2);</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merged = &#123;...obj1,...obj2&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：把多个对象合并为一个新对象，<code>Object.assign</code> 是常见做法，但 ES6 的扩展运算符语法更简洁，直接将对象展开合并，方便快捷，常用于配置对象的合并等场景，如合并默认配置和用户自定义配置。</p>
</blockquote>
<h3 id="七、短路求值"><a href="#七、短路求值" class="headerlink" title="七、短路求值"></a>七、短路求值</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="title function_">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">condition &amp;&amp; <span class="title function_">doSomething</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：当只想在某个条件满足时执行一个函数或表达式，短路求值可以省略 <code>if</code> 语句，让代码更紧凑。若条件为真，后面的表达式才会执行，常用于函数调用前的条件判断，比如判断用户是否有权限执行某个操作，有权限时才调用相应函数。</p>
</blockquote>
<h3 id="八、默认参数值"><a href="#八、默认参数值" class="headerlink" title="八、默认参数值"></a>八、默认参数值</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    name = name || <span class="string">&#x27;Guest&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params">name = <span class="string">&#x27;Guest&#x27;</span></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：在定义函数时，给参数设置默认值，以往用逻辑或运算符来实现，存在一定缺陷，如传入 0、空字符串等假值时会误判。现在 ES6 的默认参数语法能精准地为参数指定默认值，让函数更健壮，比如定义一个打招呼函数，若不传名字就默认向“Guest”打招呼。</p>
</blockquote>
<h3 id="九、解构赋值"><a href="#九、解构赋值" class="headerlink" title="九、解构赋值"></a>九、解构赋值</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> name = person.<span class="property">name</span>;</span><br><span class="line"><span class="keyword">const</span> age = person.<span class="property">age</span>;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：当从对象或数组中提取数据时，解构赋值能一次性完成多个变量的赋值，避免了逐个赋值的繁琐，让代码简洁易读。还可以结合函数参数使用，如函数接收一个对象参数，直接解构出需要的值，增强了代码的灵活性。</p>
</blockquote>
<h3 id="十、字符串转数字"><a href="#十、字符串转数字" class="headerlink" title="十、字符串转数字"></a>十、字符串转数字</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="built_in">parseInt</span>(<span class="string">&#x27;123&#x27;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = +<span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：把字符串转换为数字，除了使用 <code>parseInt</code> 函数，还可以用一元加运算符，它会尝试将操作数转换为数字类型，对于简单的字符串数字转换场景，这种写法更加简洁，如将用户输入的数字字符串转换为实际数字进行计算。</p>
</blockquote>
<h3 id="十一、多重条件判断"><a href="#十一、多重条件判断" class="headerlink" title="十一、多重条件判断"></a>十一、多重条件判断</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">10</span> &amp;&amp; num &lt; <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">10</span> &lt; num &amp;&amp; num &lt; <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：在进行多重比较判断时，调整一下比较顺序，有时能让代码逻辑看起来更清晰自然，尤其是连续比较大小的场景，更符合阅读习惯，减少理解成本。</p>
</blockquote>
<h3 id="十二、快速幂运算"><a href="#十二、快速幂运算" class="headerlink" title="十二、快速幂运算"></a>十二、快速幂运算</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">power</span>(<span class="params">base, exponent</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; exponent; i++) &#123;</span><br><span class="line">        result *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">power</span> = (<span class="params">base, exponent</span>) =&gt; <span class="title class_">Math</span>.<span class="title function_">pow</span>(base, exponent);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：计算一个数的幂次方，自己实现循环累乘固然可行，但 JavaScript 内置的 <code>Math.pow</code> 函数更加高效可靠，直接调用就能完成复杂的幂运算，节省开发时间。</p>
</blockquote>
<h3 id="十三、对象属性简写"><a href="#十三、对象属性简写" class="headerlink" title="十三、对象属性简写"></a>十三、对象属性简写</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: name &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123; name &#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：在创建对象时，如果对象属性名和变量名相同，ES6 允许我们直接简写，省去重复书写属性名的麻烦，让代码更简洁，常用于对象字面量的创建。</p>
</blockquote>
<h3 id="十四、数组映射"><a href="#十四、数组映射" class="headerlink" title="十四、数组映射"></a>十四、数组映射</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> doubled = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    doubled.<span class="title function_">push</span>(numbers[i] * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：对数组中的每个元素进行相同操作并返回新数组，使用数组的 <code>map</code> 方法比传统的循环遍历 <code>push</code> 更加简洁明了，函数式编程风格让代码更具可读性，常用于数据转换场景，如将一组数据统一格式化。</p>
</blockquote>
<h3 id="十五、交换变量值"><a href="#十五、交换变量值" class="headerlink" title="十五、交换变量值"></a>十五、交换变量值</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> temp;</span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line">[a, b] = [b, a];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：交换两个变量的值，传统方法需要借助临时变量，而利用解构赋值可以巧妙地在一行内完成交换，代码简洁高效，是一种很巧妙的技巧。</p>
</blockquote>
<h3 id="十六、动态对象属性"><a href="#十六、动态对象属性" class="headerlink" title="十六、动态对象属性"></a>十六、动态对象属性</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[dynamic + <span class="string">&#x27;name&#x27;</span>] = value;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;dynamic&#125;</span>name`</span>]: value</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：当对象的属性名需要动态生成时，以往是用字符串拼接，现在使用模板字面量结合方括号语法，更加直观，能清晰地表达属性名是动态生成的，常用于根据不同条件创建对象属性的场景。</p>
</blockquote>
<h3 id="十七、箭头函数简写对象方法"><a href="#十七、箭头函数简写对象方法" class="headerlink" title="十七、箭头函数简写对象方法"></a>十七、箭头函数简写对象方法</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">sayHello</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：在定义对象的方法时，如果方法体较为简单，使用箭头函数可以让代码更简洁。这种写法在一些简单的事件处理函数或者工具函数作为对象方法时非常实用，减少了函数声明的冗余。</p>
</blockquote>
<h3 id="十八、利用扩展运算符复制数组"><a href="#十八、利用扩展运算符复制数组" class="headerlink" title="十八、利用扩展运算符复制数组"></a>十八、利用扩展运算符复制数组</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> originalArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> copiedArray = originalArray.<span class="title function_">slice</span>();</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> originalArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> copiedArray = [...originalArray];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：当需要复制一个数组时，以往常用 <code>slice</code> 方法，但使用扩展运算符更加直观简洁，它会创建一个新的数组副本，避免了直接赋值导致的引用共享问题，在处理数据时能保证原数组不被意外修改。</p>
</blockquote>
<h3 id="十九、合并数组并去重"><a href="#十九、合并数组并去重" class="headerlink" title="十九、合并数组并去重"></a>十九、合并数组并去重</h3><p><strong>传统写法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> combined = arr1.<span class="title function_">concat</span>(arr2).<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, self</span>) =&gt;</span> self.<span class="title function_">indexOf</span>(item) === index);</span><br></pre></td></tr></table></figure>

<p><strong>简写方式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> combined = [...<span class="keyword">new</span> <span class="title class_">Set</span>([...arr1,...arr2])];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解释</strong>：要合并两个数组合并去除重复元素，传统写法需要先 <code>concat</code> 再用 <code>filter</code> 配合 <code>indexOf</code> 去重，较为繁琐。利用扩展运算符结合 <code>Set</code> 结构，先展开数组合并，再利用 <code>Set</code> 去重，最后转回数组，一步到位，简洁高效。</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>网络工程师考试知识点_01</title>
    <url>https://kfufys.github.io/posts/65522.html</url>
    <content><![CDATA[<img src="https://kfufys.github.io/posts/65202/1.jpg" alt="head-img" width="1200">

<h4 id="一、计算机存储与中断相关"><a href="#一、计算机存储与中断相关" class="headerlink" title="一、计算机存储与中断相关"></a><strong>一、计算机存储与中断相关</strong></h4><ol>
<li>常用的虚拟存储器由<strong>主存 - 辅存</strong>两级存储器组成。</li>
<li>中断向量可提供<strong>中断程序的入口地址</strong>。</li>
<li>DMA工作方式在<strong>主存与外设</strong>之间建立直接的数据通信。</li>
</ol>
<h4 id="二、项目管理与网络图表相关"><a href="#二、项目管理与网络图表相关" class="headerlink" title="二、项目管理与网络图表相关"></a><strong>二、项目管理与网络图表相关</strong></h4><ol>
<li>PERT不能清晰描述各个任务之间的<strong>并行情况</strong>，甘特图不能清晰描述各个问题之间的<strong>依赖关系</strong>。</li>
</ol>
<h4 id="三、网络设备与协议相关"><a href="#三、网络设备与协议相关" class="headerlink" title="三、网络设备与协议相关"></a><strong>三、网络设备与协议相关</strong></h4><ol>
<li>路由器出厂时，默认的串口封装协议是HDLC。</li>
<li>报文摘要算法生成报文摘要的目的是防止发送的报文被篡改。</li>
<li>PGP是支持电子<strong>邮件加密</strong>的协议。</li>
<li>根域名服务器采用的<strong>迭代</strong>查询。</li>
<li>中介域名服务器采用的是<strong>递归</strong>查询。</li>
<li><strong>AH隧道模式：</strong>使用AH与IP报头来封装IP数据包并对整个数据包进行签名以获得完整性并进行身份验证。</li>
<li><strong>ESP隧道模式：</strong>采用ESP与IP报头以及ESP身份验证尾端来封装IP数据包。</li>
<li><strong>L2TP数据包封装格式：</strong>IP - UDP - L2TP - PPP。</li>
<li>SNMP是在<strong>UDP</strong>协议之上的异步&#x2F;请求响应。</li>
</ol>
<h4 id="四、网络传输相关"><a href="#四、网络传输相关" class="headerlink" title="四、网络传输相关"></a><strong>四、网络传输相关</strong></h4><ol>
<li><p>支持1000m以上传输距离的是<strong>1000 BASE-Lx</strong>。</p>
</li>
<li><p><strong>nslookup参数：</strong></p>
<ul>
<li><p><strong>Set all ：</strong>列出当前设置的默认选项。</p>
</li>
<li><p><strong>Set type &#x3D; mx ：</strong>查询本地域的邮件交换器信息。</p>
</li>
<li><p><strong>Server NAME ：</strong>由当前默认服务器切换到制定的名字服务器NAME。</p>
</li>
</ul>
</li>
<li><p><strong>DNS服务器主要资源记录：</strong></p>
<ul>
<li><p><strong>A：</strong>域名到IP地址的映射。</p>
</li>
<li><p><strong>PTR：</strong>IP地址到域名的映射。</p>
</li>
<li><p><strong>MX：</strong>邮件服务器及优先级。</p>
</li>
<li><p><strong>CNAME：</strong>别名。</p>
</li>
<li><p><strong>NS：</strong>区域的授权服务器。</p>
</li>
</ul>
</li>
</ol>
<h4 id="五、结构化布线系统相关"><a href="#五、结构化布线系统相关" class="headerlink" title="五、结构化布线系统相关"></a><strong>五、结构化布线系统相关</strong></h4><ol>
<li><strong>工作区子系统：</strong>由终端设备到信息插座的整个区域，用于将用户终端设备连接到布线系统，主要包括信息插座、跳线、适配器。</li>
<li><strong>水平布线子系统：</strong>是结构化综合布线系统中连接用户工作区与布线系统主干的子系统。</li>
<li><strong>管理子系统：</strong>是结构化布线系统中对布线电缆进行端接及配线管理的子系统，通常设置在楼层的接线间内。</li>
<li><strong>干线子系统：</strong>是结构化综合布线系统中连接各管理间、设备间的子系统，又称垂直子系统。</li>
<li><strong>设备间子系统：</strong>主要是用来安放网络关键设备。并非每一个综合布线都有设备间子系统。</li>
<li><strong>建筑群子系统：</strong>是结构化综合布线系统中由连接楼群之间的通信传输介质及各种支持设备组成的子系统。</li>
</ol>
<h4 id="六、xDSL相关"><a href="#六、xDSL相关" class="headerlink" title="六、xDSL相关"></a><strong>六、xDSL相关</strong></h4><ol>
<li><strong>HDSL：</strong>中断距离可达3 - 5KM、传输速率2.048Mbits&#x2F;s。</li>
<li><strong>ADSL：</strong>是一种非对称的DSL技术。</li>
<li><strong>VDSL：</strong>是一种非对称的技术，也是DSL中传输速度最快的技术。</li>
<li><strong>SDSL：</strong>单线路数字用户技术是对称的。</li>
<li><strong>RADSL：</strong>速率自适应数字用户线技术，是采用非对称技术。</li>
</ol>
<h4 id="七、私有地址相关"><a href="#七、私有地址相关" class="headerlink" title="七、私有地址相关"></a><strong>七、私有地址相关</strong></h4><ol>
<li><strong>A类：</strong>10.0.0.0 - 10.255.255.255。</li>
<li><strong>B类：</strong>172.16.0.0 - 172.31.255.255。</li>
<li><strong>C类：</strong>192.168.0.0 - 192.168.255.255。</li>
</ol>
<h4 id="八、阻止路由环路相关"><a href="#八、阻止路由环路相关" class="headerlink" title="八、阻止路由环路相关"></a><strong>八、阻止路由环路相关</strong></h4><ol>
<li><p><strong>最大跳计数（Maximum Hop Count）</strong></p>
<ul>
<li><strong>原理：</strong><ul>
<li>在许多路由协议（如 RIP）中，会为数据包经过的路由器数量设置一个最大值。例如，RIP 协议默认的最大跳数是 15。当一个数据包经过的路由器数量达到这个最大值时，该数据包将被丢弃。这是因为随着跳数的不断增加，网络环路的可能性也在增大。如果没有最大跳数的限制，数据包可能会在网络中无限循环，消耗网络资源。</li>
</ul>
</li>
<li><strong>示例：</strong><ul>
<li>假设有一个简单的网络拓扑，包括路由器 A、B、C、D 和 E，它们之间通过链路相连。如果一个数据包从路由器 A 出发，经过 B、C、D、E，然后又回到 A，并且这个过程不断循环，没有最大跳数限制，这个数据包就会一直在这个环路中传递。但如果设置了最大跳数为 5，当数据包经过 5 个路由器后，就会被丢弃，从而防止了无限循环。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>水平分割（Split Horizon）</strong></p>
<ul>
<li><strong>原理：</strong><ul>
<li>水平分割规则规定，从一个接口学到的路由信息不会再从这个接口发送出去。这样可以避免路由器将从某个邻居学到的路由信息又发送回给这个邻居，从而防止产生路由环路。它基于一个简单的逻辑，即如果路由器已经从某个方向学到了到达某个网络的路由，那么它不应该再向这个方向通告这个路由，因为这个方向的邻居很可能就是通过它才学到这个路由的。</li>
</ul>
</li>
<li><strong>示例：</strong><ul>
<li>假设路由器 R1 和 R2 是邻居，它们之间通过接口 E0 相连。R1 通过接口 E0 向 R2 通告了到达网络 N 的路由。根据水平分割规则，R2 不会再通过接口 E0 向 R1 通告到达网络 N 的路由。这样就避免了 R1 和 R2 之间可能产生的路由环路。例如，在一个帧中继网络中，多个路由器通过虚电路相连，水平分割可以有效地防止路由信息在相邻路由器之间的来回传递，避免环路的形成。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>路由毒化（Route Poisoning）</strong></p>
<ul>
<li><strong>原理：</strong><ul>
<li>当一个路由不可达时，路由器会将该路由标记为不可达（通常将其度量值设置为无穷大），并且向相邻路由器通告这个不可达信息。相邻路由器收到这个中毒的路由信息后，会更新自己的路由表，并且也会向它的相邻路由器通告这个不可达信息。这样，网络中的所有路由器都会快速地知道这个路由已经不可达，从而避免将数据包转发到这个不可达的路径上，防止了路由环路的产生。</li>
</ul>
</li>
<li><strong>示例：</strong><ul>
<li>比如在一个网络中有路由器 A、B、C。路由器 A 发现它到网络 X 的链路出现故障，它就会将到网络 X 的路由标记为不可达（如将跳数设置为 16，在 RIP 协议中表示不可达），并向路由器 B 通告这个中毒的路由。路由器 B 收到后更新自己的路由表，然后也向路由器 C 通告这个中毒的路由。这样，整个网络就会很快知道网络 X 不可达，避免了因为链路故障而可能导致的数据包在 A - B - C - A 这样的环路中转发。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>保持关闭（Hold - down）</strong></p>
<ul>
<li><p><strong>原理</strong></p>
<p>：</p>
<ul>
<li>当路由器从邻居收到一个路由不可达的消息后，它会进入一个保持关闭状态。在这个状态下，路由器会忽略来自同一个邻居的关于这条路由的任何更新信息（通常会持续一段时间，如 180 秒）。这是因为在网络不稳定的情况下，可能会出现错误的路由更新信息。例如，当一条链路刚刚出现故障时，可能会因为网络的收敛过程而产生一些错误的更新，导致路由器错误地更新路由表，进而产生路由环路。保持关闭机制可以让路由器在一段时间内不被这些可能错误的更新所干扰，等待网络稳定后再更新路由表。</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<ul>
<li>假设路由器 R1 收到来自邻居 R2 的消息，说到达网络 Y 的路由不可达。R1 进入保持关闭状态。如果在这个状态期间，R2 又发送了一个关于网络 Y 的更新（可能是由于网络波动，这个更新是错误的），R1 会忽略这个更新。只有当保持关闭时间结束后，R1 才会考虑来自 R2 的关于网络 Y 的更新，这样就避免了在网络不稳定时，因为错误的更新而导致的路由环路。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="九、链路状态通告相关"><a href="#九、链路状态通告相关" class="headerlink" title="九、链路状态通告相关"></a><strong>九、链路状态通告相关</strong></h4><ol>
<li><strong>链路状态通告（LSA - Link - State Advertisement）的定义与作用：</strong><ul>
<li>链路状态通告是链路状态路由协议（如 OSPF、IS - IS）中的关键元素。它是一种包含了路由器自身以及其直连链路信息的数据包。这些信息包括接口的 IP 地址、子网掩码、链路的开销（cost）、链路的连接状态（是 up 还是 down）等。路由器通过在网络中泛洪 LSA，使得网络中的其他路由器能够了解整个网络的拓扑结构。</li>
<li>例如，在一个企业网络中，使用 OSPF 协议。路由器 A 通过生成 LSA 来通告自己的接口连接到网络 192.168.1.0&#x2F;24，开销为 10，并且接口状态是 up。这个 LSA 会在网络中传播，让其他路由器知道如何到达这个网络以及相关的链路成本。</li>
</ul>
</li>
<li><strong>LSA 的内容构成：</strong><ul>
<li><strong>路由器标识符（Router ID）：</strong><ul>
<li>这是一个用于唯一标识路由器的编号。在 OSPF 中，通常是路由器上最大的活动接口的 IP 地址，或者可以手动配置。它用于区分不同的路由器发送的 LSA。例如，在一个有多个路由器的网络中，路由器 A 的 Router ID 为 1.1.1.1，路由器 B 的 Router ID 为 2.2.2.2，这样其他路由器就可以根据 Router ID 来识别 LSA 的来源。</li>
</ul>
</li>
<li><strong>链路类型（Link Type）：</strong><ul>
<li>描述了路由器与其他设备之间链路的性质。常见的链路类型包括点到点链路（如两个路由器之间通过串行接口直接相连）、广播链路（如连接到以太网段）和非广播多路访问（NBMA，例如帧中继网络）。不同的链路类型在 LSA 中会有不同的表示方式，并且会影响路由计算和数据包转发。例如，在广播链路中，路由器需要选举出一个指定路由器（DR）和备份指定路由器（BDR）来管理 LSA 的泛洪过程。</li>
</ul>
</li>
<li><strong>链路开销（Link Cost）：</strong><ul>
<li>代表了通过该链路传输数据的代价。开销的计算可以基于链路的带宽、延迟等因素。例如，一条 100Mbps 的以太网链路的开销可能比一条 10Mbps 的以太网链路的开销小。开销是用于计算最短路径的重要参数，路由器会根据收到的 LSA 中的开销信息来选择到达目标网络的最优路径。</li>
</ul>
</li>
<li><strong>邻居信息（Neighbor Information）：</strong><ul>
<li>列出了与该路由器直接相连的其他路由器的标识符（如 Router ID）。这有助于构建完整的网络拓扑图。例如，路由器 A 在 LSA 中列出它的邻居是路由器 B 和路由器 C，它们的 Router ID 分别为 2.2.2.2 和 3.3.3.3，这样其他路由器收到这个 LSA 后，就可以知道路由器 A 与哪些路由器相连。</li>
</ul>
</li>
</ul>
</li>
<li><strong>LSA 的泛洪过程（Flooding）：</strong><ul>
<li>当路由器生成一个新的 LSA 或者收到一个更新的 LSA 时，它会将这个 LSA 发送给除了接收该 LSA 的接口之外的所有接口。这个过程称为泛洪。例如，在一个由多个路由器组成的网状网络中，路由器 A 生成了一个新的 LSA，它会将这个 LSA 发送给与它相连的路由器 B、C 和 D。路由器 B 收到这个 LSA 后，会检查自己的链路状态数据库（LSDB），如果这个 LSA 是新的或者比自己已有的 LSA 更新（根据序列号、校验和等信息判断），它会将这个 LSA 存储到自己的 LSDB 中，然后再向它的其他邻居（除了发送这个 LSA 给它的路由器 A）泛洪这个 LSA。这个过程会一直持续，直到网络中的所有路由器都收到并存储了这个最新的 LSA。</li>
<li>在这个过程中，为了防止 LSA 在网络中无限循环，每个 LSA 都有一个序列号。路由器通过比较序列号来判断 LSA 的新旧。当一个 LSA 的序列号达到最大值后，会重新从初始值开始，但同时会有其他机制（如老化时间）来确保 LSA 的准确性和及时性。</li>
</ul>
</li>
<li><strong>LSA 的老化与更新：</strong><ul>
<li><strong>老化（Aging）：</strong><ul>
<li>LSA 有一个老化时间，通常在 OSPF 中是 30 分钟。从 LSA 产生开始计算时间，当老化时间到期后，这个 LSA 会被标记为无效。这是为了确保网络拓扑信息的及时性。如果网络拓扑发生变化，旧的 LSA 不应该一直存在于网络中影响路由决策。例如，一个路由器的接口连接的网络被重新划分了子网，旧的 LSA 中关于这个网络的信息就需要更新，老化机制可以促使这种更新。</li>
</ul>
</li>
<li><strong>更新（Update）：</strong><ul>
<li>当路由器的链路状态发生变化时（如接口的状态从 up 变为 down，或者链路的开销发生变化），它会生成一个新的 LSA 来更新网络中的其他路由器。这个新的 LSA 会包含更新后的链路信息，并且会按照泛洪过程在网络中传播。例如，路由器 A 和路由器 B 之间的链路带宽从 10Mbps 提升到 100Mbps，路由器 A 会更新关于这条链路的 LSA，将链路开销等信息更新后，在网络中泛洪这个新的 LSA，让其他路由器知道网络拓扑的这个变化。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="十、VTP、STP及ACL相关"><a href="#十、VTP、STP及ACL相关" class="headerlink" title="十、VTP、STP及ACL相关"></a><strong>十、VTP、STP及ACL相关</strong></h4><ol>
<li><p><strong>访问控制列表的分类：</strong></p>
<ul>
<li><strong>标准访问控制列表：</strong>主要基于源 IP 地址进行过滤，通常使用的编号范围是 1 - 99 以及 1300 - 1999（不同的 IOS 版本可能略有差异）。它的功能相对较为基础，只能对数据包的源 IP 地址进行匹配判断，进而决定是否允许该数据包通过。</li>
<li><strong>扩展访问控制列表：</strong>功能更强大，可以基于源 IP 地址、目的 IP 地址、协议类型、端口号等多种条件来进行过滤，编号范围一般是 100 - 199 以及 2000 - 2699。通过综合考虑多个因素，能实现更精细、更复杂的访问控制策略。</li>
</ul>
</li>
<li><p><strong>具体 ACL 语句分析：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）Access-list 10 deny host 10.37.168.137 与 access-list 10 deny 10.37.168.137 等价，拒绝任何来自 10.23.168.137 的分组。</span><br><span class="line">（2）Any 与 0.0.0.0 255.255.255.255 等价，表示整个 IP 地址范围。</span><br><span class="line">（3）Access-list 10 deny tcp any (源地址) host 172.16.30.2 (目的地址) eq 23/telnet ：禁止任何主机访问 10.37.16.30.2 的 telnet 服务。</span><br><span class="line">（4）Access-list 110 permit tcp host 192.168.177.2 host 172.22.89.26 eq www/80 ，允许源 IP 地址为 192.168.177.2 的主机，通过 TCP 协议访问目的 IP 地址为 172.22.89.26 的主机的 80 端口。</span><br><span class="line">（5）Access-list 110 deny tcp any host 172.22.89.26 eq 80 ，只允许指定的 192.168.177.2 访问该主机的 80 端口。</span><br><span class="line">（6）Access-list 110 permit ip any any ，放行其他所有流量。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>接口应用 ACL 规则：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Interface S0</span><br><span class="line">Ip access-group 110 out</span><br><span class="line">允许 192.168.177.2 以 http 方式访问主机 172.22.89.26，但是拒绝其他主机的数据流访问 172.22.89.26 的 web 服务（80 端口）。</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="十一、NAT相关："><a href="#十一、NAT相关：" class="headerlink" title="十一、NAT相关："></a><strong>十一、NAT相关：</strong></h4><ol>
<li><p><strong>NAT（网络地址转换）分类：</strong></p>
<ul>
<li><p><strong>静态 NAT：</strong>内部本地地址和内部全局地址进行一对一的永久映射。</p>
<ul>
<li><p>示例配置（以 Cisco 路由器为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 定义内部本地地址和内部全局地址的映射关系：</span><br><span class="line">Router(config)#ip nat inside source static 192.168.1.2 209.165.200.22</span><br><span class="line"># 指定内部接口和外部接口：</span><br><span class="line">Router(config)#interface FastEthernet0/0</span><br><span class="line">Router(config - if)#ip nat inside</span><br><span class="line">Router(config - if)#interface Serial0/0/0</span><br><span class="line">Router(config - if)#ip nat outside</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>动态 NAT：</strong>从一个内部全局地址池中动态地分配地址给内部本地地址（临时映射关系）。</p>
<ul>
<li><p>示例配置（以 Cisco 路由器为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入全局配置模式：</span><br><span class="line">Router#conf t</span><br><span class="line"># 定义内部全局地址池。假设地址池名为 POOL1，包含的地址范围是 209.165.200.20 - 209.165.200.30：</span><br><span class="line">Router(config)#ip nat pool POOL1 209.165.200.20 209.165.200.30 netmask 255.255.255.0</span><br><span class="line"># 定义访问控制列表（ACL）来指定哪些内部本地地址可以进行 NAT 转换。假设允许 192.168.1.0/24 网段的主机进行 NAT 转换：</span><br><span class="line">Router(config)#access - list 1 permit 192.168.1.0 0.0.0.255</span><br><span class="line"># 将 ACL 与地址池关联，实现动态 NAT：</span><br><span class="line">Router(config)#ip nat inside source list 1 pool POOL1</span><br><span class="line"># 指定内部接口和外部接口（同静态 NAT）：</span><br><span class="line">Router(config)#interface FastEthernet0/0</span><br><span class="line">Router(config - if)#ip nat inside</span><br><span class="line">Router(config - if)#interface Serial0/0/0</span><br><span class="line">Router(config - if)#ip nat outside</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>配置 PAT（NAT 重载，也叫端口地址转换）：</strong></p>
<ul>
<li><p><strong>原理</strong>：PAT 通过使用不同的端口号来区分不同的内部本地地址的连接，使得多个内部本地地址可以共享一个或少数几个内部全局地址。这样可以更有效地利用 IP 地址资源，是一种多对一的地址转换方式。</p>
</li>
<li><p>示例配置（以 Cisco 路由器为例）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入全局配置模式：</span><br><span class="line">Router(config)#conf t</span><br><span class="line"># 定义访问控制列表（ACL）来指定哪些内部本地地址可以进行 NAT 转换。假设允许 192.168.1.0/24 网段的主机进行 NAT 转换：</span><br><span class="line">Router(config)#access - list 1 permit 192.168.1.0 0.0.0.255</span><br><span class="line"># 将 ACL 与外部接口关联，实现 PAT。假设外部接口是 Serial0/0/0：</span><br><span class="line">Router(config)#ip nat inside source list 1 interface Serial0/0/0 overload</span><br><span class="line"># 指定内部接口和外部接口（同静态 NAT）：</span><br><span class="line">Router(config)#interface FastEthernet0/0</span><br><span class="line">Router(config - if)#ip nat inside</span><br><span class="line">Router(config - if)#interface Serial0/0/0</span><br><span class="line">Router(config - if)#ip nat outside</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="十二、无线网络相关："><a href="#十二、无线网络相关：" class="headerlink" title="十二、无线网络相关："></a><strong>十二、无线网络相关：</strong></h4><ol>
<li><p><strong>IEEE802.11标准：</strong></p>
<ul>
<li><p>IEEE802.11a：54Mbits&#x2F;s 、5GHz标准。</p>
</li>
<li><p>IEEE802.11b：对802.11的改进，以支持5.5.Mbits&#x2F;s和11Mbits&#x2F;s。</p>
</li>
<li><p>IEEE892.11g：54Mbits&#x2F;s、2.4GHz标准（向后兼容802.11b）。</p>
</li>
<li><p>IEEE892.11n：使用MIMO(多入多出天线)提高吞吐量。</p>
</li>
<li><p>Wi-fi联盟认可了802.11i标准，并称之为wap2。</p>
</li>
<li><p>Wap2使用了aes-ccmp机密技术。</p>
</li>
</ul>
</li>
</ol>
<h4 id="十三、IPv6相关："><a href="#十三、IPv6相关：" class="headerlink" title="十三、IPv6相关："></a><strong>十三、IPv6相关：</strong></h4><ol>
<li><p><strong>特殊IPv6地址：</strong></p>
<ul>
<li><p>0:0:0:0:0:0:0:0(::) 相当于IPv4地址0.0.0.0，通常在使用有状态DHCP配置时，用作主机的源地址。</p>
</li>
<li><p>0:0:0:0:0:0:0:1(::1) 相当于IPv4地址127.0.0.1。</p>
</li>
<li><p>0:0:0:0:0:0:192.168.100.1 在同时支持IPv4和IPv6的网络中，从IPv4地址转换而来的IPv6地址通常这样写。</p>
</li>
</ul>
</li>
<li><p><strong>IPv6地址类型：</strong></p>
<ul>
<li><p>2000::&#x2F;3全局单播地址。</p>
</li>
<li><p>FC00::&#x2F;7唯一的本地单播地址范围。</p>
</li>
<li><p>FE80::&#x2F;10链路本地单播地址范围。</p>
</li>
<li><p>FF00::&#x2F;8组播地址范围 。</p>
</li>
<li><p>2001:0DB8::&#x2F;32保留举例和编写文档时使用。</p>
</li>
<li><p>3FFF:FFFF::&#x2F;32 保留举例和编写文档时使用。</p>
</li>
<li><p>2002::&#x2F;16 保留供6to4隧道技术使用。</p>
</li>
</ul>
</li>
</ol>
<h4 id="十四、软件设计相关："><a href="#十四、软件设计相关：" class="headerlink" title="十四、软件设计相关："></a><strong>十四、软件设计相关：</strong></h4><p>在软件设计阶段，划分模块的原则是一个模块的控制范围应该在作用范围之内。</p>
<ol>
<li><strong>模块的控制范围和作用范围的定义：</strong><ul>
<li><strong>控制范围：</strong>是指模块本身及其所有下属模块（如果有）的集合。</li>
<li><strong>作用范围：</strong>是指受该模块内一个判定影响的所有其他模块的集合。</li>
</ul>
</li>
<li><strong>为什么控制范围应该在作用范围之内：</strong><ul>
<li><strong>可维护性：</strong>模块控制范围在作用范围内，当需对软件进行维护或修改时，开发人员可以很容易地确定修改一个模块可能会影响到哪些其他模块。</li>
<li><strong>可读性和理解性</strong>：这种原则有助于提高软件设计的可读性和理解性。</li>
<li><strong>降低耦合度</strong>：使得模块之间的耦合度降低。</li>
</ul>
</li>
</ol>
<h4 id="十五、软件项目活动图相关："><a href="#十五、软件项目活动图相关：" class="headerlink" title="十五、软件项目活动图相关："></a><strong>十五、软件项目活动图相关：</strong></h4><p>软件项目活动图中，松弛时间表示在不影响整个工作的前提下，完成该项任务有多少机动余地，松弛时间为0的任务构成了完成整个工程的关键任务，即所需时间最长的任务。</p>
<h4 id="十六、其他网络概念相关"><a href="#十六、其他网络概念相关" class="headerlink" title="十六、其他网络概念相关"></a><strong>十六、其他网络概念相关</strong></h4><ol>
<li><p><strong>VPI与CIR：</strong>VPI用来表示不同虚拟路径，CIR用来约束数据速率。</p>
</li>
<li><p><strong>代理ARP：</strong>是指由离目标主机最近的交换机假装目标主机回答源主机的ARP请求。</p>
</li>
<li><p><strong>距离矢量路由协议：</strong>每一个路由器接收的路由信息来源于它的邻居路由器。</p>
</li>
<li><p><strong>BGP4协议：</strong></p>
<ul>
<li><p>打开（open）报文建立两个路由之间的邻居关系。</p>
</li>
<li><p>更新（UPDATE）报文给出了新的路由信息。</p>
</li>
</ul>
</li>
<li><p><strong>OSPF协议：</strong></p>
<ul>
<li><p>链路状态算法用于计算路由表。</p>
</li>
<li><p>一个路由器的链路状态只涉及与相邻路由器的连通状态。</p>
</li>
</ul>
</li>
<li><p><strong>组播地址：</strong></p>
<ul>
<li><p>224.0.0.0 - 224.0.0.255为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其他地址供路由协议用。</p>
</li>
<li><p>224.0.1.0 - 224.0.1.255是公用组播地址，可以用于Internet。</p>
</li>
<li><p>224.0.2.0 - 238.255.255.255可为用户可用的组播地址（临时组播地址），全网范围内有效。</p>
</li>
<li><p>239.0.0.0 - 239.255.255.255为本地管理组地址，仅在特定的本地范围内有效。</p>
</li>
<li><p>组播服务发送信息只需要发送一个分组，组内所有成员即可全部收到。</p>
</li>
</ul>
</li>
<li><p><strong>数字签名验证：</strong>用户B收到用户A带数字签名的消息M，为了验证M的真实性，首先需要从CA获取用户的数字证书，并利用CA的公钥验证证书的真伪，然后利用A的公钥验证M的真实性。</p>
</li>
<li><p><strong>SDES算法</strong>：是一种共享秘钥算法。</p>
</li>
<li><p><strong>IPSEC安全关联：</strong>IPSEC中安全关联（security Associations）三元组是&lt;安全参数索引SPI，目标IP地址，安全协议&gt;。</p>
</li>
<li><p><strong>SNMP协议：</strong>当代理收到一个GET请求时，如果有一个值不可或者不能提供，则返回该实例的下一个值。</p>
</li>
<li><p><strong>SNMP网络管理：</strong>一个代理可以由多个管理站管理。</p>
</li>
<li><p><strong>自动专用IP地址：</strong></p>
<ul>
<li><p>用途是DHCP服务器的专用地址。</p>
</li>
<li><p>自动专用IP地址的范围是169.254.0.0 - 169.254.255.255。</p>
</li>
</ul>
</li>
<li><p><strong>以太网结构填充字段：</strong>作用是保持最小帧长。</p>
</li>
<li><p><strong>物联网无线传感网络技术</strong>：是802.15.3ZigBee微微网。</p>
</li>
<li><p><strong>4G标准：</strong>LTE、LTE-Advanced、WIMAXII、Wireless MAN、UMB等属于4G标准。</p>
</li>
<li><p><strong>扩展频谱通信：</strong>主要思想是将信号散步到更宽的带宽上以减少阻塞和干扰的机会。</p>
</li>
<li><p><strong>CLOSE-WAIT状态：</strong>等待从本地用户发来的连接中断请求。</p>
</li>
<li><p><strong>BGP报文：</strong></p>
<ul>
<li><p>Open报文：用于建立邻居关系。</p>
</li>
<li><p>Update报文：用于发送新的路由信息。</p>
</li>
<li><p>Keepalive报文：用于对Open的应答和周期性地确认邻居关系。</p>
</li>
<li><p>Notification报文：用于报告监测到的错误。</p>
</li>
</ul>
</li>
<li><p><strong>Vsftp服务：</strong>可以通过 service Vsftpd start&#x2F;down&#x2F;restart 三个命令来启动、关闭和重启，主配置文件名为 vsftpd.conf 。</p>
</li>
<li><p><strong>SNMP团体名设置：</strong></p>
<ul>
<li><p>R2(config)#snmp-server community publicr  ro ：设置snmp-server的只读团体名为publicr。</p>
</li>
<li><p>R2(config)# snmp-server community publicw  rw ：设置snmp-server的读写团体名为publicw。</p>
</li>
<li><p>Nat(inside) 1 0 或者 nat(inside) 1.0.0.0 0.0.0.0 表示内网的所有主机均可以访问外网。</p>
</li>
</ul>
</li>
<li><p><strong>华为静态路由与默认路由配置：</strong></p>
<ol>
<li><p><strong>静态路由配置：</strong></p>
<ul>
<li><p><strong>配置基本静态路由：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt;system - view  # 进入系统视图，这是配置大多数华为设备命令的前提操作，后续配置都在此视图下进行</span><br><span class="line">[Huawei]ip route - static 192.168.2.0 255.255.255.0 192.168.1.2  # 配置一条静态路由</span><br><span class="line"># “ip route-static”是配置静态路由的命令关键字</span><br><span class="line"># “192.168.2.0”是目的网络地址，表示要去往的目标网络段</span><br><span class="line"># “255.255.255.0”是对应的子网掩码，用于精确界定目的网络的范围</span><br><span class="line"># “192.168.1.2”是下一跳地址，也就是数据包从本路由器发出去后，下一个接收该数据包的设备接口地址</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置负载分担的静态路由（多条链路到同一目的网络）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei]ip route - static 10.0.0.0 255.0.0.0 172.16.1.2  # 配置第一条到达目的网络10.0.0.0/8的静态路由</span><br><span class="line"># 这条命令含义与上面基本静态路由类似，这里目的网络是10.0.0.0，子网掩码255.0.0.0，下一跳为172.16.1.2，用于和下一条命令共同实现负载分担</span><br><span class="line">[Huawei]ip route - static 10.0.0.0 255.0.0.0 172.16.2.2  # 配置第二条到达目的网络10.0.0.0/8的静态路由</span><br><span class="line"># 同样是去往10.0.0.0/8网络，但下一跳变为172.16.2.2，两条链路可同时分担去往该目的网络的流量，实现负载分担功能</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态路由的优先级调整：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei]ip route - static 10.0.0.0 255.0.0.0 172.16.1.2 preference 70  # 调整特定静态路由的优先级</span><br><span class="line"># “preference”关键字用于设置优先级，此处将之前配置的去往10.0.0.0/8网络且下一跳为172.16.1.2的静态路由优先级设置为70</span><br><span class="line"># 优先级数值越大，表示该路由相对其他到达相同目的网络的路由被优先选用的程度越低，默认静态路由优先级是60</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>默认路由配置：</strong></p>
<ul>
<li><p><strong>配置基本默认路由：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei]ip route - static 0.0.0.0 0.0.0.0 192.168.1.1  # 配置默认路由</span><br><span class="line"># “0.0.0.0 0.0.0.0”表示所有网络（目的网络地址和子网掩码都为全0），意味着如果数据包的目的地址在本地路由表中没有更精确匹配的路由条目时，都将按照这条默认路由转发</span><br><span class="line"># “192.168.1.1”是下一跳地址，即数据包将被转发到这个地址对应的设备接口</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置默认路由的应用场景示例（完整配置）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt;system - view  # 进入系统视图</span><br><span class="line">[Huawei]interface GigabitEthernet0/0/1  # 进入路由器的一个接口（假设是连接内部网络的接口）视图，GigabitEthernet0/0/1是接口名称，可根据实际设备接口情况改变</span><br><span class="line">[Huawei - GigabitEthernet0/0/1]ip address 192.168.1.254 255.255.255.0  # 配置该接口的IP地址为192.168.1.254，子网掩码为255.255.255.0，使其能与内部网络通信</span><br><span class="line">[Huawei - GigabitEthernet0/0/1]quit  # 退出接口视图，回到系统视图</span><br><span class="line">[Huawei]interface GigabitEthernet0/0/2  # 进入另一个接口（假设是连接外部网络，比如ISP的接口）视图</span><br><span class="line">[Huawei - GigabitEthernet0/0/2]ip address 202.100.1.2 255.255.255.252  # 配置该接口的IP地址为202.100.1.2，子网掩码为255.255.255.252，使其能与外部网络通信</span><br><span class="line">[Huawei - GigabitEthernet0/0/2]quit  # 退出接口视图，回到系统视图</span><br><span class="line">[Huawei]ip route - static 0.0.0.0 0.0.0.0 202.100.1.1  # 配置默认路由，下一跳地址为202.100.1.1，这样内部网络的数据可以通过这个接口转发出去访问互联网等外部网络</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p><strong>运算器：</strong>主要完成算术运算、逻辑运算和移位操作，主要部件有算术逻辑单元（ALU）、累加器（ACC）、标志寄存器、寄存器组、多路转换器、数据总线等。</p>
</li>
<li><p><strong>控制器：</strong>主要实现指令的读入、寄存、译码和执行过程有序地发出控制信号。控制器主要由指令寄存器、程序计数器、指令译码器、状态&#x2F;条件寄存器、时序产生器、微操作信号发生器组成。</p>
</li>
<li><p><strong>地址映射方式：</strong>有：全相联方式、直接方式和组相联方式。</p>
</li>
<li><p><strong>专利保护期限：</strong>根据我国《专利法》规定，发明专利的保护期限为20年，实用型和外观设计专利为10年。</p>
</li>
<li><p><strong>交换机与路由器连接：</strong>交换机与路由器用直通电缆连接。</p>
</li>
<li><p><strong>默认静态路由配置：</strong>例如： Router(config)#ip route 0.0.0.0 0.0.0.0 [exit-interface | ip-address ] 。</p>
</li>
<li><p><strong>cache与内存转换：</strong>cache与内存之间的转换是由硬件完成的。</p>
</li>
<li><p><strong>相联存储器：</strong>按内容方式访问。</p>
</li>
<li><p><strong>E1、E2、E3、T1载波数据速率：</strong></p>
<ul>
<li><p>E1载波的数据速率为2.048Mbit&#x2F;s。</p>
</li>
<li><p>E2由4个E1组成。</p>
</li>
<li><p>E3由4个E2组成。</p>
</li>
<li><p>T1载波的数据速率为1.544Mbit&#x2F;s。</p>
</li>
</ul>
</li>
<li><p>**<code>route print</code><strong>与</strong><code>netstat –r</code>**功能是一样的。</p>
</li>
<li><p>在Linux中，DNS服务器的配置文件为<code>/etc/resolv.conf</code>。</p>
</li>
<li><p>MD5算法属于<strong>摘要算法</strong>。</p>
</li>
<li><p><strong>集成windows身份验证</strong>是安全级别最高的验证方法。</p>
</li>
<li><p><strong>网络可用性</strong>是指用户可利用网络时间得百分比。</p>
</li>
<li><p><strong>网络管理功能：</strong>网络管理的5大功能为：配置管理、故障管理、计费管理、性能管理和安全管理。</p>
</li>
<li><p><strong>BGP传输协议及端口：</strong>BGP将TCP用作其传输协议，运行在TCP的179端口上（目的端口）。</p>
</li>
<li><p><strong>BGP邻居关系维持：</strong>BGP使用keepalive周期性的发送存活消息（60s）维持邻居关系。</p>
</li>
<li><p><strong>IPsec传输模式选择：</strong>IPsec传输模式和隧道模式，实现端到端的传输应选择传输模式。</p>
</li>
<li><p><strong>IPv6地址类型：</strong>IPv6地址分为3中类型，它们是单播地址、组播地址、任意播地址。</p>
</li>
<li><p><strong>802.11 MAC层算法：</strong>802.11在MAC层采用了CSMA&#x2F;CA算法。</p>
</li>
<li><p><strong>Ieee802.11n数据速率：</strong>Ieee802.11n提供的最高数据速率可达到300Mbit&#x2F;s。</p>
</li>
<li><p><strong>IEEE802.16标准：</strong>IEEE802.16工作组提出的无线接入系统空中接口标准是WiMAX。</p>
</li>
<li><p><strong>安全电子邮件协议：</strong>安全电子邮件使用PGP协议。</p>
</li>
<li><p>Linux服务器中DHCP服务器程序对应的配置文件的名称为<code>dhcp.conf</code>，该文件的默认目录是<code>/etc</code>。</p>
</li>
<li><p><strong>CSMA&#x2F;CD（载波监听多路访问 &#x2F; 碰撞检测）算法：</strong></p>
<ul>
<li><strong>基本原理：</strong><ul>
<li>CSMA&#x2F;CD 主要用于解决在共享介质的以太网中，多个节点同时访问介质时可能产生的冲突问题。其工作过程主要包括载波监听、冲突检测和退避。</li>
<li>当一个节点要发送数据时，首先会进行载波监听，也就是检测信道是否空闲。如果信道空闲，节点就开始发送数据；如果信道忙，则节点会等待，直到信道空闲。</li>
</ul>
</li>
<li><strong>冲突检测机制：</strong><ul>
<li>在发送数据过程中，节点同时进行冲突检测。这是因为电磁波在介质中传播需要时间，即使在发送数据时检测到信道空闲，但在数据传输过程中仍有可能与其他节点发送的数据发生冲突。</li>
<li>节点通过比较自己发送的数据信号和从信道上接收到的信号来判断是否发生冲突。如果发现信号不同，就表示发生了冲突。</li>
</ul>
</li>
<li><strong>退避算法：</strong><ul>
<li>一旦检测到冲突，发送节点会立即停止发送数据，并执行退避算法。退避算法的目的是让发生冲突的节点在不同的时间重新尝试发送数据，以减少再次冲突的可能性。</li>
<li>常用的退避算法是二进制指数退避算法。在这种算法中，冲突次数 n 决定了节点重新发送数据前需要等待的时间间隔。等待时间间隔的计算公式为，其中是一个在区间均匀分布的随机数，是一个与网络参数相关的常量（如时隙时间）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>监听算法分类：</strong></p>
<ul>
<li><strong>非坚持 CSMA（Non - persistent CSMA）：</strong><ul>
<li><strong>工作原理：</strong><ul>
<li>当一个节点要发送数据时，首先监听信道。如果信道空闲，就立即发送数据；如果信道忙，则不再继续监听，而是随机等待一段时间后，再重新监听信道是否空闲。</li>
</ul>
</li>
<li><strong>特点：</strong><ul>
<li>这种算法的优点是减少了节点等待信道空闲的时间，因为一旦发现信道忙就不再监听，而是等待一段时间后重新尝试。缺点是如果有多个节点同时等待发送数据，可能会导致频繁的冲突，因为它们重新开始监听的时间是随机的，很可能再次同时发现信道空闲而同时发送数据。</li>
</ul>
</li>
</ul>
</li>
<li>1 - 坚持 CSMA（1 - persistent CSMA）<ul>
<li>工作原理<ul>
<li>当节点要发送数据时，首先监听信道。如果信道空闲，就立即发送数据；如果信道忙，则持续监听，直到信道空闲后立即发送数据。</li>
</ul>
</li>
<li>特点<ul>
<li>优点是只要信道空闲，节点就能很快地发送数据，减少了等待时间。缺点是如果有两个或多个节点同时等待发送数据，当信道空闲时，它们会同时发送数据，导致冲突概率较高。</li>
</ul>
</li>
</ul>
</li>
<li>P - 坚持 CSMA（P - persistent CSMA）<ul>
<li>工作原理<ul>
<li>用于时分复用的信道。当节点要发送数据时，首先监听信道。如果信道空闲，就以概率发送数据，以概率推迟发送；如果信道忙，则持续监听，直到信道空闲后，再按照上述概率规则发送数据。</li>
</ul>
</li>
<li>特点<ul>
<li>这种算法试图在非坚持 CSMA 和 1 - 坚持 CSMA 之间找到一个平衡。当时，它就变成了 1 - 坚持 CSMA；当时，它就变成了非坚持 CSMA。但是，它的实现相对复杂，而且要选择合适的值才能有效地降低冲突概率。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>IEEE802.3最小帧长：</strong>IEEE802.3规定的最小帧长为64字节。</p>
</li>
<li><p>Apache的主配置文件名是<code>http.conf</code>，改文件所在所在目录为<code>/etc</code>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>网工</category>
      </categories>
      <tags>
        <tag>网络工程师</tag>
        <tag>考试知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown教程</title>
    <url>https://kfufys.github.io/posts/c079e252.html</url>
    <content><![CDATA[<img src="https://kfufys.github.io/posts/c079e252/1.png" alt="Markdown" width="1200">

<h3 id="一、Markdown简介"><a href="#一、Markdown简介" class="headerlink" title="一、Markdown简介"></a>一、Markdown简介</h3><p><code>Markdown</code> 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。<br><code>Markdown</code> 允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的HTML文档。<br><code>Markdown</code> 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。<br><code>Markdown</code> 编写的文档后缀为 .md、.markdown。<br><code>Markdown</code> 是目前互联网上流行的写作语言之一，很多网站平台的文章、博客、论文都是基于它写的。</p>
<h3 id="二、Markdown优点"><a href="#二、Markdown优点" class="headerlink" title="二、Markdown优点"></a>二、Markdown优点</h3><p>很多人看到【轻量级】【标记】【语言】这些标签就直接放弃了，想着自己学习了非常多的语言，为了记个笔记写个博客还要再学习一门语言吗？实则不然，Markdown的语言非常非常简单，如果想学，10分钟你完全可以学完90%的常用的语法，而且你从此摆脱排版的折磨，属实是强迫症党的福利了。它的优点不仅限于此：</p>
<ul>
<li>纯文本编辑，只要是支持 Markdown 编辑的都能获得同样的结果，摆脱排版苦恼</li>
<li>学习成本低，常用的语法很少，简单易学快速上手</li>
<li>支持跨平台同步数据</li>
<li>支持插入图片、视频等</li>
<li>随时修改，不必担心word等工具出现排版错误</li>
</ul>
<h3 id="三、Markdown基本语法"><a href="#三、Markdown基本语法" class="headerlink" title="三、Markdown基本语法"></a>三、Markdown基本语法</h3><h4 id="3-1-标题"><a href="#3-1-标题" class="headerlink" title="3.1 标题"></a>3.1 标题</h4><p>使用 <code>#</code> 标记，可表示1~6级标题， 随 <code>#</code> 的个数递增，一级标题字号最大，六级标题字号最小。  </p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<p><strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/2.png" alt="Markdown_Title" width="1200">

<blockquote>
<p><em><strong>注意</strong></em>：</p>
<ul>
<li>最好 <code>#</code> 字符与标题文本中间留一个空格</li>
<li>标题应该置于行首，如果放入表格中可能无法正确解析</li>
</ul>
</blockquote>
<h4 id="3-2-字体"><a href="#3-2-字体" class="headerlink" title="3.2 字体"></a>3.2 字体</h4><p><code>*</code> 与 <code>_</code> 都可以，1个斜体，2个粗体，3个粗斜体</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*这是斜体*</span></span><br><span class="line"><span class="emphasis">_这是斜体_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**这是粗体**</span></span><br><span class="line"><span class="strong">__这是粗体__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*这是粗斜体*</span>**</span></span><br><span class="line"><span class="strong">__<span class="emphasis">_这是粗斜体_</span>__</span></span><br></pre></td></tr></table></figure>

<p><strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/3.png" alt="Markdown_Font" width="1200">

<blockquote>
<p><em><strong>快捷键</strong></em>：</p>
<ul>
<li>加粗 <code>Ctrl+B</code></li>
<li>斜体 <code>Ctrl+I</code></li>
</ul>
</blockquote>
<h4 id="3-3-换行"><a href="#3-3-换行" class="headerlink" title="3.3 换行"></a>3.3 换行</h4><p>Markdown换行的方式有很多种:</p>
<ul>
<li>直接在一句话后敲两个空格</li>
<li>两句话之间加一个空行</li>
<li>如果你在编辑的时候，想让一行文字在显示的时候换行，就在中间加<code>&lt;br/&gt;</code></li>
</ul>
<p> <strong>示例代码</strong>：</p>
 <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Hello World  </span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">Hello World<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span>Hello World</span><br></pre></td></tr></table></figure>
<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/4.png" alt="Markdown_enter" width="1200">

<h4 id="3-4-引用"><a href="#3-4-引用" class="headerlink" title="3.4 引用"></a>3.4 引用</h4><p>Markdown 中引用通过符号 <code>&gt;</code> 来实现。</p>
<ul>
<li><code>&gt;</code> 符号后的空格，可有可无。  </li>
<li>在引用的区块内，允许换行存在，换行并不会终止引用的区块。</li>
<li>如果要结束引用，需要一行空白行，来结束引用的区块。</li>
</ul>
<p> <strong>示例代码</strong>：</p>
 <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一个引用</span></span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/5.png" alt="Markdown_quote1" width="1200">

<blockquote>
<p><strong>此外，引用还可以嵌套使用</strong>  </p>
</blockquote>
<p> <strong>示例代码</strong>：</p>
 <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一个引用：</span></span><br><span class="line">&gt;&gt; 这是一个引用的引用</span><br><span class="line">&gt;&gt;&gt; 这是一个引用的引用的引用</span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/6.png" alt="Markdown_quote2" width="1200">

<h4 id="3-5-链接"><a href="#3-5-链接" class="headerlink" title="3.5 链接"></a>3.5 链接</h4><p>Markdown 中插入链接的使用方式是：  </p>
<p> <strong>示例代码</strong>：</p>
 <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> [<span class="string">链接名称</span>](<span class="link">链接地址</span>)</span><br><span class="line"><span class="bullet">2.</span> &lt;链接地址&gt;</span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/7.png" alt="Markdown_link" width="1200">

<h4 id="3-6-图片"><a href="#3-6-图片" class="headerlink" title="3.6 图片"></a>3.6 图片</h4><p>Markdown 中插入图片的使用方式是：  </p>
<p> <strong>示例代码</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片描述，可写可不写，但中括号要有</span>](<span class="link">图片地址，本地链接或者URL地址。</span>)</span><br></pre></td></tr></table></figure>
<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/8.png" alt="Markdown_img" width="1200">

<h4 id="3-7-列表"><a href="#3-7-列表" class="headerlink" title="3.7 列表"></a>3.7 列表</h4><p>列表分为有序列表和无序列表</p>
<ul>
<li>无序列表，使用<code>*</code>、<code>+</code>、<code>-</code>，再加一个空格作为列表的标记</li>
<li>有序列表，使用数字并加上<code>.</code>号，再加一个空格作为列表的标记</li>
</ul>
<p> <strong>示例代码</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> 无序列表 1</span><br><span class="line"><span class="bullet">+</span> 无序列表 2</span><br><span class="line"><span class="bullet">-</span> 无序列表 3</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 有序列表 1</span><br><span class="line"><span class="bullet">2.</span> 有序列表 2</span><br><span class="line"><span class="bullet">3.</span> 有序列表 3</span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/9.png" alt="Markdown_listtable1" width="1200">

<blockquote>
<p><strong>如果想要控制列表的层级，则需要在列表符号前使用 <code>Tab</code></strong></p>
</blockquote>
<p> <strong>示例代码</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">+</span> 无序列表 1</span><br><span class="line"><span class="bullet">+</span> 无序列表 2</span><br><span class="line"><span class="bullet">	+</span> 无序列表 2.1</span><br><span class="line"><span class="bullet">	+</span> 无序列表 2.2</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 有序列表 1</span><br><span class="line"><span class="code">	1.1 有序列表 1.1</span></span><br><span class="line"><span class="code">2. 有序列表 2</span></span><br><span class="line"><span class="code">	2.1 有序列表2.1</span></span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/10.png" alt="Markdown_listtable2" width="1200">

<h4 id="3-8-分割线"><a href="#3-8-分割线" class="headerlink" title="3.8 分割线"></a>3.8 分割线</h4><p>可在一行中用三个 <code>-</code> 、<code>_</code> 或 <code>*</code> 来建立一个分割线。</p>
<p>*<strong>注意</strong>：在分割线的上面空一行，否则会导致前一行字体放大。</p>
<p> <strong>示例代码</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">#### 使用三个或更多的连字符 -</span></span><br><span class="line"></span><br><span class="line">这是分割线上面的内容。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这是分割线下面的内容。</span><br><span class="line"></span><br><span class="line"><span class="section">#### 使用三个或更多的星号 *</span></span><br><span class="line"></span><br><span class="line">上面部分的文本。</span><br><span class="line"></span><br><span class="line"><span class="strong">***</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">下面部分的文本。</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">#### 使用三个或更多的下划线 _</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">分割线之上。</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">___</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">分割线之下。</span></span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/11.png" alt="Markdown_splitLine" width="1200">

<h4 id="3-9-删除线"><a href="#3-9-删除线" class="headerlink" title="3.9 删除线"></a>3.9 删除线</h4><p>在要添加删除线的文字前后添加两个 <code>~</code>  </p>
<p> <strong>示例代码</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~这是要被删除的文字~~</span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/12.png" alt="Markdown_strikethrough" width="1200">

<h4 id="3-10-下划线"><a href="#3-10-下划线" class="headerlink" title="3.10 下划线"></a>3.10 下划线</h4><p>在要添加下划线的文字首尾添加 <code>&lt;u&gt;</code>  标签</p>
<p> <strong>示例代码</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>这是添加下划线的文字<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/13.png" alt="Markdown_underscore" width="1200">

<h4 id="3-11-代码块"><a href="#3-11-代码块" class="headerlink" title="3.11 代码块"></a>3.11 代码块</h4><p>Markdown中代码块有两种：  </p>
<ul>
<li>如果在一行内需要引用代码，只需要用两个反引号引起来。</li>
<li>如果在一个块内引用代码，则在要引用的代码块的前一行和后一行使用三个反引号，同时在前一个反引号后写入代码语言。</li>
</ul>
<p> <strong>示例代码</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">### Code Blocks</span></span><br><span class="line"><span class="code">`Hello World`</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span></span><br><span class="line"></span><br><span class="line">message = greet(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/14.png" alt="Markdown_CodeBlocks" width="1200">

<h4 id="3-12-表格"><a href="#3-12-表格" class="headerlink" title="3.12 表格"></a>3.12 表格</h4><p>表格使用<code>|</code>来分割不同的单元格，使用<code>-</code>来分隔表头和其他行</p>
<ul>
<li><code>:-</code>：将表头及单元格内容左对齐</li>
<li><code>-:</code>：将表头及单元格内容右对齐</li>
<li><code>:-:</code>：将表头及单元格内容居中</li>
</ul>
<p> <strong>示例代码</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :----- | -----: | :------: |</span><br><span class="line">| 内容1  |  内容2 |  内容3   |</span><br><span class="line">| 内容4  |  内容5 |  内容6   |</span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/15.png" alt="Markdown_Table" width="1200">

<h4 id="3-13-脚注"><a href="#3-13-脚注" class="headerlink" title="3.13 脚注"></a>3.13 脚注</h4><p>脚注主要由两部分构成：在正文中标记脚注的位置和在文档末尾定义脚注的内容。</p>
<ul>
<li><strong>在正文中标记脚注</strong>：使用 [^标记名] 来标记脚注的位置，其中 “标记名” 可以是数字、字母或其他字符组合，但在同一个文档里不能重复。</li>
<li><strong>在文档末尾定义脚注内容</strong>：使用 [^标记名]: 脚注具体内容 来给出脚注的详细说明，这里的 “标记名” 要和正文中的保持一致。</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Typora[^T] 编辑器进行书写。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">^1</span>]: <span class="link">Markdown 是一种轻量级标记语言，它使用简单的文本格式来标记文本结构，能让写作者专注于内容创作，提高书写效率。</span></span><br><span class="line">[<span class="symbol">^2</span>]: <span class="link">Markdown 可以借助多种工具，如 Pandoc 等，方便快捷地转换为 HTML 格式，便于在网页上展示。</span></span><br><span class="line">[<span class="symbol">^T</span>]: <span class="link">Typora 是一款简洁易用的 Markdown 编辑器，采用所见即所得的编辑模式，能实时预览 Markdown 渲染效果，提升书写体验。</span></span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/16.png" alt="Markdown_footnotes" width="1200">

<h4 id="3-14-特殊符号"><a href="#3-14-特殊符号" class="headerlink" title="3.14 特殊符号"></a>3.14 特殊符号</h4><p>对于Markdown中的语法符号，符号前面加反斜线<code>\</code>即可以显示符号本身。  </p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是一个普通的 \# 符号，并非标题标记。</span><br><span class="line">这里有一个转义后的 \* 星号和一个 \_ 下划线。</span><br><span class="line">这是一个普通的 \- 连字符，不是列表项。</span><br><span class="line">在代码里可能会用到 \` 反引号。</span><br><span class="line">这是一个转义后的 \( 左括号和 \) 右括号，以及 \[ 左方括号和 \] 右方括号。</span><br><span class="line">这里有一个转义后的 \| 管道符号。</span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/17.png" alt="Markdown_escaped character" width="1200">

<h3 id="四、Markdown高级语法"><a href="#四、Markdown高级语法" class="headerlink" title="四、Markdown高级语法"></a>四、Markdown高级语法</h3><h4 id="4-1-制作待办事项"><a href="#4-1-制作待办事项" class="headerlink" title="4.1 制作待办事项"></a>4.1 制作待办事项</h4><p>用 <code>Markdown</code> 制作待办事项，格式为：<code>-[]</code> 表示未完成；<code>-[x]</code>表示已完成 </p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] 支持以 <span class="code">`PDF`</span> 格式导出文稿</span><br><span class="line"><span class="bullet">-</span> [ ] 改进 <span class="code">`Cmd`</span> 渲染算法，使用局部渲染技术提高渲染效率</span><br><span class="line"><span class="bullet">-</span> [x] 新增 <span class="code">`Todo`</span> 列表功能</span><br><span class="line"><span class="bullet">-</span> [x] 修复 <span class="code">`LaTex`</span> 公式渲染问题</span><br><span class="line"><span class="bullet">-</span> [x] 新增 <span class="code">`LaTex`</span> 公式编号功能</span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/4-1.png" alt="Markdown_To-do list" width="1200">

<h4 id="4-2-书写公式"><a href="#4-2-书写公式" class="headerlink" title="4.2 书写公式"></a>4.2 书写公式</h4><p>Markdown支持书写公式，例如书写一个纳维 - 斯托克斯方程。<br><code>$$</code>表示整行公式  </p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">对于粘性不可压缩流体，纳维 - 斯托克斯方程可以表示为：</span><br><span class="line">$$</span><br><span class="line">\rho \left( \frac&#123;\partial \mathbf&#123;v&#125;&#125;&#123;\partial t&#125; + \mathbf&#123;v&#125; \cdot \nabla \mathbf&#123;v&#125; \right) = -\nabla p + \mu \nabla^2 \mathbf&#123;v&#125; + \mathbf&#123;f&#125;</span><br><span class="line">$$</span><br><span class="line">其中 $\rho$ 是流体密度，$\mathbf&#123;v&#125;$ 是流体速度矢量，$t$ 是时间，$p$ 是压力，$\mu$ 是动力粘度，$\nabla$ 是梯度算子，$\nabla^2$ 是拉普拉斯算子，$\mathbf&#123;f&#125;$ 是作用在流体上的外力密度。</span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/4-2.png" alt="Markdown_To-do list" width="1200">

<h4 id="4-3-绘制流程图"><a href="#4-3-绘制流程图" class="headerlink" title="4.3 绘制流程图"></a>4.3 绘制流程图</h4><p><strong>代码解释</strong>：</p>
<ul>
<li><code>graph LR</code>：表示这是一个从左到右（Left to Right）方向的流程图。</li>
<li><code>classDef</code>：用于定义不同类型节点的样式。</li>
<li>各个节点（如 <code>A</code>、<code>B</code> 等）通过箭头连接，并且可以添加条件判断（如 <code>|是|</code>、<code>|否|</code>）。</li>
</ul>
<p><strong>示例代码</strong>：（在支持 Mermaid 的环境中）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;mermaid&quot;&gt;graph LR</span><br><span class="line">    classDef startend fill:#F5EBFF,stroke:#BE8FED,stroke-width:2px;</span><br><span class="line">    classDef process fill:#E5F6FF,stroke:#73A6FF,stroke-width:2px;</span><br><span class="line">    classDef decision fill:#FFF6CC,stroke:#FFBC52,stroke-width:2px;</span><br><span class="line">    </span><br><span class="line">    A([开始]):::startend --&gt; B&#123;是否需要帮助?&#125;:::decision</span><br><span class="line">    B --&gt;|是| C(寻求帮助):::process</span><br><span class="line">    B --&gt;|否| D(自行解决):::process</span><br><span class="line">    C --&gt; E(问题解决):::process</span><br><span class="line">    D --&gt; E</span><br><span class="line">    E --&gt; F([结束]):::startend&lt;/pre&gt;</span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/4-3.png" alt="Markdown_flow chart" width="1200">

<h4 id="4-4-绘制序列图"><a href="#4-4-绘制序列图" class="headerlink" title="4.4 绘制序列图"></a>4.4 绘制序列图</h4><p><strong>代码解释</strong>：</p>
<ul>
<li><code>participant</code>：用于定义序列图中的参与者。</li>
<li><code>-&gt;&gt;</code> 表示实线箭头（主动消息），<code>--&gt;&gt;</code> 表示虚线箭头（返回消息）。</li>
</ul>
<p><strong>示例代码</strong>：（在支持 Mermaid 的环境中）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;mermaid&quot;&gt;sequenceDiagram</span><br><span class="line">    participant User</span><br><span class="line">    participant System</span><br><span class="line">    User-&gt;&gt;System: 发起请求</span><br><span class="line">    System--&gt;&gt;User: 请求接收确认</span><br><span class="line">    System-&gt;&gt;System: 处理请求</span><br><span class="line">    System--&gt;&gt;User: 返回处理结果&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<img src="https://kfufys.github.io/posts/c079e252/4-4.png" alt="Markdown_sequence diagram" width="1200">

<h4 id="4-5-绘制甘特图"><a href="#4-5-绘制甘特图" class="headerlink" title="4.5 绘制甘特图"></a>4.5 绘制甘特图</h4><p><strong>代码解释</strong>：</p>
<ul>
<li><code>title</code>：设置甘特图的标题。</li>
<li><code>dateFormat</code>：指定日期的格式。</li>
<li><code>section</code>：划分不同的项目阶段，每个任务通过任务名、任务标识（如 <code>a1</code>）、开始日期和持续时间来定义。</li>
</ul>
<p><strong>示例代码</strong>：（在支持 Mermaid 的环境中）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;pre class=&quot;mermaid&quot;&gt;gantt</span><br><span class="line">    title 项目进度甘特图</span><br><span class="line">    dateFormat  YYYY-MM-DD</span><br><span class="line">    section 项目阶段</span><br><span class="line">    需求分析           :a1, 2024-01-01, 30d</span><br><span class="line">    设计阶段           :after a1, 20d</span><br><span class="line">    开发阶段           :after a2, 60d</span><br><span class="line">    测试阶段           :after a3, 20d</span><br><span class="line">    上线发布           :after a4, 1d&lt;/pre&gt;</span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/4-5.png" alt="Markdown_Gantt chart" width="1200">

<h4 id="4-6-内嵌Html"><a href="#4-6-内嵌Html" class="headerlink" title="4.6 内嵌Html"></a>4.6 内嵌Html</h4><p>Markdown 允许直接嵌入 HTML 标签，在 Markdown 文件中编写 HTML 代码时，Markdown 解析器会将 HTML 代码原样保留并按照 HTML 的规则进行渲染。不过要注意，不同的 Markdown 解析器对 HTML 的支持可能会有细微差异。</p>
<p><strong>示例代码</strong>：</p>
<p>使用 HTML 的 <code>&lt;a&gt;</code> 标签结合 CSS 样式可以创建链接按钮。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://kfufys.github.io&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: inline-block; background-color: #007BFF; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;&quot;</span>&gt;</span>访问示例网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> <strong>渲染效果</strong>：</p>
<img src="https://kfufys.github.io/posts/c079e252/4-6.png" alt="Markdown_Embedded Html" width="1200">

<h3 id="五、Markdown工具"><a href="#五、Markdown工具" class="headerlink" title="五、Markdown工具"></a>五、Markdown工具</h3><p>Markdown 编辑器有很多，它们在功能、适用平台、界面设计等方面各有特色，以下为你介绍一些常用的 Markdown 编辑器：</p>
<h4 id="5-1-通用跨平台编辑器"><a href="#5-1-通用跨平台编辑器" class="headerlink" title="5.1 通用跨平台编辑器"></a>5.1 通用跨平台编辑器</h4><ul>
<li><p><b><span class="exturl" data-url="aHR0cHM6Ly90eXBvcmFpby5jbi8=">Typora<i class="fa fa-external-link-alt"></i></span></b></p>
<ul>
<li><p><strong>特点</strong>：这是一款简洁美观的 Markdown 编辑器，最大的亮点是采用所见即所得的编辑模式，支持多平台，包括 Windows、Mac 和 Linux。</p>
</li>
<li><p><strong>适用场景</strong>：适合日常写作、博客撰写、笔记记录等场景，能让用户专注于内容创作。</p>
</li>
</ul>
</li>
<li><p><b><span class="exturl" data-url="aHR0cHM6Ly92c2NvZGUuanMuY24vRG93bmxvYWQ=">Visual Studio Code<i class="fa fa-external-link-alt"></i></span></b></p>
<ul>
<li><p><strong>特点</strong>：作为一款强大的开源代码编辑器，VS Code 通过安装 Markdown 相关的扩展插件，可实现丰富的 Markdown 编辑功能，如语法高亮、自动补全、预览等。支持 Git 集成，方便进行版本控制。</p>
</li>
<li><p><strong>适用场景</strong>：对于开发者来说，在编写代码文档、技术博客时使用 VS Code 非常便捷，可与开发工作无缝衔接。</p>
</li>
</ul>
</li>
<li><p><b><span class="exturl" data-url="aHR0cHM6Ly9vYnNpZGlhbi5tZA==">Obsidian<i class="fa fa-external-link-alt"></i></span></b></p>
<ul>
<li><p><strong>特点</strong>：它是一款基于本地文件的知识管理和笔记应用，支持 Markdown 格式。具有强大的链接和图谱功能，可以方便地建立笔记之间的关联，形成个人知识网络。</p>
</li>
<li><p><strong>适用场景</strong>：适合构建个人知识体系、做学习笔记、进行项目规划等，有助于知识的整理和沉淀。</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-2-在线编辑器"><a href="#5-2-在线编辑器" class="headerlink" title="5.2 在线编辑器"></a>5.2 在线编辑器</h4><ul>
<li><p><b><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29t">GitHub<i class="fa fa-external-link-alt"></i></span></b></p>
<ul>
<li><p><strong>特点</strong>：作为全球最大的代码托管平台，GitHub 内置了 Markdown 编辑器，在创建和编辑 README 文件、Wiki 页面时可直接使用。支持 Markdown 语法，方便开发者展示项目信息和文档。</p>
</li>
<li><p><strong>适用场景</strong>：对于开发者来说，在 GitHub 上使用 Markdown 编写项目文档是非常常见的操作，便于与团队成员和其他开发者共享信息。</p>
</li>
</ul>
</li>
<li><p><b><span class="exturl" data-url="aHR0cHM6Ly93d3cuenlidWx1by5jb20vbWRlZGl0b3I=">Cmd Markdown<i class="fa fa-external-link-alt"></i></span></b></p>
<ul>
<li><p><strong>特点</strong>：这是一款功能丰富的在线 Markdown 编辑器，支持云存储，方便在不同设备间同步文档。提供多种主题和模板，可导出为多种格式，还支持数学公式、流程图等高级功能。</p>
</li>
<li><p><strong>适用场景</strong>：适合需要在线协作编辑、跨设备使用的场景，如团队文档编写、学术论文撰写等。</p>
</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>如须学习更多 Markdown 实用小技巧，可以参考这个 Blog：<span class="exturl" data-url="aHR0cHM6Ly9tYXJrZG93bi5jb20uY24vY2hlYXQtc2hlZXQuaHRtbA==">Markdown 教程<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络工程师考试知识点_02</title>
    <url>https://kfufys.github.io/posts/65202.html</url>
    <content><![CDATA[<img src="https://kfufys.github.io/posts/65202/1.jpg" alt="head-img" width="1200">

<h4 id="一、事务："><a href="#一、事务：" class="headerlink" title="一、事务："></a><strong>一、事务：</strong></h4><ul>
<li><strong>原子性：</strong>事务包含的操作要么全部成功，要么全部失败回滚。</li>
<li><strong>一致性：</strong>事务执行前后都必须处于一个一致性状态。</li>
<li><strong>隔离性：</strong>多事务并发执行，任一事务更新操作到成功提交的过程，对其他事务都是不可见的。</li>
<li><strong>持久性：</strong>事务一经提交，对数据库数据的改变是永久性的。</li>
</ul>
<h4 id="二、寄存器："><a href="#二、寄存器：" class="headerlink" title="二、寄存器："></a><strong>二、寄存器：</strong></h4><ul>
<li><strong>程序计数器：</strong>存放指令地址。</li>
<li><strong>状态寄存器：</strong>记录运算中产生的标志信息。</li>
<li><strong>通用寄存器：</strong>运算时暂存操作数、地址。</li>
<li><strong>累加器：</strong>数据寄存器，运算中暂存操作数和中间结果，数据不长存。</li>
</ul>
<blockquote>
<p>CPU在<strong>一个总线周期</strong>结束时响应DMA请求。<br><strong>加法器</strong>是算术逻辑单元的部件。<br>在程序执行过程中，cache与主存的地址映像由<strong>硬件自动完成</strong>。<br>补码自带符号位，0是唯一的，n位二进制编码可以表示<strong>2<sup>n</sup><strong>个不同的数。<br>浮点数表示为阶和尾数两部分。两浮点数相加，先对阶，即</strong>将小阶向大阶对其，同时将尾数右移n位</strong>。<br>指令寄存器位数取决于<strong>指令字长</strong>。<br>为了便于多级中断，使用<strong>堆栈</strong>保护断点和现场最有效。</p>
</blockquote>
<h4 id="三、存储器分类："><a href="#三、存储器分类：" class="headerlink" title="三、存储器分类："></a><strong>三、存储器分类：</strong></h4><ul>
<li><strong>位置：</strong>内存、外存。</li>
<li><strong>材料：</strong>磁存储器、半导体存储器、光存储器。</li>
<li><strong>工作方式：</strong>读写存储器、只读存储器。</li>
<li><strong>访问方式：</strong>按地址访问、按内容访问。</li>
<li><strong>寻址方式：</strong>随机存储器、顺序存储器、直接存储器。</li>
</ul>
<h4 id="四、指令集："><a href="#四、指令集：" class="headerlink" title="四、指令集："></a><strong>四、指令集：</strong></h4><ol>
<li><strong>概念：</strong><ul>
<li><strong>RISC（Reduced Instruction Set Computer）</strong>：即精简指令集计算机。它的设计理念是通过简化指令系统，使计算机的硬件结构更简单、更规则。指令集的指令数量较少，格式相对简单且长度固定，每条指令的执行时间较短。</li>
<li><strong>CISC（Complex Instruction Set Computer）</strong>：是复杂指令集计算机。它的指令系统较为复杂，包含大量不同功能和复杂程度的指令，指令格式多样，长度可变，能完成复杂多样的操作。</li>
</ul>
</li>
<li><strong>指令特点：</strong><ul>
<li><strong>RISC：</strong><ul>
<li>指令数量通常较少，一般在几十条到一百多条之间。这些指令的功能比较单一，例如加法指令就只进行加法操作。</li>
<li>指令格式简单且固定，有利于指令的快速译码和执行。</li>
</ul>
</li>
<li><strong>CISC：</strong><ul>
<li>指令数量很多，可能包含几百条甚至上千条指令。它有各种功能强大的指令，比如可以一条指令完成从内存中读取数据、进行复杂运算并且存储结果的操作。</li>
<li>指令格式多样且长度可变。这是为了适应各种复杂指令的需求，但也使得指令的译码过程相对复杂，因为硬件需要花费更多时间来识别指令的具体格式和操作内容。</li>
</ul>
</li>
</ul>
</li>
<li><strong>性能特点：</strong><ul>
<li><strong>RISC：</strong><ul>
<li>由于指令简单、格式固定，RISC 处理器可以采用流水线技术来高效地执行指令。</li>
<li>执行速度通常较快，尤其是对于简单、重复的任务，如数值计算等。</li>
</ul>
</li>
<li><strong>CISC：</strong><ul>
<li>CISC 处理器的优势在于可以用较少的指令完成复杂的任务。例如在处理复杂的图形绘制或者文件系统操作时，它可以通过一条复杂指令完成多个简单指令的功能，从而减少程序的指令数量。</li>
<li>但是，由于指令复杂，其执行速度可能会受到影响。复杂指令的译码和执行需要更多的硬件资源和时间，而且指令长度可变也会对指令读取和存储产生一定的干扰。</li>
</ul>
</li>
</ul>
</li>
<li><strong>硬件实现复杂度：</strong><ul>
<li><strong>RISC：</strong><ul>
<li>硬件结构相对简单。因为指令集简单，处理器的控制单元设计比较规则，不需要复杂的微代码（微代码是一种用于解释和执行复杂指令的底层代码）生成电路。例如，在 RISC 处理器中，控制单元可以通过简单的逻辑电路来直接控制指令的执行流程。</li>
<li>寄存器数量通常较多，这有助于提高数据的处理速度。数据可以快速地存储在寄存器中，减少了频繁访问内存的次数，因为访问寄存器比访问内存要快得多。</li>
</ul>
</li>
<li><strong>CISC：</strong><ul>
<li>硬件实现复杂。由于指令集复杂，CISC 处理器需要复杂的控制单元和微代码生成电路来处理各种不同类型的指令。这些电路的设计和实现难度较大，需要更多的芯片面积和功耗。</li>
<li>寄存器数量可能相对较少，因为一些复杂指令可以直接在内存和运算单元之间进行操作，对寄存器的依赖程度相对较低。</li>
</ul>
</li>
</ul>
</li>
<li><strong>应用场景：</strong><ul>
<li><strong>RISC：</strong><ul>
<li>在嵌入式系统中应用广泛，如手机、平板电脑等移动设备中的处理器。这些设备通常需要高效地处理简单、重复的任务，如音频视频播放、图形显示等，RISC 处理器的快速执行和低功耗特点非常适合这些应用。</li>
<li>也用于高性能计算领域，特别是在处理大量数据的并行计算任务时，RISC 处理器的流水线技术和多核心架构可以发挥优势。</li>
</ul>
</li>
<li><strong>CISC：</strong><ul>
<li>在传统的桌面计算机和服务器中仍然有应用。因为这些系统需要运行各种复杂的软件，包括操作系统、数据库管理系统等，CISC 处理器的复杂指令可以更高效地处理这些软件中的复杂操作。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="五、内存存储容量："><a href="#五、内存存储容量：" class="headerlink" title="五、内存存储容量："></a><strong>五、内存存储容量：</strong></h4><ul>
<li>内存按字节编址，从A1000H–&gt;B13FFH的区域，存储容量为<strong>65KB</strong>。</li>
<li>结束地址与起始地址差值加1为存储单元个数：B13FFH-A1000H+1&#x3D;10400H，转为十进制：65536+1024&#x3D;64KB+1KB&#x3D;65K。</li>
</ul>
<h4 id="六、周期："><a href="#六、周期：" class="headerlink" title="六、周期："></a><strong>六、周期：</strong></h4><ul>
<li>计算机操作的最小时间单位：<strong>时钟周期</strong>。</li>
<li>一个<strong>指令周期</strong>需要多个时钟周期。</li>
<li>一个<strong>机器周期</strong>（CPU周期）完成一个计算机基本操作的时间，需要多个时钟周期。</li>
</ul>
<h4 id="七、CPU-与外设间通信："><a href="#七、CPU-与外设间通信：" class="headerlink" title="七、CPU 与外设间通信："></a><strong>七、CPU 与外设间通信：</strong></h4><ol>
<li><p><strong>程序中断方式：</strong></p>
<ul>
<li><p>某一外设的数据准备就绪后，它“主动”向CPU发出中断请求信号，请求CPU暂时中断目前正在执行的程序转而进行数据交换；</p>
</li>
<li><p>当CPU响应这个中断时，便暂停运行主程序，自动转去执行该设备的中断服务程序；</p>
</li>
<li><p>当中断服务程序执行完毕（数据交换结束）后，CPU又<strong>回到原来的主程序继续执行</strong>。</p>
</li>
</ul>
</li>
<li><p><strong>程序查询方式：</strong></p>
<ul>
<li>CPU 不断地查询外部设备的状态寄存器，以确定设备是否准备好进行数据传输。</li>
<li>例如，在从磁盘读取数据时，CPU 会周期性地检查磁盘控制器的状态位，看数据是否已经准备好被读取。</li>
<li>如果状态位显示数据未准备好，CPU 就继续查询；</li>
<li>如果准备好了，CPU 就开始读取数据。（<strong>CPU 利用率很低</strong>）。</li>
</ul>
</li>
<li><p><strong>直接存储器访问（DMA）方式：</strong></p>
<ul>
<li><p>DMA 控制器可以在不需要 CPU 干预的情况下，直接在外部设备和内存之间进行数据传输。</p>
</li>
<li><p>在传输数据之前，CPU 需要对 DMA 控制器进行初始化，设置好传输的起始地址、数据长度、传输方向等参数。</p>
</li>
<li><p>例如，在从硬盘读取大量数据到内存时，DMA 控制器会接管总线控制权，按照预先设定的参数，将硬盘中的数据直接传输到内存指定区域，期间 CPU 可以去处理其他任务。（<strong>硬件成本相对较高</strong>）。</p>
</li>
</ul>
</li>
<li><p><strong>通道方式：</strong></p>
<ul>
<li><p>通道是一种特殊的处理机，它可以独立于 CPU 执行通道程序，专门负责管理和控制外部设备与内存之间的数据传输。</p>
</li>
<li><p>通道有自己的指令系统，可以理解为是一个 “小 CPU”，用于执行通道程序。</p>
</li>
<li><p>例如，在大型计算机系统中，磁带机的大量数据读写可以由通道来完成。</p>
</li>
<li><p>CPU 将通道程序（包括数据传输的起始地址、长度、操作类型等信息）发送给通道，通道就按照程序指令进行操作，而 CPU 可以去做其他工作。（<strong>硬件和软件实现都比较复杂，成本较高</strong>）。</p>
</li>
</ul>
</li>
</ol>
<h4 id="八、指令流水线："><a href="#八、指令流水线：" class="headerlink" title="八、指令流水线："></a><strong>八、指令流水线：</strong></h4><ol>
<li><p><strong>基本概念：</strong></p>
<ul>
<li>指令流水线是将指令的执行过程分解为多个阶段，如取指（IF）、译码（ID）、执行（EX）、访存（MEM）和写回（WB）等阶段。每个阶段由专门的硬件电路来处理，不同指令的不同阶段可以在同一时间内重叠执行，提高指令的执行效率。</li>
</ul>
</li>
<li><p><strong>计算指标：</strong></p>
<ul>
<li><strong>吞吐率（Throughput）：</strong><ul>
<li><strong>定义</strong>：单位时间内执行的指令数。它是衡量流水线性能的一个重要指标。</li>
<li><strong>计算公式</strong>：吞吐率 $TP&#x3D;\frac{n}{T_k}$，其中 $n$ 是执行的指令数，$T_k$ 是处理 $n$ 条指令所用的时间。在理想情况下（各阶段时间相等且无流水线停顿），如果流水线的时钟周期为 $T$，流水线阶段数为 $k$，则执行 $n$ 条指令的时间 $T_k&#x3D;(k + n - 1)T$，所以理想吞吐率 $TP&#x3D;\frac{n}{(k + n - 1)T}$。当 $n$ 很大时，$TP\approx\frac{1}{T}$。</li>
<li><strong>示例</strong>：假设有一个5阶段（$k &#x3D; 5$）的流水线，时钟周期 $T &#x3D; 1ns$，要执行100条指令（$n &#x3D; 100$）。按照公式计算，$T_k&#x3D;(5 + 100 - 1)\times1ns &#x3D; 104ns$，则吞吐率 $TP&#x3D;\frac{100}{104ns}\approx0.96\times10^9$ 条指令&#x2F;秒。</li>
</ul>
</li>
<li><strong>加速比（Speed - up）：</strong><ul>
<li><strong>定义</strong>：非流水线执行时间与流水线执行时间之比。它反映了流水线相对于非流水线方式在性能上的提升程度。</li>
<li><strong>计算公式</strong>：设非流水线方式执行一条指令的时间为 $T_0$，流水线的时钟周期为 $T$，流水线阶段数为 $k$，则加速比 $S&#x3D;\frac{nT_0}{(k + n - 1)T}$。在理想情况下，当各阶段时间相等且 $T &#x3D; \frac{T_0}{k}$ 时，对于大量指令（$n\gg k$），加速比 $S\approx k$。</li>
<li><strong>示例</strong>：假设非流水线方式执行一条指令需要 $10ns$（$T_0 &#x3D; 10ns$），采用一个4阶段（$k &#x3D; 4$）的流水线，且每个阶段时间相等，那么流水线的时钟周期 $T&#x3D;\frac{10ns}{4}&#x3D;2.5ns$。如果要执行1000条指令（$n &#x3D; 1000$），非流水线执行时间为 $1000\times10ns &#x3D; 10000ns$，流水线执行时间 $T_k&#x3D;(4 + 1000 - 1)\times2.5ns &#x3D; 2507.5ns$，加速比 $S&#x3D;\frac{1000\times10ns}{2507.5ns}\approx3.99$。</li>
</ul>
</li>
<li><strong>效率（Efficiency）：</strong><ul>
<li><strong>定义</strong>：流水线的设备利用率。它是指流水线中各功能段的实际使用时间与整个运行时间之比。</li>
<li><strong>计算公式</strong>：在理想情况下（各阶段时间相等），效率 $E&#x3D;\frac{n}{k(k + n - 1)}$。当 $n$ 很大时，$E\approx\frac{1}{k}$。</li>
<li><strong>示例</strong>：同样是上述4阶段（$k &#x3D; 4$）的流水线，执行1000条指令（$n &#x3D; 1000$），根据公式计算效率 $E&#x3D;\frac{1000}{4\times(4 + 1000 - 1)}\approx0.25$。</li>
</ul>
</li>
</ul>
</li>
<li><p>指令流水线操作周期为“<strong>瓶颈</strong>”段所需时间。（最大操作时间段）。</p>
</li>
</ol>
<h4 id="九、指令执行时间："><a href="#九、指令执行时间：" class="headerlink" title="九、指令执行时间："></a><strong>九、指令执行时间：</strong></h4><ol>
<li><p><strong>顺序方式执行时间计算：</strong></p>
<ul>
<li><p>在<strong>顺序执行</strong>方式下，每条指令都要依次经过取指令、分析和执行这三个阶段，上一条指令执行完所有阶段后，下一条指令才开始执行。</p>
</li>
<li><p><strong>每条指令执行总时间：</strong></p>
</li>
<li><p>执行一条指令时间为取指、分析和执行三个阶段时间之和，即：[4\triangle t + 2\triangle t + 3\triangle t &#x3D; 9\triangle t]</p>
</li>
<li><p><strong>计算600条指令执行总时间：</strong></p>
</li>
<li><p>由于是顺序执行，执行完(600)条指令所需的总时间就是一条指令执行时间乘以指令的条数，即：[9\triangle t×600 &#x3D; 5400\triangle t]</p>
</li>
</ul>
</li>
<li><p><strong>流水线方式执行时间计算：</strong></p>
<ul>
<li><p>在流水线执行方式下，不同指令的不同阶段可以<strong>重叠进行</strong>，就像工厂的流水线一样，各个阶段同时开展工作。</p>
</li>
<li><p><strong>确定流水线的阶段数及各阶段时间：</strong></p>
</li>
<li><p>本题中流水线分为取指令、分析和执行这(3)个阶段，对应的时间分别为(4\triangle t)、(2\triangle t)、(3\triangle t)。</p>
</li>
<li><p><strong>计算第一条指令进入流水线到最后一条指令流出流水线的时间：</strong></p>
<ul>
<li><p>对于流水线，执行(n)条指令所需的总时间可以用公式(T &#x3D; (k + n - 1)×\Delta t_{max})来计算（其中(k)是流水线的阶段数，(n)是指令的条数，(\Delta t_{max})是流水线各阶段中时间最长的那个阶段所用时间）。</p>
</li>
<li><p>在本题中，k &#x3D; 3，n &#x3D; 600，(\Delta t_{max}&#x3D; 4\triangle t)，将这些值代入上述公式可得：<br>$$<br>[T &#x3D; (3 + 600 - 1)×4\triangle t]<br>[&#x3D;(602)×4\triangle t]<br>[&#x3D; 2408\triangle t]<br>$$</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="十、中断响应时间："><a href="#十、中断响应时间：" class="headerlink" title="十、中断响应时间："></a><strong>十、中断响应时间：</strong></h4><ul>
<li>CPU 中断响应时间是指<strong>从 CPU 检测到中断请求信号到开始执行中断服务程序</strong>的第一条指令所需要的时间。</li>
</ul>
<h4 id="十一、机器指令寻址方式："><a href="#十一、机器指令寻址方式：" class="headerlink" title="十一、机器指令寻址方式："></a><strong>十一、机器指令寻址方式：</strong></h4><ol>
<li><strong>立即寻址：</strong><ul>
<li><strong>定义</strong>：操作数直接包含在指令中，作为指令的一部分。</li>
<li><strong>特点和用途</strong>：优点是指令执行速度快，因为不需要额外的访存操作来获取操作数，它常用于给寄存器赋初值等操作。</li>
</ul>
</li>
<li><strong>直接寻址</strong><ul>
<li><strong>定义</strong>：指令的操作数部分直接给出操作数在内存中的地址。</li>
<li><strong>特点和用途</strong>：直接寻址方式简单直观，能直接访问内存中的数据。但是，它只能访问固定的内存单元。</li>
</ul>
</li>
<li><strong>间接寻址</strong><ul>
<li><strong>定义</strong>：指令中给出的是存放操作数地址的存储单元的地址。</li>
<li><strong>特点和用途</strong>：这种寻址方式增加了地址的灵活性。通过改变存放操作数地址的寄存器内容，可以方便地访问不同的内存单元。</li>
</ul>
</li>
<li><strong>寄存器寻址</strong><ul>
<li><strong>定义</strong>：操作数存放在寄存器中，指令直接指定寄存器来获取操作数。</li>
<li><strong>特点和用途</strong>：寄存器寻址的速度非常快，因为寄存器位于CPU内部，数据访问速度比内存快得多。这种寻址方式常用于在CPU内部的寄存器之间进行数据传输和操作。</li>
</ul>
</li>
<li><strong>寄存器间接寻址</strong><ul>
<li><strong>定义</strong>：操作数的地址存放在寄存器中，通过寄存器间接获取操作数的地址。</li>
<li><strong>特点和用途</strong>：结合了寄存器寻址的速度优势和间接寻址的灵活性。它在处理数组和缓冲区等数据结构时非常有用。</li>
</ul>
</li>
<li><strong>相对寻址</strong><ul>
<li><strong>定义</strong>：以程序计数器（PC）或指令指针（IP）的当前内容为基地址，加上指令中给出的偏移量来形成操作数的有效地址。</li>
<li><strong>特点和用途</strong>：主要用于程序的分支和循环结构中。它的优点是代码的可移植性较好，因为相对地址不依赖于程序在内存中的绝对位置。</li>
</ul>
</li>
<li><strong>基址寻址</strong><ul>
<li><strong>定义</strong>：将CPU中的基址寄存器（如8086中的BX或BP）的内容与指令中给定的偏移量相加，得到操作数的地址。</li>
<li><strong>特点和用途</strong>：可以方便地访问一片连续的内存区域。这种寻址方式常用于访问数组、结构体等数据结构，其中基址寄存器可以指向数据结构的起始地址，偏移量用于访问内部的元素。</li>
</ul>
</li>
<li><strong>变址寻址</strong><ul>
<li><strong>定义</strong>：以变址寄存器（如8086中的SI或DI）的内容为基础，加上指令中给定的偏移量来确定操作数的地址。</li>
<li><strong>特点和用途</strong>：与基址寻址类似，变址寻址也用于访问连续的内存区域。它的特点是变址寄存器的内容可以在程序执行过程中动态变化，常用于循环访问数组元素。</li>
</ul>
</li>
</ol>
<h4 id="十二、Flynn分类法："><a href="#十二、Flynn分类法：" class="headerlink" title="十二、Flynn分类法："></a><strong>十二、Flynn分类法：</strong></h4><p>Flynn于1972年提出计算平台分类法主要根据指令流和数据流来分类，分为四类：</p>
<ol>
<li><p><strong>单指令流单数据流机器（S1SD)：</strong></p>
<ul>
<li>SISD机器是一种传统的串行计算机，它的硬件不支持任何形式的并行计算，所有的指令都是串行执行。并且在某个时钟周期内，CPU只能处理一个数据流。</li>
</ul>
</li>
<li><p><strong>单指令流多数据流机器（SIMD)：</strong></p>
<ul>
<li>SIMD是采用一个指令流处理多个数据流。这类机器在数字信号处理、图像处理，以及多媒体信息处理等领域非常有效。</li>
<li>Intel处理器实现的MMXTM、SSE (Streaming SIMD Extensions)、SSE2及SSE3扩展指令集，都能在单个时钟周期内处理多个数据单元。也就是说人们现在用的单核计算机基本上都属于SIMD机器。</li>
</ul>
</li>
<li><p><strong>多指令流单数据流机器(MISD)：</strong></p>
<ul>
<li>MISD采用多指令流处理单个数据流。实际情况中，用多指令流处理多数据流才是更有效的方法，因此MISD只作为理论模型出现，没投入实际应用。</li>
</ul>
</li>
<li><p><strong>多指令流多数据流机器(MIMD)：</strong></p>
<ul>
<li>MIMD机器可以同时执行多个指令流，这些指令流分别对不同数据流进行操作。</li>
</ul>
</li>
</ol>
<h4 id="十三、图像数据量："><a href="#十三、图像数据量：" class="headerlink" title="十三、图像数据量："></a><strong>十三、图像数据量：</strong></h4><ol>
<li><p><strong>计算数据量的公式：</strong></p>
<ul>
<li>图像数据量 &#x3D; 图像水平分辨率×图像垂直分辨率×像素深度（单位为位）÷ 8（单位转换为字节）。<ul>
<li><strong>图像水平分辨率和垂直分辨率</strong>：分别表示图像在水平和垂直方向上所包含的像素数量。</li>
<li><strong>像素深度</strong>：指存储每个像素所用的位数。对于真彩色图像，像素深度为24位（因为每个像素有3个基色分量，每个分量8位）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>计算示例</strong></p>
<ul>
<li><p>假设有一幅真彩色图像：800<em>600px，像素深度为24位，根据上述公式计算其数据量：<br>$$<br>[<br>\begin{align</em>}<br>&amp;800×600×24÷8\<br>&#x3D;&amp;800×600×3\<br>&#x3D;&amp;480000×3\<br>&#x3D;&amp;1440000字节<br>\end{align*}<br>]</p>
<p>[1440000÷1024÷1024≈1.37MB]<br>$$</p>
</li>
</ul>
</li>
</ol>
<h4 id="十四、CPI、MIPS、PCI、MFLOPS："><a href="#十四、CPI、MIPS、PCI、MFLOPS：" class="headerlink" title="十四、CPI、MIPS、PCI、MFLOPS："></a><strong>十四、CPI、MIPS、PCI、MFLOPS：</strong></h4><ul>
<li><p><strong>CPI（Cycles Per Instruction）：</strong>每条指令执行所需的时钟周期数。它是衡量计算机性能的一个重要指标，反映了CPU执行指令的效率。<br>$$<br>CPI &#x3D; \frac{CPU执行程序所用的时钟周期数}{程序包含的指令数}<br>$$</p>
</li>
<li><p><strong>MIPS（Million Instructions Per Second）：</strong>表示计算机在一秒钟内能够执行的指令数量，单位是百万条指令&#x2F;秒。用于衡量计算机的运算速度。<br>$$<br>MIPS &#x3D; \frac{指令数}{执行时间\times10^{6}}<br>$$</p>
</li>
<li><p><strong>PCI（Peripheral Component Interconnect）：</strong>外围部件互连，是一种计算机局部总线标准。</p>
<table>
<thead>
<tr>
<th>PCIe版本</th>
<th>单通道传输速率（GT&#x2F;s）</th>
<th>编码方式</th>
<th>单通道有效数据传输速率（Gbps）</th>
<th>x16模式总带宽（Gbps）</th>
</tr>
</thead>
<tbody><tr>
<td>1.0</td>
<td>2.5</td>
<td>8b&#x2F;10b</td>
<td>2</td>
<td>32</td>
</tr>
<tr>
<td>2.0</td>
<td>5</td>
<td>8b&#x2F;10b</td>
<td>4</td>
<td>64</td>
</tr>
<tr>
<td>3.0</td>
<td>8</td>
<td>128b&#x2F;130b</td>
<td>约7.88</td>
<td>约126</td>
</tr>
<tr>
<td>4.0</td>
<td>16</td>
<td>128b&#x2F;130b</td>
<td>约15.75</td>
<td>约252</td>
</tr>
<tr>
<td>5.0</td>
<td>32</td>
<td>128b&#x2F;130b</td>
<td>约30.5</td>
<td>约488</td>
</tr>
<tr>
<td>6.0</td>
<td>64</td>
<td>新编码和信号传输技术</td>
<td>大幅提升</td>
<td>-</td>
</tr>
</tbody></table>
</li>
<li><p><strong>MFLOPS（Million Floating - Point Operations Per Second）：</strong>每秒百万次浮点运算数，主要用于衡量计算机在浮点运算方面的性能。<br>$$<br>MFLOPS &#x3D; \frac{浮点运算次数}{执行时间\times10^{6}}<br>$$</p>
</li>
</ul>
<h4 id="十五、WLAN标准："><a href="#十五、WLAN标准：" class="headerlink" title="十五、WLAN标准："></a><strong>十五、WLAN标准：</strong></h4><table>
<thead>
<tr>
<th>标准</th>
<th>频段</th>
<th>最大数据速率</th>
<th>调制方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>802.11a</td>
<td>5GHz</td>
<td>54Mbps</td>
<td>OFDM（正交频分复用）</td>
<td>传输速率较高，但传输距离相对较短，受障碍物影响较大，频段干扰相对较少</td>
</tr>
<tr>
<td>802.11b</td>
<td>2.4GHz</td>
<td>11Mbps</td>
<td>DSSS（直接序列扩频）</td>
<td>传输距离较远，但速率较低，频段容易受到干扰，是早期广泛使用的标准之一</td>
</tr>
<tr>
<td>802.11g</td>
<td>2.4GHz</td>
<td>54Mbps</td>
<td>OFDM（正交频分复用）</td>
<td>与802.11b兼容，在2.4GHz频段实现了较高的数据传输速率，应用较为广泛</td>
</tr>
<tr>
<td>802.11n</td>
<td>2.4GHz和5GHz</td>
<td>600Mbps</td>
<td>MIMO - OFDM（多输入多输出 - 正交频分复用）</td>
<td>采用MIMO技术，提高了传输速率和传输距离，同时在两个频段都能工作，兼容性较好</td>
</tr>
<tr>
<td>802.11ac</td>
<td>5GHz</td>
<td>理论上可达6.93Gbps（实际应用中速率因多种因素降低）</td>
<td>OFDM（正交频分复用）等高级调制技术</td>
<td>主要工作在5GHz频段，进一步提高了传输速率，支持更宽的频带和更多的空间流，适合高清视频传输等高速应用场景</td>
</tr>
<tr>
<td>802.11ax（Wi - Fi 6）</td>
<td>2.4GHz和5GHz</td>
<td>理论上可达9.6Gbps</td>
<td>OFDMA（正交频分多址）等新技术</td>
<td>采用新技术提升频谱效率、降低延迟，支持更多设备同时连接，在密集用户环境下性能出色，适用于智能家居等多设备场景</td>
</tr>
<tr>
<td>802.11be（Wi - Fi 7）</td>
<td>2.4GHz、5GHz和6GHz</td>
<td>理论上可达46Gbps</td>
<td>进一步优化的调制和多址接入技术</td>
<td>新增6GHz频段资源，提供更高的传输速率、更低的延迟和更好的可靠性，有望满足未来虚拟现实、8K视频等高带宽需求应用</td>
</tr>
</tbody></table>
<h4 id="十六、微波："><a href="#十六、微波：" class="headerlink" title="十六、微波："></a><strong>十六、微波：</strong></h4><table>
<thead>
<tr>
<th>微波分类</th>
<th>频率范围</th>
<th>波长范围</th>
<th>频带名称</th>
<th>应用场景</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>分米波（UHF）</td>
<td>300MHz - 3GHz</td>
<td>1m - 10cm</td>
<td>特高频（Ultra - High Frequency）</td>
<td>广播电视信号传输、移动通信（如GSM网络部分频段）、无绳电话</td>
<td>传播特性近似于光波，沿直线传播，绕射能力弱，但在建筑物内的穿透能力相对较好；能被电离层反射，受气象条件影响相对较小</td>
</tr>
<tr>
<td>厘米波（SHF）</td>
<td>3GHz - 30GHz</td>
<td>10cm - 1cm</td>
<td>超高频（Super - High Frequency）</td>
<td>卫星通信、雷达（如气象雷达、防空雷达）、无线局域网（如Wi - Fi 5GHz频段）</td>
<td>频率较高，带宽较宽，能实现较高的数据传输速率；方向性好，能量集中，但传播损耗比分米波大，易受雨雾等天气影响</td>
</tr>
<tr>
<td>毫米波（EHF）</td>
<td>30GHz - 300GHz</td>
<td>1cm - 1mm</td>
<td>极高频（Extremely - High Frequency）</td>
<td>5G毫米波通信、高速短距离通信（如部分短距数据传输设备）、毫米波雷达（用于汽车自动驾驶等）</td>
<td>频带宽，可利用的频谱资源丰富；波束窄，方向性极强，可实现高精度的定位和探测；但传播损耗大，传输距离短，对障碍物遮挡非常敏感</td>
</tr>
<tr>
<td>丝米波</td>
<td>300GHz - 3THz</td>
<td>1mm - 0.1mm</td>
<td>太赫兹（Terahertz）</td>
<td>安检成像（如人体安检仪）、材料无损检测、高速通信（实验阶段）</td>
<td>位于毫米波和红外线之间的频段，兼具两者部分特性；具有高穿透性和高分辨率成像能力，但技术实现难度较大，信号衰减较为严重</td>
</tr>
</tbody></table>
<h4 id="十七、CRC校验（循环冗余校验）："><a href="#十七、CRC校验（循环冗余校验）：" class="headerlink" title="十七、CRC校验（循环冗余校验）："></a><strong>十七、CRC校验（循环冗余校验）：</strong></h4><ol>
<li><p><strong>基本原理：</strong></p>
<ul>
<li><p>CRC校验是一种基于多项式除法的错误检测方法。发送方和接收方事先约定一个生成多项式（如CRC - 16、CRC - 32等）。发送方将待发送的数据看成一个多项式的系数序列，用这个数据多项式除以生成多项式，得到的余数就是CRC校验码。将校验码附加在原始数据后面一起发送。</p>
</li>
<li><p>例如，对于一个简单的生成多项式$G(x)&#x3D;x^3 + x + 1$（对应的二进制数为1011），假设要发送的数据为1010。将1010看作多项式$M(x)&#x3D;x^3 + x$，在数据后面添加3个0（因为生成多项式最高次幂为3），得到1010000。用1010000除以1011（模2除法），得到余数为011，这个011就是CRC校验码。发送的数据就是1010011。</p>
</li>
</ul>
</li>
<li><p><strong>计算步骤：</strong></p>
<ul>
<li><p><strong>步骤一：确定生成多项式和数据多项式</strong>。根据应用场景和通信协议选择生成多项式，将发送的数据表示为多项式形式。</p>
</li>
<li><p><strong>步骤二：数据多项式左移</strong>。将数据多项式左移生成多项式最高次幂的位数，在低位补0。</p>
</li>
<li><p><strong>步骤三：进行模2除法</strong>。用左移后的多项式除以生成多项式，模2除法的规则是减法不借位，即异或运算。</p>
</li>
<li><p><strong>步骤四：得到校验码和发送数据</strong>。除法运算得到的余数就是CRC校验码，将校验码附加在原始数据后面作为发送数据。</p>
</li>
</ul>
</li>
<li><p><strong>校验过程：</strong></p>
<ul>
<li>接收方收到数据后，用接收到的数据（包括原始数据和CRC校验码）除以相同的生成多项式。如果余数为0，则认为数据没有错误；如果余数不为0，则说明数据在传输过程中出现了错误。</li>
</ul>
</li>
<li><p><strong>应用场景：</strong></p>
<ul>
<li>CRC校验广泛应用于数据存储和数据通信领域。在数据存储中，如硬盘、U盘等存储设备写入数据时计算CRC校验码，读取数据时进行校验，以检测数据是否因存储介质损坏等原因出现错误。在数据通信中，像以太网、蓝牙等通信协议都使用CRC校验来检测传输过程中的数据错误，确保数据的完整性。</li>
</ul>
</li>
</ol>
<h4 id="十八、二进制指数退避算法："><a href="#十八、二进制指数退避算法：" class="headerlink" title="十八、二进制指数退避算法："></a><strong>十八、二进制指数退避算法：</strong></h4><ol>
<li><p><strong>基本原理：</strong></p>
<ul>
<li><p>二进制指数退避算法主要用于解决在共享介质（如以太网）的网络环境中，多个设备同时发送数据产生冲突后的重发问题。当发生冲突时，每个发送设备随机选择一个等待时间，这个等待时间是一个时隙（时间片）的整数倍，时隙的大小是固定的。</p>
</li>
<li><p>例如，第一次发生冲突后，设备随机选择等待0或1个时隙后重发；如果再次冲突，就随机选择等待0、1、2或3个时隙后重发；每冲突一次，等待时间的上限就成倍增加，这个倍数是2的指数形式，所以称为二进制指数退避。</p>
</li>
</ul>
</li>
<li><p><strong>计算步骤：</strong></p>
<ul>
<li><p><strong>步骤一：确定冲突次数</strong>。设备检测到发送数据时发生冲突的次数。</p>
</li>
<li><p><strong>步骤二：计算等待时隙范围</strong>。根据冲突次数$n$，计算等待时隙的范围是$[0,2^n - 1]$。例如，第一次冲突$n &#x3D; 1$，等待时隙范围是$[0,1]$；第二次冲突$n &#x3D; 2$，范围是$[0,3]$。</p>
</li>
<li><p><strong>步骤三：随机选择等待时间</strong>。在计算出的等待时隙范围内随机选择一个值$k$，设备等待$k$个时隙后再尝试发送数据。</p>
</li>
</ul>
</li>
<li><p><strong>应用场景：</strong></p>
<ul>
<li>该算法主要应用于以太网等采用CSMA&#x2F;CD（载波监听多路访问&#x2F;冲突检测）协议的网络中。在这种网络环境下，多个节点共享传输介质，通过二进制指数退避算法可以有效减少冲突的再次发生概率，提高网络的稳定性和传输效率。例如，在一个办公室的局域网中，多台计算机通过以太网连接到交换机，当计算机同时发送数据产生冲突时，就会使用二进制指数退避算法来重发数据。</li>
</ul>
</li>
</ol>
<h4 id="十九、ipconfig参数表格："><a href="#十九、ipconfig参数表格：" class="headerlink" title="十九、ipconfig参数表格："></a><strong>十九、ipconfig参数表格：</strong></h4><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>/all</code></td>
<td align="left">显示完整的TCP&#x2F;IP配置信息，包括IP地址、子网掩码、默认网关、DNS服务器地址、物理（MAC）地址等所有网络适配器的详细信息。</td>
</tr>
<tr>
<td align="center"><code>/release</code></td>
<td align="left">释放通过DHCP（动态主机配置协议）获取的IP地址。</td>
</tr>
<tr>
<td align="center"><code>/renew</code></td>
<td align="left">向DHCP服务器请求更新IP地址。通常在使用<code>/release</code>释放IP地址后，或者当网络连接出现异常需要重新获取有效的IP配置时使用。</td>
</tr>
<tr>
<td align="center"><code>/flushdns</code></td>
<td align="left">清除本地DNS缓存。</td>
</tr>
<tr>
<td align="center"><code>/displaydns</code></td>
<td align="left">显示本地DNS缓存的内容。用于查看当前系统缓存的DNS记录，了解哪些域名已经被解析并存储在本地缓存中。</td>
</tr>
</tbody></table>
<h4 id="二十、RAID："><a href="#二十、RAID：" class="headerlink" title="二十、RAID："></a><strong>二十、RAID：</strong></h4><table>
<thead>
<tr>
<th align="center">RAIA级别</th>
<th align="left"><strong>特点</strong></th>
<th align="center">磁盘利用率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RAID 0</td>
<td align="left">数据条带化分布在多个磁盘上，无数据冗余，读写效率高，但一个磁盘损坏会导致所有数据丢失。<br>最少需要两块盘。</td>
<td align="center">100%</td>
</tr>
<tr>
<td align="center">RAID 1</td>
<td align="left">将数据同时写入两个或多个磁盘，实现数据完全镜像备份，提供高数据冗余，但磁盘利用率低，写性能相对较差。<br>最少需要两块盘，盘数需为偶数。</td>
<td align="center">50%</td>
</tr>
<tr>
<td align="center">RAID 3</td>
<td align="left">一块盘单独做奇偶校验盘，其余盘做RAID 0，数据以位或字节为单位分散存储在数据盘中，校验盘用于存储奇偶校验信息。<br>读写效率高，一定程度上提供数据冗余，但校验盘损坏后无法恢复数据。<br>最少需要三块盘。</td>
<td align="center">$(n - 1) &#x2F; n$，其中$n$为磁盘总数，当$n &#x3D; 3$时，利用率约为66.7%</td>
</tr>
<tr>
<td align="center">RAID 5</td>
<td align="left">数据和奇偶校验数据分布在所有磁盘上，以块为单位进行条带化存储，最多允许坏一块盘，通过奇偶校验信息恢复数据。<br>读写性能较好，读性能优于写性能，磁盘利用率较高。<br>最少需要三块盘。</td>
<td align="center">$(n - 1) &#x2F; n$，例如，当有5块磁盘时，磁盘利用率为80%</td>
</tr>
<tr>
<td align="center">RAID 6</td>
<td align="left">在RAID 5的基础上增加了一种校验码，最多允许坏两块盘，数据安全性更高，但性能相对较低，写性能比RAID 5更差。<br>最少需要四块盘。</td>
<td align="center">$(n - 2) &#x2F; n$，比如，当有6块磁盘时，磁盘利用率约为66.7%</td>
</tr>
<tr>
<td align="center">RAID 10</td>
<td align="left">先进行镜像，再进行条带化，结合了RAID 0的高读写性能和RAID 1的数据冗余优势，允许一半的磁盘（每组镜像中的一个）损坏而不丢失数据。<br>最少需要四块盘，盘数必须是偶数。</td>
<td align="center">50%</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>网工</category>
      </categories>
      <tags>
        <tag>网络工程师</tag>
        <tag>考试知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>终极 Nginx 配置指南（超详细）</title>
    <url>https://kfufys.github.io/posts/59687.html</url>
    <content><![CDATA[<img src="https://kfufys.github.io/posts/59687/nginx-logo.png" alt="head-img" width="1200">



<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>对于自己上线项目的前端来说，nginx也是必须要了解和熟悉的，查了很多的nginx文章，看着写的都很详细，但是却没有了整体的概念。这里就重新梳理一遍，也理清思路。</p>
<p>我们在安装nginx之后，会自动生成很多的文件，但是nginx.conf这个文件是我们的核心，如何去正确的修改和优化它是nginx的核心。</p>
<p>首先我们可以先看下原本的配置，你会觉得无所适从，因为感觉这个鬼东西也太多了吧。而且感觉根本就不理解，也不知道该怎么写。下面，就一步一步的教你如何入门到熟悉</p>
<h3 id="一、nginx-conf原本配置到解释"><a href="#一、nginx-conf原本配置到解释" class="headerlink" title="一、nginx.conf原本配置到解释"></a><strong>一、<code>nginx.conf</code>原本配置到解释</strong></h3><p>看到这个118行是不是觉得有点害怕</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>        mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  &#x27;$remote_addr  -  $remote_user  [$time_local]  &quot;$request&quot;  &#x27;</span></span><br><span class="line">    <span class="comment">#            &#x27;$status  $body_bytes_sent  &quot;$http_referer&quot;  &#x27;</span></span><br><span class="line">    <span class="comment">#            &#x27;&quot;$http_user_agent&quot;  &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>        <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset  koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html  index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404  /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#redirect  server  error  pages  to  the  static  page  /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span>  <span class="number">500</span>  <span class="number">502</span>  <span class="number">503</span>  <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#proxy  the  PHP  scripts  to  Apache  listening  on  127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location  ~  \.php$  &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass  http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#pass  the  PHP  scripts  to  FastCGI  server  listening  on  127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location  ~  \.php$  &#123;</span></span><br><span class="line">        <span class="comment">#    root         html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass  127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include       fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#deny  access  to  .htaccess  files,  if  Apache&#x27;s  document  root</span></span><br><span class="line">        <span class="comment">#concurs  with  nginx&#x27;s  one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location  ~  /\.ht  &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#another  virtual  host  using  mix  of  IP-,  name-,  and  port-based  configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server  &#123;</span></span><br><span class="line">    <span class="comment">#    listen        8000;</span></span><br><span class="line">    <span class="comment">#    listen        somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name   somename   alias   another.alias;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location  /  &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html  index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#HTTPS  server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server  &#123;</span></span><br><span class="line">    <span class="comment">#    listen        443  ssl;</span></span><br><span class="line">    <span class="comment">#    server_name   localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location  /  &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html  index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>没关系，我们把其中的注释都删掉，除掉了注释之后的nginx代码，现在只有22行了。感觉好多了</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;  </span><br><span class="line"><span class="section">events</span> &#123;  </span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="section">http</span> &#123;  </span><br><span class="line">    <span class="attribute">include</span>       mime.types;  </span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;  </span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;  </span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;  </span><br><span class="line">    <span class="section">server</span> &#123;  </span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;  </span><br><span class="line">        <span class="attribute">server_name</span>  localhost;  </span><br><span class="line">        <span class="section">location</span> / &#123;  </span><br><span class="line">            <span class="attribute">root</span>   html;  </span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;  </span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;  </span><br><span class="line">            <span class="attribute">root</span>   html;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>注解版本：</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#nginx进程数，建议设置为等于CPU总核心数。  </span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;  </span><br><span class="line"><span class="comment"># 事件区块开始  </span></span><br><span class="line"><span class="section">events</span> &#123;  </span><br><span class="line">    <span class="comment">#单个进程最大连接数（最大连接数=连接数*进程数）  </span></span><br><span class="line">    <span class="comment">#根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。  </span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">#设定http服务器，利用它的反向代理功能提供负载均衡支持  </span></span><br><span class="line"><span class="section">http</span> &#123;  </span><br><span class="line">    <span class="comment">#include：导入外部文件mime.types，将所有types提取为文件，然后导入到nginx配置文件中  </span></span><br><span class="line">    <span class="attribute">include</span>       mime.types;  </span><br><span class="line">     <span class="comment">#默认文件类型  </span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;  </span><br><span class="line">    <span class="comment">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。  </span></span><br><span class="line">    <span class="comment">#sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。  </span></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;  </span><br><span class="line">      <span class="comment">#长连接超时时间，单位是秒  </span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;  </span><br><span class="line">    <span class="comment"># 第一个Server区块开始，表示一个独立的虚拟主机站点  </span></span><br><span class="line">    <span class="section">server</span> &#123;  </span><br><span class="line">        <span class="comment"># 提供服务的端口，默认80  </span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;  </span><br><span class="line">        <span class="comment"># 提供服务的域名主机名  </span></span><br><span class="line">        <span class="attribute">server_name</span>  localhost;  </span><br><span class="line">        <span class="comment">#对 &quot;/&quot; 启用反向代理,第一个location区块开始  </span></span><br><span class="line">        <span class="section">location</span> / &#123;  </span><br><span class="line">            <span class="attribute">root</span>   html;  <span class="comment">#服务默认启动目录  </span></span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm; <span class="comment"># 默认的首页文件，多个用空格分开  </span></span><br><span class="line">        &#125;  </span><br><span class="line">         <span class="comment"># 错误页面路由  </span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html; <span class="comment"># 出现对应的http状态码时，使用50x.html回应客户  </span></span><br><span class="line">        <span class="section">location</span> = /50x.html &#123; <span class="comment"># location区块开始，访问50x.html  </span></span><br><span class="line">            <span class="attribute">root</span>   html;  <span class="comment"># 指定对应的站点目录为html  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<h3 id="二、整体基本理解"><a href="#二、整体基本理解" class="headerlink" title="二、整体基本理解"></a><strong>二、整体基本理解</strong></h3><p>虽然上面有了注解，但是看起来还是很迷糊。接着解释：我们可以把**<code>nginx.conf</code>**分为三个部分进行理解：</p>
<ul>
<li>第一部分：<strong>全局块</strong> </li>
<li>第二部分：<strong>events块</strong> </li>
<li>第三部分：<strong>http块</strong></li>
</ul>
<p><strong>对应图解：</strong></p>
<img src="https://kfufys.github.io/posts/59687/1.png" alt="nginx.conf 分块图解">

<h4 id="全局块："><a href="#全局块：" class="headerlink" title="全局块："></a><strong>全局块：</strong></h4><p><strong>作用：</strong>从配置文件开始到 <code>events</code>块之间的内容，主要会设置一些影响nginx服务器整体运行的配置指令，主要包括配置<strong>运行 <code>Nginx</code></strong><br><strong>服务器的用户（组）</strong>、<strong>允许生成的 <code>worker process</code> 数</strong>，<strong>进程 <code>PID</code> 存放路径</strong>、<strong>日志存放路径</strong>和<strong>类型以及配置文件的引入</strong>等。</p>
<p>比如上面第一行配置的</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;  </span><br></pre></td></tr></table></figure>


<p>这是 <code>Nginx</code> 服务器并发处理服务的关键配置，<code>worker_processes</code> 值越大，可以支持的并发处理量也越多，但是 会受到硬件、软件等设备的制约。</p>
<h4 id="events块："><a href="#events块：" class="headerlink" title="events块："></a><strong><code>events</code>块：</strong></h4><p>作用：<code>events</code> 块涉及的指令主要影响 <code>Nginx</code> 服务器与用户的网络连接，常用的设置包括是否开启对多 <code>work process</code>下的网络连接进行序列化，是否 允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个<code> word process</code> 可以同时支持的最大连接数等。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">worker_connections</span>  <span class="number">1024</span>;  </span><br></pre></td></tr></table></figure>


<p>上述例子就表示每个 <code>work process</code> 支持的最大连接数为 <code>1024</code>。</p>
<p>这部分的配置对 <code>Nginx</code> 的性能影响较大，在实际中应该灵活配置。</p>
<h4 id="http块："><a href="#http块：" class="headerlink" title="http块："></a><strong>http块：</strong></h4><p><strong>作用：</strong>这算是 <code>Nginx</code> 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。</p>
<blockquote>
<p>需要注意的是：<code>http</code> 块也可以包括 <strong>http全局块</strong>、<strong>server 块</strong>。</p>
</blockquote>
<ul>
<li><p><strong>http全局块</strong></p>
<ul>
<li>http全局块配置的指令包括<strong>文件引入</strong>、**<code>MIME-TYPE</code> 定义<strong>、</strong>日志自定义<strong>、</strong>连接超时时间<strong>、</strong>单链接请求数上限**等。</li>
</ul>
<ul>
<li><p><strong>server 块</strong></p>
<ul>
<li><p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。</p>
<ul>
<li><p>每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 </p>
</li>
<li><p>而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>全局 server 块</strong></p>
<ul>
<li>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或<code>IP</code>配置。</li>
</ul>
</li>
<li><p><strong>location 块</strong></p>
<ul>
<li>一个 <code>server</code> 块可以配置多个 <code>location</code> 块。</li>
<li>这块的主要作用是基于 <code>Nginx</code> 服务器接收到的请求字符串（例如 server_name&#x2F;uri-string），对虚拟主机名称 （也可以是<code>IP</code>别名）之外的字符串（例如 前面的 <code>/uri-string</code>）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>对应图解：</strong></p>
<img src="https://kfufys.github.io/posts/59687/2.png" alt="nginx.conf 三部分">


<h3 id="三、最简单的上线"><a href="#三、最简单的上线" class="headerlink" title="三、最简单的上线"></a><strong>三、最简单的上线</strong></h3><p>以上，我们就知道了nginx整体大致的结构，以及每部分的结构是用于做什么的。接下来我们就修改nginx关键位置来实现我们网站的代理功能。看着nginx配置很繁琐，但是如果你只是需要上线一个网站，那么你只需要去修改两个地方即可：</p>
<img src="https://kfufys.github.io/posts/59687/3.png" alt="online">

<p>我们可以使用默认简单的配置，然后指定<code>server_name</code>和<code>root</code>，主要是告诉nginx代理的<code>ip</code>是xxx，然后我放在服务器的文件在bbb文件夹即可。nginx便会在用户访问这个ip时，自动的将bbb文件夹中的<code>index.html</code>返回到浏览器来展示页面。</p>
<h3 id="四、-Nginx-优化："><a href="#四、-Nginx-优化：" class="headerlink" title="四、&#96;Nginx 优化："></a><strong>四、&#96;Nginx 优化：</strong></h3><h4 id="1-前端history模式404问题："><a href="#1-前端history模式404问题：" class="headerlink" title="1. 前端history模式404问题："></a><strong>1. 前端<code>history模式404</code>问题：</strong></h4><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;  </span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>这段代码的作用是，当用户刷新页面时，Nginx会先检查当前<code>URL</code>是否存在，如果不存在，就会尝试访问<code>index.htm</code>l，从而可以正常显示页面。</p>
<img src="https://kfufys.github.io/posts/59687/4.png" alt="404">

<h4 id="2-反向代理："><a href="#2-反向代理：" class="headerlink" title="2. 反向代理："></a><strong>2. 反向代理：</strong></h4><p>相信大家作为前端都了解跨域问题，目前前端的主流解决跨域的方式就是</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line">1. 开发生产cors解决 </span><br><span class="line">2. 开发proxy，生产nginx解决。 </span><br></pre></td></tr></table></figure>

<p><strong>如何配置：</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#接口端  </span></span><br><span class="line"><span class="section">location</span> /police/ &#123;  </span><br><span class="line">    <span class="attribute">proxy_pass</span>   http://192.168.1.182:8852/police/;  </span><br><span class="line">    <span class="attribute">proxy_redirect</span> default;  </span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;  </span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span>   <span class="number">60</span>;  </span><br><span class="line">    <span class="attribute">proxy_send_timeout</span>      <span class="number">60</span>;  </span><br><span class="line">    <span class="attribute">proxy_read_timeout</span>      <span class="number">90</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>具体位置：</strong></p>
<img src="https://kfufys.github.io/posts/59687/5.png" alt="反向代理">

<p><strong>理解：</strong></p>
<p><strong>这段代码的意思：</strong>大致就是如果遇到以<code>/police</code>请求开头的接口，那么就去访问这个ip地址(<code>http://192.168.1.182:8852/police/</code>)的后台端口。</p>
<p><strong>例如：</strong>我们通过<code>axios</code>去访问<code>/police/getList</code>这个后台接口时，nginx会将这个请求转发到ip端口为<code>http://192.168.1.182:8852</code>的后台中，后台将结果返回给nginx，nginx再把结果给到浏览器，实现反向代理。</p>
<p><strong>定义多个端口的反向代理：</strong></p>
<p>copy上面的，直接修改<code>代理头</code>和<code>proxy_pass</code>即可。</p>
<img src="https://kfufys.github.io/posts/59687/6.png" alt="代理头和proxy_pass">

<h4 id="3-开启gzip："><a href="#3-开启gzip：" class="headerlink" title="3. 开启gzip："></a><strong>3. 开启<code>gzip</code>：</strong></h4><p><strong>作用：</strong></p>
<p>开启<code>gzip</code>对于前端来说还是比较重要的，浏览器加载的包大概能节约一半的空间。例如首页需要加载<code>a.js</code>文件，该文件为<code>900kb</code>，在开启<code>gzip</code>之后，浏览器会去加载<code>a.js</code>经过<code>gzip</code>之后的文件<code>a.js.gz</code>，大概只有<code>450kb</code>，能够很好的提升浏览速度。</p>
<p><strong>如何配置：</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>; <span class="comment"># 默认off，是否开启gzip  </span></span><br><span class="line"><span class="attribute">gzip_types</span> text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 上面两个开启基本就能跑起了，下面的愿意折腾就了解一下  </span></span><br><span class="line"><span class="attribute">gzip_static</span> <span class="literal">on</span>;  </span><br><span class="line"><span class="attribute">gzip_proxied</span> any;  </span><br><span class="line"><span class="attribute">gzip_vary</span> <span class="literal">on</span>;  </span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">6</span>;  </span><br><span class="line"><span class="attribute">gzip_buffers</span> <span class="number">16</span> <span class="number">8k</span>;  </span><br><span class="line"><span class="comment"># gzip_min_length 1k;  </span></span><br><span class="line"><span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;  </span><br></pre></td></tr></table></figure>

<p><strong>具体位置：</strong></p>
<img src="https://kfufys.github.io/posts/59687/7.png" alt="gzip">

<h4 id="4-维护页面："><a href="#4-维护页面：" class="headerlink" title="4. 维护页面："></a><strong>4. 维护页面：</strong></h4><p><strong>作用：</strong></p>
<p>在系统进行维护升级时，用户打开我们的网站看到的维护页面。</p>
<p><strong>如何配置：</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 系统临时维护请打开下面这行注释，并重启nginx,维护完毕后请注释下年这行,并重启nginx  </span></span><br><span class="line"> <span class="comment"># rewrite ^(.*)$ /maintainace.html break;  </span></span><br></pre></td></tr></table></figure>

<p><strong>具体位置：</strong></p>
<img src="https://kfufys.github.io/posts/59687/8.png" alt="fix page">

<h4 id="5-一个ip上线多个网站："><a href="#5-一个ip上线多个网站：" class="headerlink" title="5. 一个ip上线多个网站："></a><strong>5. 一个<code>ip</code>上线多个网站：</strong></h4><p><strong>作用：</strong></p>
<p>只有一个<code>ip</code>。利用<code>nginx</code>上线多个网站。例如访问<code>192.168.1.154:8080</code>访问我们的个人博客网站，访问<code>192.168.1.154:8081</code>访问我们的直播网站。</p>
<p><strong>如何配置：</strong></p>
<p>直接复制<code>server块</code>即可，一个<code>server块</code>就代表了一个<code>website</code>，需要改端口和文件的路径等内容。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个网站：个人博客项目配置  </span></span><br><span class="line">  <span class="section">server</span> &#123;  </span><br><span class="line">   <span class="attribute">listen</span>       <span class="number">8080</span>;  </span><br><span class="line">   <span class="attribute">root</span>         /data/www/hexo;  </span><br><span class="line">   <span class="attribute">index</span>        index.html;  </span><br><span class="line">   <span class="section">location</span> / &#123;  </span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html; <span class="comment"># 路由模式history的修改  </span></span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="comment"># 第二个网站：直播网站项目配置  </span></span><br><span class="line"> <span class="section">server</span> &#123;  </span><br><span class="line">  <span class="attribute">listen</span>       <span class="number">8081</span>;  </span><br><span class="line">  <span class="attribute">root</span>         /data/www/geov;  </span><br><span class="line">  <span class="attribute">index</span>        index.html;  </span><br><span class="line">  <span class="section">location</span> / &#123;&#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>

<p><strong>具体位置：</strong></p>
<img src="https://kfufys.github.io/posts/59687/9.png" alt="多站设置">

<p><strong>注意点：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 这里的8081一定要你的服务器开放了这个端口才可以使用，否则你按照这个配置了也会访问不到（让后端去配）。 </span><br><span class="line">2. 如果是云服务器（比如阿里云，腾讯云），则需要开放相应的入口为8081,否则用户访问不到。 </span><br></pre></td></tr></table></figure>

<h4 id="6-动静分离："><a href="#6-动静分离：" class="headerlink" title="6. 动静分离："></a><strong>6. 动静分离：</strong></h4><p><strong>作用：</strong></p>
<p>在Web开发中，通常来说，动态资源其实就是指那些后台资源，而静态资源就是指<code>HTML</code>，<code>JavaScript</code>，<code>CSS</code>，<code>img</code>等文件。</p>
<p>一般来说，都需要将动态资源和静态资源分开，将静态资源部署在<code>Nginx</code>上，当一个请求来的时候，如果是静态资源的请求，就直接到<code>nginx</code>配置的静态资源目录下面获取资源，如果是动态资源的请求，<code>nginx</code>利用反向代理的原理，把请求转发给后台应用去处理，从而实现动静分离。</p>
<p>在使用前后端分离之后，可以很大程度的提升静态资源的访问速度，同时在开过程中也可以让前后端开发并行可以有效的提高开发时间，也可以有些的减少联调时间 。</p>
<p><strong>解析：</strong></p>
<p>实际上我们在代理前端的<code>html</code>和接口时就已经做到了动静分离。我们打包后的dist包实际上就是纯静态的资源，所以直接访问<code>nginx</code>静态资源服务器，就不需要经过后台的tomcat。访问接口时，就需要<code>nginx</code>先去访问后台服务器，拿到结果再给到浏览器</p>
<img src="https://kfufys.github.io/posts/59687/10.png" alt="动静分离">

<p><strong>图解：</strong></p>
<img src="https://kfufys.github.io/posts/59687/11.png" alt="nginx动静分离图解">

<p><strong>如何配置（其实是优化，因为一般配置会有动静分离）：</strong></p>
<p>假设有比较大的图片等需要放置到服务器上，然后通过<code>nginx</code>来转发。或者是有一个纯前端的开源项目（如<code>pdf.js</code>），也需要放在服务器上。如果放在本地代码包，打包出来体积会很大。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /image/ &#123;  </span><br><span class="line">  <span class="attribute">root</span>   /var/filecenter/;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="section">location</span> /static/ &#123;  </span><br><span class="line">  <span class="attribute">root</span>   /var/filecenter/;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="section">location</span> /car/ &#123;  </span><br><span class="line">  <span class="attribute">root</span>   /var/filecenter/;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="section">location</span> <span class="regexp">~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css)$</span> &#123;  </span><br><span class="line">  <span class="attribute">root</span> /Users/dalaoyang/Downloads/static;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>具体位置：</strong></p>
<img src="https://kfufys.github.io/posts/59687/12.png" alt="image">

<h4 id="7-其他优化"><a href="#7-其他优化" class="headerlink" title="7. 其他优化"></a><strong>7. 其他优化</strong></h4><p>这里只讲了一些<code>nginx</code>基础的知识和一些基础的优化，基本上够用了。但是如果你需要追求更高的性能，那么可以添加其他的优化，只需要根据一些搜索到的文章内容<code>copy</code>过来就行了，<code>nginx</code>主要还是配置多一些，但是理解了整体结构和脉络的话，其实就还是蛮简单的。这里就不做过多的讲解了。</p>
<h3 id="五、Nginx基础命令：安装，启动，重启，关闭"><a href="#五、Nginx基础命令：安装，启动，重启，关闭" class="headerlink" title="五、Nginx基础命令：安装，启动，重启，关闭"></a><strong>五、<code>Nginx</code>基础命令：安装，启动，重启，关闭</strong></h3><ol>
<li><strong>安装<code>nginx</code>：</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install nginx  </span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>看是否有<code>nginx</code>进程：</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -anput | grep nginx  </span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>查看服务器端口占用情况：</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ntlp  </span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong><code>nginx</code>启动:</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx  </span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong><code>nginx</code>重启:</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload  </span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>关闭<code>nginx</code>：</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s stop	<span class="comment"># 快速停止nginx </span></span><br><span class="line">nginx -s quit	<span class="comment"># 完整有序的停止nginx </span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>查看默认的<code>nginx</code>配置文件路径：</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -t  </span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong>注：</strong>如果有<code>nginx.conf</code>配置的更改，需要重启<code>nginx</code>配置才会生效。如果只是更改<code>dist</code>包<code>/html</code>，则可以不重启<code>nginx</code>。</p>
</blockquote>
<h3 id="六、参考文章："><a href="#六、参考文章：" class="headerlink" title="六、参考文章："></a><strong>六、参考文章：</strong></h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1aS1ydWktYW4vbmdpbnhwYWdlcw==">rui-rui-an&#x2F;nginxpages: nginx的配置文件<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTA0MTQ0MjM1NDEzNTEy">Nginx 从入门到实践，万字详解！ - 掘金<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjkxNDg0L2FydGljbGUvZGV0YWlscy8xMjYzNTQ3MDI=">Nginx nginx.conf配置文件详解_nginxconf配置详解-CSDN博客<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>网站部署</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>网站部署</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 常用的 50 个注解</title>
    <url>https://kfufys.github.io/posts/4233e670.html</url>
    <content><![CDATA[<img src="https://kfufys.github.io/posts/4233e670/1.png" alt="SpringBoot" width="1200">

<h3 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1. @SpringBootApplication"></a>1. <code>@SpringBootApplication</code></h3><h4 id="代码作用"><a href="#代码作用" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>这是一个组合注解，包含了 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code> 三个注解。用于标识 Spring Boot 应用程序的入口类，简化 Spring 应用程序的配置和启动过程。</p>
</blockquote>
<h4 id="代码用例"><a href="#代码用例" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@SpringBootApplication</code> 注解标注在 <code>MyApplication</code> 类上，表明这是 Spring Boot 应用的入口类。</li>
<li><code>main</code> 方法中调用 <code>SpringApplication.run(MyApplication.class, args)</code> 来启动 Spring Boot 应用程序。</li>
</ul>
<h3 id="2-RestController"><a href="#2-RestController" class="headerlink" title="2. @RestController"></a>2. <code>@RestController</code></h3><h4 id="代码作用-1"><a href="#代码作用-1" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>与 <code>@Controller</code> 类似，是 <code>@Controller</code> 和 <code>@ResponseBody</code> 的组合注解，用于标注一个类为 RESTful 风格的控制器，会自动将返回值转换为 JSON 格式，可处理 HTTP 请求并返回 JSON&#x2F;XML 格式的响应。</p>
</blockquote>
<h4 id="代码用例-1"><a href="#代码用例-1" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@RestController</code> 注解标注在 <code>HelloController</code> 类上，表明该类是一个 RESTful 风格的控制器。</li>
<li><code>hello</code> 方法使用 <code>@GetMapping</code> 注解映射 <code>/hello</code> 请求，返回的字符串会自动转换为 JSON 格式响应给客户端。</li>
</ul>
<h3 id="3-RequestMapping"><a href="#3-RequestMapping" class="headerlink" title="3. @RequestMapping"></a>3. <code>@RequestMapping</code></h3><h4 id="代码作用-2"><a href="#代码作用-2" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>是 Spring MVC 框架中的核心注解，用于映射 HTTP 请求和控制器方法之间的关系，可用于类级别和方法级别，指定请求 URL 和 HTTP 方法（GET、POST、PUT、DELETE 等）。</p>
</blockquote>
<h4 id="代码用例-2"><a href="#代码用例-2" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取用户列表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建新用户</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 ID 获取用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id, <span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 ID 删除用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@RequestMapping(&quot;/api&quot;)</code> 注解在类级别，指定该控制器处理的请求路径以 <code>/api</code> 开头。</li>
<li>各个方法上的 <code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code> 等注解进一步细化了请求的 URL 和 HTTP 方法。</li>
</ul>
<h3 id="4-GetMapping"><a href="#4-GetMapping" class="headerlink" title="4. @GetMapping"></a>4. <code>@GetMapping</code></h3><h4 id="代码作用-3"><a href="#代码作用-3" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于映射 HTTP GET 请求，是 <code>@RequestMapping(method = RequestMethod.GET)</code> 的快捷方式。</p>
</blockquote>
<h4 id="代码用例-3"><a href="#代码用例-3" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取用户列表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 ID 获取用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-3"><a href="#代码分析-3" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li>两个 <code>@GetMapping</code> 注解分别映射 <code>/api/users</code> 和 <code>/api/users/&#123;id&#125;</code> 的 GET 请求，分别用于获取用户列表和根据 ID 获取用户信息。</li>
</ul>
<h3 id="5-PostMapping"><a href="#5-PostMapping" class="headerlink" title="5. @PostMapping"></a>5. <code>@PostMapping</code></h3><h4 id="代码作用-4"><a href="#代码作用-4" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于映射 HTTP POST 请求，是 <code>@RequestMapping(method = RequestMethod.POST)</code> 的快捷方式。</p>
</blockquote>
<h4 id="代码用例-4"><a href="#代码用例-4" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建新用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-4"><a href="#代码分析-4" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@PostMapping(&quot;/users&quot;)</code> 注解映射 <code>/api/users</code> 的 POST 请求，用于创建新用户。</li>
<li><code>@RequestBody</code> 注解将 HTTP 请求体中的数据绑定到 <code>User</code> 对象。</li>
</ul>
<h3 id="6-PutMapping"><a href="#6-PutMapping" class="headerlink" title="6. @PutMapping"></a>6. <code>@PutMapping</code></h3><h4 id="代码作用-5"><a href="#代码作用-5" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于映射 HTTP PUT 请求，是 <code>@RequestMapping(method = RequestMethod.PUT)</code> 的快捷方式。</p>
</blockquote>
<h4 id="代码用例-5"><a href="#代码用例-5" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id, <span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-5"><a href="#代码分析-5" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@PutMapping(&quot;/users/&#123;id&#125;&quot;)</code> 注解映射 <code>/api/users/&#123;id&#125;</code> 的 PUT 请求，用于更新指定 ID 的用户信息。</li>
<li><code>@PathVariable</code> 注解获取 URL 中的 <code>id</code> 参数，<code>@RequestBody</code> 注解将请求体数据绑定到 <code>User</code> 对象。</li>
</ul>
<h3 id="7-DeleteMapping"><a href="#7-DeleteMapping" class="headerlink" title="7. @DeleteMapping"></a>7. <code>@DeleteMapping</code></h3><h4 id="代码作用-6"><a href="#代码作用-6" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于映射 HTTP DELETE 请求，是 <code>@RequestMapping(method = RequestMethod.DELETE)</code> 的快捷方式。</p>
</blockquote>
<h4 id="代码用例-6"><a href="#代码用例-6" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 ID 删除用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-6"><a href="#代码分析-6" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@DeleteMapping(&quot;/users/&#123;id&#125;&quot;)</code> 注解映射 <code>/api/users/&#123;id&#125;</code> 的 DELETE 请求，用于删除指定 ID 的用户。</li>
<li><code>@PathVariable</code> 注解获取 URL 中的 <code>id</code> 参数。</li>
</ul>
<h3 id="8-RequestParam"><a href="#8-RequestParam" class="headerlink" title="8. @RequestParam"></a>8. <code>@RequestParam</code></h3><h4 id="代码作用-7"><a href="#代码作用-7" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于获取请求参数的值，将 HTTP 请求中的参数绑定到控制器方法的参数上。</p>
</blockquote>
<h4 id="代码用例-7"><a href="#代码用例-7" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">(<span class="meta">@RequestParam(&quot;page&quot;)</span> <span class="type">int</span> page, <span class="meta">@RequestParam(&quot;size&quot;)</span> <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="comment">// 分页获取用户列表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-7"><a href="#代码分析-7" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@RequestParam(&quot;page&quot;)</code> 和 <code>@RequestParam(&quot;size&quot;)</code> 分别获取请求参数 <code>page</code> 和 <code>size</code> 的值，并将其绑定到方法的 <code>page</code> 和 <code>size</code> 参数上。</li>
</ul>
<h3 id="9-PathVariable"><a href="#9-PathVariable" class="headerlink" title="9. @PathVariable"></a>9. <code>@PathVariable</code></h3><h4 id="代码作用-8"><a href="#代码作用-8" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于将 HTTP 请求路径中的变量绑定到控制器方法的参数上。</p>
</blockquote>
<h4 id="代码用例-8"><a href="#代码用例-8" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 ID 获取用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-8"><a href="#代码分析-8" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@PathVariable</code> 注解将 URL 中的 <code>&#123;id&#125;</code> 参数绑定到方法的 <code>id</code> 参数上，用于根据 ID 获取用户信息。</li>
</ul>
<h3 id="10-RequestBody"><a href="#10-RequestBody" class="headerlink" title="10. @RequestBody"></a>10. <code>@RequestBody</code></h3><h4 id="代码作用-9"><a href="#代码作用-9" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于将 HTTP 请求的主体转换为方法的参数，将请求体中的数据绑定到控制器方法的参数上。</p>
</blockquote>
<h4 id="代码用例-9"><a href="#代码用例-9" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-9"><a href="#代码分析-9" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@RequestBody</code> 注解将 HTTP 请求体中的 JSON 或 XML 数据转换为 <code>User</code> 对象，并传递给 <code>createUser</code> 方法。</li>
</ul>
<h3 id="11-ResponseBody"><a href="#11-ResponseBody" class="headerlink" title="11. @ResponseBody"></a>11. <code>@ResponseBody</code></h3><h4 id="代码作用-10"><a href="#代码作用-10" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于将方法的返回值转换为 HTTP 响应的主体，将控制器方法的返回值转换为响应体中的数据。</p>
</blockquote>
<h4 id="代码用例-10"><a href="#代码用例-10" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 ID 获取用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-10"><a href="#代码分析-10" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li>由于 <code>@RestController</code> 是 <code>@Controller</code> 和 <code>@ResponseBody</code> 的组合注解，所以这里方法的返回值 <code>User</code> 对象会自动转换为 JSON 格式的响应体返回给客户端。</li>
</ul>
<h3 id="12-Autowired"><a href="#12-Autowired" class="headerlink" title="12. @Autowired"></a>12. <code>@Autowired</code></h3><h4 id="代码作用-11"><a href="#代码作用-11" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于自动装配 Spring 容器中的 Bean，根据类型进行依赖注入。</p>
</blockquote>
<h4 id="代码用例-11"><a href="#代码用例-11" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 UserService 接口中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-11"><a href="#代码分析-11" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Autowired</code> 注解标注在 <code>userRepository</code> 字段上，Spring 会自动从容器中查找类型为 <code>UserRepository</code> 的 Bean 并注入到该字段。</li>
</ul>
<h3 id="13-Component"><a href="#13-Component" class="headerlink" title="13. @Component"></a>13. <code>@Component</code></h3><h4 id="代码作用-12"><a href="#代码作用-12" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>是 Spring 框架中的通用注解，用于标注一个类作为 Spring Bean，让 Spring 容器自动扫描并管理该类。</p>
</blockquote>
<h4 id="代码用例-12"><a href="#代码用例-12" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 UserService 接口中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-12"><a href="#代码分析-12" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Component</code> 注解标注在 <code>UserServiceImpl</code> 类上，表明该类是一个 Spring Bean，会被 Spring 容器扫描并注册。</li>
</ul>
<h3 id="14-Service"><a href="#14-Service" class="headerlink" title="14. @Service"></a>14. <code>@Service</code></h3><h4 id="代码作用-13"><a href="#代码作用-13" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于标注一个类作为服务类（Service），是 <code>@Component</code> 的一种特殊形式，用于表示业务逻辑层的组件。</p>
</blockquote>
<h4 id="代码用例-13"><a href="#代码用例-13" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 UserService 接口中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-13"><a href="#代码分析-13" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Service</code> 注解标注在 <code>UserServiceImpl</code> 类上，表明该类是一个服务类，负责处理业务逻辑，会被 Spring 容器扫描并注册。</li>
</ul>
<h3 id="15-Repository"><a href="#15-Repository" class="headerlink" title="15. @Repository"></a>15. <code>@Repository</code></h3><h4 id="代码作用-14"><a href="#代码作用-14" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于标注一个类作为数据访问对象（DAO），是 <code>@Component</code> 的一种特殊形式，用于表示数据访问层的组件。</p>
</blockquote>
<h4 id="代码用例-14"><a href="#代码用例-14" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title class_">UserRepository</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 UserRepository 接口中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-14"><a href="#代码分析-14" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Repository</code> 注解标注在 <code>UserRepositoryImpl</code> 类上，表明该类是一个数据访问对象，负责与数据库交互，会被 Spring 容器扫描并注册。</li>
</ul>
<h3 id="16-Configuration"><a href="#16-Configuration" class="headerlink" title="16. @Configuration"></a>16. <code>@Configuration</code></h3><h4 id="代码作用-15"><a href="#代码作用-15" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于标注一个类作为配置类，该类中可以定义一个或多个 <code>@Bean</code> 方法，用于创建和配置 Spring 应用程序上下文中的 Bean。</p>
</blockquote>
<h4 id="代码用例-15"><a href="#代码用例-15" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserRepository <span class="title function_">userRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserRepositoryImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-15"><a href="#代码分析-15" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Configuration</code> 注解标注在 <code>AppConfig</code> 类上，表明该类是一个配置类。</li>
<li><code>@Bean</code> 注解的 <code>userService</code> 和 <code>userRepository</code> 方法分别返回 <code>UserService</code> 和 <code>UserRepository</code> 的实例，这些实例会被注册到 Spring 容器中。</li>
</ul>
<h3 id="17-Value"><a href="#17-Value" class="headerlink" title="17. @Value"></a>17. <code>@Value</code></h3><h4 id="代码作用-16"><a href="#代码作用-16" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于将配置文件中的属性值注入到 Bean 对象中，支持从配置文件中读取属性值并赋值给类的字段。</p>
</blockquote>
<h4 id="代码用例-16"><a href="#代码用例-16" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;my.property&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String myProperty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-16"><a href="#代码分析-16" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Component</code> 注解标注在 <code>MyComponent</code> 类上，表明该类是一个 Spring Bean。</li>
<li><code>@Value(&quot;$&#123;my.property&#125;&quot;)</code> 注解将配置文件中名为 <code>my.property</code> 的属性值注入到 <code>myProperty</code> 字段。</li>
</ul>
<h3 id="18-Bean"><a href="#18-Bean" class="headerlink" title="18. @Bean"></a>18. <code>@Bean</code></h3><h4 id="代码作用-17"><a href="#代码作用-17" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于将一个方法返回的对象注册到 Spring 容器中，通常在配置类中使用，方法的返回值会被作为一个 Bean 注册到容器中。</p>
</blockquote>
<h4 id="代码用例-17"><a href="#代码用例-17" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserRepository <span class="title function_">userRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserRepositoryImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-17"><a href="#代码分析-17" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Configuration</code> 注解标注在 <code>AppConfig</code> 类上，表明该类是一个配置类。</li>
<li><code>@Bean</code> 注解的 <code>userService</code> 和 <code>userRepository</code> 方法分别返回 <code>UserService</code> 和 <code>UserRepository</code> 的实例，这些实例会被注册到 Spring 容器中。</li>
</ul>
<h3 id="19-Import"><a href="#19-Import" class="headerlink" title="19. @Import"></a>19. <code>@Import</code></h3><h4 id="代码作用-18"><a href="#代码作用-18" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于导入其他配置类或 Bean，将其他配置类的 Bean 定义合并到当前配置类中。</p>
</blockquote>
<h4 id="代码用例-18"><a href="#代码用例-18" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;AppConfig1.class, AppConfig2.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-18"><a href="#代码分析-18" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Configuration</code> 注解标注在 <code>AppConfig</code> 类上，表明该类是一个配置类。</li>
<li><code>@Import</code> 注解导入 <code>AppConfig1</code> 和 <code>AppConfig2</code> 两个配置类，将它们的 Bean 定义合并到 <code>AppConfig</code> 中。</li>
</ul>
<h3 id="20-Conditional"><a href="#20-Conditional" class="headerlink" title="20. @Conditional"></a>20. <code>@Conditional</code></h3><h4 id="代码作用-19"><a href="#代码作用-19" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于根据条件判断是否创建 Bean 或执行配置，只有当条件满足时，被注解的 Bean 才会被创建。</p>
</blockquote>
<h4 id="代码用例-19"><a href="#代码用例-19" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional(DatabaseTypeCondition.class)</span></span><br><span class="line">    <span class="keyword">public</span> UserRepository <span class="title function_">userRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserRepositoryImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-19"><a href="#代码分析-19" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Configuration</code> 注解标注在 <code>AppConfig</code> 类上，表明该类是一个配置类。</li>
<li><code>@Conditional(DatabaseTypeCondition.class)</code> 注解表示只有当 <code>DatabaseTypeCondition</code> 条件满足时，<code>userRepository</code> Bean 才会被创建。</li>
</ul>
<h3 id="21-Profile"><a href="#21-Profile" class="headerlink" title="21. @Profile"></a>21. <code>@Profile</code></h3><h4 id="代码作用-20"><a href="#代码作用-20" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于指定配置的环境，如开发环境、测试环境或生产环境，根据不同的环境激活不同的 Bean。</p>
</blockquote>
<h4 id="代码用例-20"><a href="#代码用例-20" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userServiceDev</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceDevImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userServiceProd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceProdImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-20"><a href="#代码分析-20" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Configuration</code> 注解标注在 <code>AppConfig</code> 类上，表明该类是一个配置类。</li>
<li><code>@Profile(&quot;dev&quot;)</code> 注解表示 <code>userServiceDev</code> Bean 只在开发环境下激活，<code>@Profile(&quot;prod&quot;)</code> 注解表示 <code>userServiceProd</code> Bean 只在生产环境下激活。</li>
</ul>
<h3 id="22-PropertySource"><a href="#22-PropertySource" class="headerlink" title="22. @PropertySource"></a>22. <code>@PropertySource</code></h3><h4 id="代码作用-21"><a href="#代码作用-21" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于指定配置文件的位置，让 Spring 应用程序可以使用这些配置文件中的属性。</p>
</blockquote>
<h4 id="代码用例-21"><a href="#代码用例-21" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>(environment.getProperty(<span class="string">&quot;userService.name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-21"><a href="#代码分析-21" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Configuration</code> 注解标注在 <code>AppConfig</code> 类上，表明该类是一个配置类。</li>
<li><code>@PropertySource(&quot;classpath:application.properties&quot;)</code> 注解指定了配置文件 <code>application.properties</code> 的位置。</li>
<li>通过 <code>Environment</code> 对象可以读取配置文件中的属性值，并传递给 <code>UserService</code> 实例的构造方法。</li>
</ul>
<h3 id="23-Qualifier"><a href="#23-Qualifier" class="headerlink" title="23. @Qualifier"></a>23. <code>@Qualifier</code></h3><h4 id="代码作用-22"><a href="#代码作用-22" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于指定注入的 Bean 的名称，当存在多个相同类型的 Bean 时，通过名称来区分并注入指定的 Bean。</p>
</blockquote>
<h4 id="代码用例-22"><a href="#代码用例-22" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userRepositoryImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-22"><a href="#代码分析-22" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Component</code> 注解标注在 <code>UserServiceImpl</code> 类上，表明该类是一个 Spring Bean。</li>
<li><code>@Autowired</code> 注解用于自动装配 <code>UserRepository</code> 类型的 Bean，<code>@Qualifier(&quot;userRepositoryImpl&quot;)</code> 注解指定要注入的 Bean 名称为 <code>userRepositoryImpl</code>。</li>
</ul>
<h3 id="24-ExceptionHandler"><a href="#24-ExceptionHandler" class="headerlink" title="24. @ExceptionHandler"></a>24. <code>@ExceptionHandler</code></h3><h4 id="代码作用-23"><a href="#代码作用-23" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于处理异常，在控制器中指定一个方法来处理特定类型的异常。</p>
</blockquote>
<h4 id="代码用例-23"><a href="#代码用例-23" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;errorMessage&quot;</span>, ex.getMessage());</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-23"><a href="#代码分析-23" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@ControllerAdvice</code> 注解标注在 <code>GlobalExceptionHandler</code> 类上，表明该类是一个全局异常处理器。</li>
<li><code>@ExceptionHandler(Exception.class)</code> 注解指定 <code>handleException</code> 方法处理所有类型的异常，将异常信息封装到 <code>ModelAndView</code> 对象中并返回。</li>
</ul>
<h3 id="25-ResponseStatus"><a href="#25-ResponseStatus" class="headerlink" title="25. @ResponseStatus"></a>25. <code>@ResponseStatus</code></h3><h4 id="代码作用-24"><a href="#代码作用-24" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于指定异常的HTTP响应状态码。</p>
</blockquote>
<h4 id="代码用例-24"><a href="#代码用例-24" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;  </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span>  </span><br><span class="line">    <span class="meta">@ResponseBody</span>  </span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span>  </span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">getUserDetails</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;  </span><br><span class="line">        <span class="comment">// 查询用户信息  </span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> userService.getUserDetails(id);  </span><br><span class="line">        <span class="keyword">if</span> (userDetails == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserNotFoundException</span>(<span class="string">&quot;User not found&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> userDetails;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(UserNotFoundException.class)</span>  </span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span>  </span><br><span class="line">    <span class="meta">@ResponseBody</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleUserNotFoundException</span><span class="params">(UserNotFoundException ex)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> ex.getMessage();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-24"><a href="#代码分析-24" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@ResponseStatus(HttpStatus.OK)</code> 注解标注在 <code>getUserDetails</code> 方法上，指定该方法正常返回时的HTTP响应状态码为 <code>OK</code>。</li>
<li><code>@ResponseStatus(HttpStatus.NOT_FOUND)</code> 注解标注在 <code>handleUserNotFoundException</code> 方法上，指定当处理 <code>UserNotFoundException</code> 异常时的HTTP响应状态码为 <code>NOT_FOUND</code>。</li>
</ul>
<h3 id="26-ControllerAdvice"><a href="#26-ControllerAdvice" class="headerlink" title="26. @ControllerAdvice"></a>26. <code>@ControllerAdvice</code></h3><h4 id="代码作用-25"><a href="#代码作用-25" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于全局处理异常。<code>@ControllerAdvice</code>是Spring框架中的一个注解，用于定义全局控制器通知。在Spring MVC框架中，控制器通知是一些特殊的组件，它们可以在控制器方法执行前、执行后或抛出异常时执行一些额外的逻辑处理。使用<code>@ControllerAdvice</code>注解可以定义全局控制器通知，它可以应用于所有的控制器。</p>
</blockquote>
<h4 id="代码用例-25"><a href="#代码用例-25" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalControllerAdvice</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute(&quot;currentUser&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getCurrentUser</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 获取当前登录用户信息  </span></span><br><span class="line">        <span class="type">User</span> <span class="variable">currentUser</span> <span class="operator">=</span> userService.getCurrentUser();  </span><br><span class="line">        <span class="keyword">return</span> currentUser;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(WebDataBinder binder)</span> &#123;  </span><br><span class="line">        <span class="comment">// 注册自定义的属性编辑器  </span></span><br><span class="line">        binder.registerCustomEditor(Date.class, <span class="keyword">new</span> <span class="title class_">CustomDateEditor</span>(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>), <span class="literal">true</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span>  </span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleException</span><span class="params">(Exception ex)</span> &#123;  </span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();  </span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;errorMessage&quot;</span>, ex.getMessage());  </span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;error&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> modelAndView;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-25"><a href="#代码分析-25" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@ControllerAdvice</code> 注解标注在 <code>GlobalControllerAdvice</code> 类上，表明该类是一个全局控制器通知。</li>
<li><code>@ModelAttribute(&quot;currentUser&quot;)</code> 注解标注的 <code>getCurrentUser</code> 方法会在所有控制器方法执行前执行，用于将当前登录用户信息添加到模型中。</li>
<li><code>@InitBinder</code> 注解标注的 <code>initBinder</code> 方法会在所有控制器方法执行前执行，用于注册自定义的属性编辑器。</li>
<li><code>@ExceptionHandler(Exception.class)</code> 注解指定 <code>handleException</code> 方法处理所有类型的异常，将异常信息封装到 <code>ModelAndView</code> 对象中并返回。</li>
</ul>
<h3 id="27-CrossOrigin"><a href="#27-CrossOrigin" class="headerlink" title="27. @CrossOrigin"></a>27. <code>@CrossOrigin</code></h3><h4 id="代码作用-26"><a href="#代码作用-26" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于解决跨域问题。<code>@CrossOrigin</code>是Spring框架中的一个注解，用于解决跨域资源共享（CORS）问题。跨域资源共享是浏览器安全策略的一部分，它限制了浏览器在不同域名之间发送和接收HTTP请求。使用<code>@CrossOrigin</code>注解可以指定允许跨域访问的域名和HTTP方法。</p>
</blockquote>
<h4 id="代码用例-26"><a href="#代码用例-26" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span>  </span><br><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://localhost:8080&quot;, methods = &#123;RequestMethod.GET, RequestMethod.POST&#125;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiController</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 查询用户信息  </span></span><br><span class="line">        List&lt;User&gt; users = userService.getUsers();  </span><br><span class="line">        <span class="keyword">return</span> users;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-26"><a href="#代码分析-26" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@RestController</code> 注解标注在 <code>ApiController</code> 类上，表明该类是一个RESTful风格的控制器。</li>
<li><code>@RequestMapping(&quot;/api&quot;)</code> 注解在类级别，指定该控制器处理的请求路径以 <code>/api</code> 开头。</li>
<li><code>@CrossOrigin(origins = &quot;http://localhost:8080&quot;, methods = &#123;RequestMethod.GET, RequestMethod.POST&#125;)</code> 注解指定允许来自 <code>http://localhost:8080</code> 域名的 <code>GET</code> 和 <code>POST</code> 请求访问该控制器中的方法。</li>
</ul>
<h3 id="28-Async"><a href="#28-Async" class="headerlink" title="28. @Async"></a>28. <code>@Async</code></h3><h4 id="代码作用-27"><a href="#代码作用-27" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于将方法标记为异步执行。在Spring框架中，如果一个方法需要执行一些比较耗时的操作，如果这个方法是在主线程中执行，就会导致主线程被阻塞，用户界面无法响应用户的操作。使用<code>@Async</code>注解可以将这个方法的执行异步化，让主线程继续执行其他任务，提高应用程序的响应性能。</p>
</blockquote>
<h4 id="代码用例-27"><a href="#代码用例-27" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>  </span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;UserDetails&gt; <span class="title function_">getUserDetailsAsync</span><span class="params">(Long id)</span> &#123;  </span><br><span class="line">        <span class="comment">// 查询用户信息  </span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> userRepository.getUserDetails(id);  </span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(userDetails);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-27"><a href="#代码分析-27" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Service</code> 注解标注在 <code>UserService</code> 类上，表明该类是一个服务。</li>
<li><code>@Async</code> 注解标注在 <code>getUserDetailsAsync</code> 方法上，表示这个方法需要异步执行，查询用户信息的操作在异步线程中执行，不会阻塞主线程，且该方法返回一个 <code>CompletableFuture</code> 对象，表示异步执行的结果。</li>
</ul>
<h3 id="29-Cacheable"><a href="#29-Cacheable" class="headerlink" title="29. @Cacheable"></a>29. <code>@Cacheable</code></h3><h4 id="代码作用-28"><a href="#代码作用-28" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于缓存方法的返回值。在Spring框架中，如果一个方法的返回结果是固定的，而且这个方法的执行比较耗时，我们可以使用<code>@Cacheable</code>注解将这个方法的返回结果缓存起来，下次执行这个方法时直接从缓存中获取结果，避免重复执行。</p>
</blockquote>
<h4 id="代码用例-28"><a href="#代码用例-28" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(&quot;userCache&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;  </span><br><span class="line">        <span class="comment">// 查询用户信息  </span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.getUser(id);  </span><br><span class="line">        <span class="keyword">return</span> user;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-28"><a href="#代码分析-28" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Service</code> 注解标注在 <code>UserService</code> 类上，表明该类是一个服务。</li>
<li><code>@Cacheable(&quot;userCache&quot;)</code> 注解标注在 <code>getUser</code> 方法上，表示这个方法的返回结果可以被缓存到名为 <code>userCache</code> 的缓存中。首次执行时查询用户信息并缓存结果，下次执行若缓存存在则直接获取，无需再次查询。</li>
</ul>
<h3 id="30-CacheEvict"><a href="#30-CacheEvict" class="headerlink" title="30. @CacheEvict"></a>30. <code>@CacheEvict</code></h3><h4 id="代码作用-29"><a href="#代码作用-29" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于清除缓存。<code>@CacheEvict</code>是Spring框架中的一个注解，用于清空缓存中的数据。在Spring框架中，如果一个方法的执行会导致缓存数据的失效，我们可以使用<code>@CacheEvict</code>注解将这个方法的缓存数据清空，这样下次执行这个方法时就会重新查询数据并缓存起来。</p>
</blockquote>
<h4 id="代码用例-29"><a href="#代码用例-29" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(&quot;userCache&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;  </span><br><span class="line">        <span class="comment">// 查询用户信息  </span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.getUser(id);  </span><br><span class="line">        <span class="keyword">return</span> user;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheEvict(&quot;userCache&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearCache</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 清空缓存  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-29"><a href="#代码分析-29" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Service</code> 注解标注在 <code>UserService</code> 类上，表明该类是一个服务。</li>
<li><code>@Cacheable(&quot;userCache&quot;)</code> 注解标注的 <code>getUser</code> 方法，其返回结果会被缓存。</li>
<li><code>@CacheEvict(&quot;userCache&quot;)</code> 注解标注的 <code>clearCache</code> 方法，会清空名为 <code>userCache</code> 的缓存，使得下次执行 <code>getUser</code> 方法时需重新查询并缓存数据。</li>
</ul>
<h3 id="31-CachePut"><a href="#31-CachePut" class="headerlink" title="31. @CachePut"></a>31. <code>@CachePut</code></h3><h4 id="代码作用-30"><a href="#代码作用-30" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于更新缓存中的数据。<code>@CachePut</code>是Spring框架中的一个注解，用于更新或添加缓存中的数据。在Spring框架中，如果一个方法的执行会导致缓存数据的更新或添加，我们可以使用<code>@CachePut</code>注解将这个方法的返回结果更新或添加到缓存中。</p>
</blockquote>
<h4 id="代码用例-30"><a href="#代码用例-30" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(&quot;userCache&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;  </span><br><span class="line">        <span class="comment">// 查询用户信息  </span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.getUser(id);  </span><br><span class="line">        <span class="keyword">return</span> user;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(&quot;userCache&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateUser</span><span class="params">(Long id, User user)</span> &#123;  </span><br><span class="line">        <span class="comment">// 更新用户信息  </span></span><br><span class="line">        <span class="type">User</span> <span class="variable">updatedUser</span> <span class="operator">=</span> userRepository.updateUser(id, user);  </span><br><span class="line">        <span class="keyword">return</span> updatedUser;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-30"><a href="#代码分析-30" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Service</code> 注解标注在 <code>UserService</code> 类上，表明该类是一个服务。</li>
<li><code>@Cacheable(&quot;userCache&quot;)</code> 注解标注的 <code>getUser</code> 方法，其返回结果会被缓存。</li>
<li><code>@CachePut(&quot;userCache&quot;)</code> 注解标注的 <code>updateUser</code> 方法，在更新用户信息后，会将返回的更新后的用户信息更新或添加到名为 <code>userCache</code> 的缓存中，以便下次 <code>getUser</code> 方法可获取最新缓存数据。</li>
</ul>
<h3 id="32-Transactional"><a href="#32-Transactional" class="headerlink" title="32. @Transactional"></a>32. <code>@Transactional</code></h3><h4 id="代码作用-31"><a href="#代码作用-31" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于启用事务管理功能。<code>@Transactional</code>是Spring框架中的一个注解，用于标识一个方法或类需要使用事务进行操作。在Spring框架中，如果一个方法需要对数据库进行操作，我们可以使用<code>@Transactional</code>注解来确保这个操作在一个事务中进行，从而保证操作的原子性、一致性、隔离性和持久性。</p>
</blockquote>
<h4 id="代码用例-31"><a href="#代码用例-31" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="meta">@Transactional</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;  </span><br><span class="line">        userRepository.save(user);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(Long id, User user)</span> &#123;  </span><br><span class="line">        <span class="type">User</span> <span class="variable">existingUser</span> <span class="operator">=</span> userRepository.findById(id);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (existingUser != <span class="literal">null</span>) &#123;  </span><br><span class="line">            existingUser.setName(user.getName());  </span><br><span class="line">            existingUser.setEmail(user.getEmail());  </span><br><span class="line">            userRepository.save(existingUser);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-31"><a href="#代码分析-31" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Service</code> 注解标注在 <code>UserService</code> 类上，表明该类是一个服务。</li>
<li><code>@Transactional</code> 注解标注在类上，表示该类中的 <code>createUser</code> 和 <code>updateUser</code> 方法都需要使用事务进行操作，<code>userRepository</code> 的操作都在一个事务中进行，以保证操作的原子性、一致性、隔离性和持久性。</li>
</ul>
<h3 id="34-EnableAspectJAutoProxy"><a href="#34-EnableAspectJAutoProxy" class="headerlink" title="34. @EnableAspectJAutoProxy"></a>34. <code>@EnableAspectJAutoProxy</code></h3><h4 id="代码作用-32"><a href="#代码作用-32" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于启用AOP功能。<code>@EnableAspectJAutoProxy</code>是Spring框架中的一个注解，用于启用自动代理功能，以便使用AOP（面向切面编程）进行编程。在Spring框架中，如果需要使用AOP来实现某些功能，我们可以使用<code>@EnableAspectJAutoProxy</code>注解来启用自动代理功能，从而在运行时自动为我们生成代理对象，以便进行切面编程。</p>
</blockquote>
<h4 id="代码用例-32"><a href="#代码用例-32" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> MyAspect <span class="title function_">myAspect</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyAspect</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-32"><a href="#代码分析-32" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Configuration</code> 注解标注在 <code>AppConfig</code> 类上，表明该类是一个配置类。</li>
<li><code>@EnableAspectJAutoProxy</code> 注解标注在类上，表示这个配置类需要启用自动代理功能。</li>
<li><code>@Bean</code> 注解标注的 <code>myAspect</code> 方法返回一个 <code>MyAspect</code> 实例，<code>myAspect</code> 类用于实现切面编程功能，<code>@Bean</code> 注解标注的 <code>userService</code> 方法返回一个 <code>UserService</code> 实例，用于实现业务功能。</li>
</ul>
<h3 id="35-Aspect"><a href="#35-Aspect" class="headerlink" title="35. @Aspect"></a>35. <code>@Aspect</code></h3><h4 id="代码作用-33"><a href="#代码作用-33" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于定义切面。<code>@Aspect</code>是Spring框架中的一个注解，用于标识一个类为切面类，从而可以在该类中定义切面逻辑以实现AOP（面向切面编程）。在Spring框架中，如果需要使用AOP来实现某些功能，我们可以使用<code>@Aspect</code>注解来标识一个类为切面类。在切面类中，我们可以定义切面逻辑，包括切入点、通知类型和切面顺序等，从而实现AOP编程的功能。</p>
</blockquote>
<h4 id="代码用例-33"><a href="#代码用例-33" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.UserService.*(..))&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeAdvice</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Before advice is executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.example.UserService.*(..))&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterAdvice</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;After advice is executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-33"><a href="#代码分析-33" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Aspect</code> 注解标注在 <code>MyAspect</code> 类上，表明该类是一个切面类，<code>@Component</code> 注解用于将该类纳入Spring容器管理。</li>
<li><code>@Before(&quot;execution(* com.example.UserService.*(..))&quot;)</code> 注解标注的 <code>beforeAdvice</code> 方法，定义了在 <code>com.example.UserService</code> 类中所有方法执行前执行的通知逻辑。</li>
<li><code>@After(&quot;execution(* com.example.UserService.*(..))&quot;)</code> 注解标注的 <code>afterAdvice</code> 方法，定义了在 <code>com.example.UserService</code> 类中所有方法执行后执行的通知逻辑。</li>
</ul>
<h3 id="36-Pointcut"><a href="#36-Pointcut" class="headerlink" title="36. @Pointcut"></a>36. <code>@Pointcut</code></h3><h4 id="代码作用-34"><a href="#代码作用-34" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于定义切点。<code>@Pointcut</code>是Spring框架中的一个注解，用于定义一个切入点，从而可以在该切入点上定义通知类型以实现AOP（面向切面编程）。在Spring框架中，如果需要使用AOP来实现某些功能，我们可以使用<code>@Pointcut</code>注解来定义一个切入点。在切入点上，我们可以定义切面逻辑，包括通知类型和切面顺序等，从而实现AOP编程的功能。</p>
</blockquote>
<h4 id="代码用例-34"><a href="#代码用例-34" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.UserService.*(..))&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userServicePointcut</span><span class="params">()</span> &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;userServicePointcut()&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeAdvice</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Before advice is executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;userServicePointcut()&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterAdvice</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;After advice is executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-34"><a href="#代码分析-34" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Aspect</code> 注解标注在 <code>MyAspect</code> 类上，表明该类是一个切面类，<code>@Component</code> 注解用于将该类纳入Spring容器管理。</li>
<li><code>@Pointcut(&quot;execution(* com.example.UserService.*(..))&quot;)</code> 注解标注的 <code>userServicePointcut</code> 方法定义了一个切入点，<code>@Before(&quot;userServicePointcut()&quot;)</code> 注解标注的 <code>beforeAdvice</code> 方法和 <code>@After(&quot;userServicePointcut()&quot;)</code> 注解标注的 <code>afterAdvice</code> 方法分别定义了在该切入点对应的目标方法执行前和执行后的通知逻辑。</li>
</ul>
<h3 id="37-Before"><a href="#37-Before" class="headerlink" title="37. @Before"></a>37. <code>@Before</code></h3><h4 id="代码作用-35"><a href="#代码作用-35" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于在方法执行前执行通知。<code>@Before</code>是Spring框架中的一个注解，用于定义在目标方法执行前执行的通知类型，以实现AOP（面向切面编程）。在Spring框架中，如果需要在目标方法执行前执行某些操作，我们可以使用<code>@Before</code>注解来定义一个通知类型。在这个通知类型中，我们可以编写自己的逻辑代码，从而实现AOP编程的功能。</p>
</blockquote>
<h4 id="代码用例-35"><a href="#代码用例-35" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.UserService.*(..))&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeAdvice</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Before advice is executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-35"><a href="#代码分析-35" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Aspect</code> 注解标注在 <code>MyAspect</code> 类上，表明该类是一个切面类，<code>@Component</code> 注解用于将该类纳入Spring容器管理。</li>
<li><code>@Before(&quot;execution(* com.example.UserService.*(..))&quot;)</code> 注解标注的 <code>beforeAdvice</code> 方法，定义了在 <code>com.example.UserService</code> 类中所有方法执行前执行的通知逻辑，即打印 <code>Before advice is executed.</code>。</li>
</ul>
<h3 id="38-After"><a href="#38-After" class="headerlink" title="38. @After"></a>38. <code>@After</code></h3><h4 id="代码作用-36"><a href="#代码作用-36" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于在方法执行后执行通知。<code>@After</code>是Spring框架中的一个注解，用于定义在目标方法执行后执行的通知类型，以实现AOP（面向切面编程）。在Spring框架中，如果需要在目标方法执行后执行某些操作，我们可以使用<code>@After</code>注解来定义一个通知类型。在这个通知类型中，我们可以编写自己的逻辑代码，从而实现AOP编程的功能。</p>
</blockquote>
<h4 id="代码用例-36"><a href="#代码用例-36" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.example.UserService.*(..))&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterAdvice</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;After advice is executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-36"><a href="#代码分析-36" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Aspect</code>注解标注在<code>MyAspect</code>类上，表明该类是一个切面类。</li>
<li><code>@Component</code>注解用于将<code>MyAspect</code>类纳入Spring容器管理。</li>
<li><code>@After(&quot;execution(* com.example.UserService.*(..))&quot;)</code>注解标注的<code>afterAdvice</code>方法，定义了在<code>com.example.UserService</code>类中所有方法执行后执行的通知逻辑，即打印<code>After advice is executed.</code>。</li>
</ul>
<h3 id="39-Around"><a href="#39-Around" class="headerlink" title="39. @Around"></a>39. <code>@Around</code></h3><h4 id="代码作用-37"><a href="#代码作用-37" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于在方法执行前后执行通知。<code>@Around</code>是Spring框架中的一个注解，用于定义在目标方法执行前后执行的通知类型，以实现AOP（面向切面编程）。在Spring框架中，如果需要在目标方法执行前后执行某些操作，我们可以使用<code>@Around</code>注解来定义一个通知类型。在这个通知类型中，我们可以编写自己的逻辑代码，从而实现AOP编程的功能。</p>
</blockquote>
<h4 id="代码用例-37"><a href="#代码用例-37" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.UserService.*(..))&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Before advice is executed.&quot;</span>);  </span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();  </span><br><span class="line">        System.out.println(<span class="string">&quot;After advice is executed.&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-37"><a href="#代码分析-37" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Aspect</code>注解标注在<code>MyAspect</code>类上，表明该类是一个切面类。</li>
<li><code>@Component</code>注解用于将<code>MyAspect</code>类纳入Spring容器管理。</li>
<li><code>@Around(&quot;execution(* com.example.UserService.*(..))&quot;)</code>注解标注的<code>aroundAdvice</code>方法，定义了在<code>com.example.UserService</code>类中所有方法执行前后的通知逻辑。在方法执行前打印<code>Before advice is executed.</code>，通过<code>joinPoint.proceed()</code>执行目标方法，在方法执行后打印<code>After advice is executed.</code>，并返回目标方法的执行结果。</li>
</ul>
<h3 id="40-AfterReturning"><a href="#40-AfterReturning" class="headerlink" title="40. @AfterReturning"></a>40. <code>@AfterReturning</code></h3><h4 id="代码作用-38"><a href="#代码作用-38" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于在方法返回结果后执行通知。<code>@AfterReturning</code>是Spring框架中的一个注解，用于定义在目标方法返回结果后执行的通知类型，以实现AOP（面向切面编程）。在Spring框架中，如果需要在目标方法返回结果后执行某些操作，我们可以使用<code>@AfterReturning</code>注解来定义一个通知类型。在这个通知类型中，我们可以编写自己的逻辑代码，从而实现AOP编程的功能。</p>
</blockquote>
<h4 id="代码用例-38"><a href="#代码用例-38" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;execution(* com.example.UserService.*(..))&quot;, returning = &quot;result&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturningAdvice</span><span class="params">(Object result)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;After returning advice is executed. Result is &quot;</span> + result);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-38"><a href="#代码分析-38" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Aspect</code>注解标注在<code>MyAspect</code>类上，表明该类是一个切面类。</li>
<li><code>@Component</code>注解用于将<code>MyAspect</code>类纳入Spring容器管理。</li>
<li><code>@AfterReturning(pointcut = &quot;execution(* com.example.UserService.*(..))&quot;, returning = &quot;result&quot;)</code>注解标注的<code>afterReturningAdvice</code>方法，定义了在<code>com.example.UserService</code>类中所有方法返回结果后执行的通知逻辑。当目标方法返回结果时，将结果传递给<code>afterReturningAdvice</code>方法，并打印<code>After returning advice is executed. Result is </code>以及结果内容。</li>
</ul>
<h3 id="41-AfterThrowing"><a href="#41-AfterThrowing" class="headerlink" title="41. @AfterThrowing"></a>41. <code>@AfterThrowing</code></h3><h4 id="代码作用-39"><a href="#代码作用-39" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于在方法抛出异常后执行通知。<code>@AfterThrowing</code>是Spring框架中的一个注解，用于定义在目标方法抛出异常后执行的通知类型，以实现AOP（面向切面编程）。在Spring框架中，如果需要在目标方法抛出异常后执行某些操作，我们可以使用<code>@AfterThrowing</code>注解来定义一个通知类型。在这个通知类型中，我们可以编写自己的逻辑代码，从而实现AOP编程的功能。</p>
</blockquote>
<h4 id="代码用例-39"><a href="#代码用例-39" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(pointcut = &quot;execution(* com.example.UserService.*(..))&quot;, throwing = &quot;ex&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowingAdvice</span><span class="params">(Exception ex)</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;After throwing advice is executed. Exception is &quot;</span> + ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-39"><a href="#代码分析-39" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Aspect</code>注解标注在<code>MyAspect</code>类上，表明该类是一个切面类。</li>
<li><code>@Component</code>注解用于将<code>MyAspect</code>类纳入Spring容器管理。</li>
<li><code>@AfterThrowing(pointcut = &quot;execution(* com.example.UserService.*(..))&quot;, throwing = &quot;ex&quot;)</code>注解标注的<code>afterThrowingAdvice</code>方法，定义了在<code>com.example.UserService</code>类中所有方法抛出异常后执行的通知逻辑。当目标方法抛出异常时，将异常对象传递给<code>afterThrowingAdvice</code>方法，并打印<code>After throwing advice is executed. Exception is </code>以及异常信息。</li>
</ul>
<h3 id="42-Order"><a href="#42-Order" class="headerlink" title="42. @Order"></a>42. <code>@Order</code></h3><h4 id="代码作用-40"><a href="#代码作用-40" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于指定切面的执行顺序。<code>@Order</code>是Spring框架中的一个注解，用于定义切面的执行顺序。在Spring框架中，如果有多个切面类需要对同一个方法进行切面处理，那么这些切面类的执行顺序可能会影响到最终的结果。为了控制这些切面类的执行顺序，我们可以使用<code>@Order</code>注解来定义它们的执行顺序。<code>@Order</code>注解可以应用在切面类上，用于指定切面执行的顺序。它的参数为一个整数，数值越小表示优先级越高，数值相同时按照类名的自然顺序进行排序。</p>
</blockquote>
<h4 id="代码用例-40"><a href="#代码用例-40" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Order(1)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect1</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.UserService.*(..))&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeAdvice</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Before advice from MyAspect1 is executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Order(2)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect2</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.UserService.*(..))&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeAdvice</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Before advice from MyAspect2 is executed.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-40"><a href="#代码分析-40" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Aspect</code>和<code>@Component</code>注解分别标注在<code>MyAspect1</code>和<code>MyAspect2</code>类上，表明这两个类都是切面类且被纳入Spring容器管理。</li>
<li><code>@Order(1)</code>注解标注在<code>MyAspect1</code>类上，<code>@Order(2)</code>注解标注在<code>MyAspect2</code>类上，指定了<code>MyAspect1</code>的执行顺序优先于<code>MyAspect2</code>。</li>
<li>两个类中的<code>@Before(&quot;execution(* com.example.UserService.*(..))&quot;)</code>注解标注的<code>beforeAdvice</code>方法，定义了在<code>com.example.UserService</code>类中所有方法执行前的通知逻辑，分别打印各自的提示信息。</li>
</ul>
<h3 id="43-Slf4j"><a href="#43-Slf4j" class="headerlink" title="43. @Slf4j"></a>43. <code>@Slf4j</code></h3><h4 id="代码作用-41"><a href="#代码作用-41" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于简化日志记录。<code>@Slf4j</code>是Lombok框架中的一个注解，用于在Java类中自动生成日志记录器。在Java开发中，日志记录是非常重要的一环，可以帮助我们更好地了解程序的运行情况，从而更好地进行调试和优化。通常情况下，我们需要手动引入日志框架（如Log4j、SLF4J等）并编写相应的日志记录代码。这些代码可能会比较繁琐，而且容易出现错误。为了简化这个过程，Lombok框架提供了一个<code>@Slf4j</code>注解，可以在Java类中自动生成日志记录器。使用<code>@Slf4j</code>注解非常简单，只需要在Java类中添加这个注解即可。在使用时，我们可以直接使用log变量来记录日志，而不需要再引入其他的日志框架。</p>
</blockquote>
<h4 id="代码用例-41"><a href="#代码用例-41" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;  </span><br><span class="line">        log.debug(<span class="string">&quot;This is a debug message.&quot;</span>);  </span><br><span class="line">        log.info(<span class="string">&quot;This is an info message.&quot;</span>);  </span><br><span class="line">        log.error(<span class="string">&quot;This is an error message.&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-41"><a href="#代码分析-41" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Slf4j</code>注解标注在<code>MyService</code>类上，自动生成了日志记录器。</li>
<li>在<code>doSomething</code>方法中，通过<code>log</code>变量直接调用<code>debug</code>、<code>info</code>、<code>error</code>方法记录不同级别的日志信息，无需手动引入其他日志框架。需注意使用<code>@Slf4j</code>注解需要在编译器中安装Lombok插件，否则可能出现编译错误。</li>
</ul>
<h3 id="44-Data"><a href="#44-Data" class="headerlink" title="44. @Data"></a>44. <code>@Data</code></h3><h4 id="代码作用-42"><a href="#代码作用-42" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于自动生成JavaBean的getters、setters、toString、hashCode和equals方法。<code>@Data</code>是Lombok框架中的一个注解，可以自动生成Java类的getter、setter、equals、hashCode和toString等方法。在Java开发中，我们经常需要编写一些POJO类来表示数据结构。这些类通常包含一些成员变量，并且需要编写相应的getter、setter、equals、hashCode和toString等方法。这些方法通常是相似的，而且比较繁琐。为了简化这个过程，Lombok框架提供了一个<code>@Data</code>注解，可以自动生成这些方法。使用<code>@Data</code>注解非常简单，只需要在Java类上添加这个注解即可。在使用时，我们可以直接访问类的成员变量，并且可以自动生成相应的getter、setter、equals、hashCode和toString等方法。</p>
</blockquote>
<h4 id="代码用例-42"><a href="#代码用例-42" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Long id;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> Integer age;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-42"><a href="#代码分析-42" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Data</code>注解标注在<code>User</code>类上，Lombok会自动为该类的<code>id</code>、<code>name</code>、<code>age</code>成员变量生成对应的<code>getter</code>、<code>setter</code>方法，同时生成<code>equals</code>、<code>hashCode</code>和<code>toString</code>方法，简化了POJO类的编写。</li>
</ul>
<h3 id="45-NoArgsConstructor"><a href="#45-NoArgsConstructor" class="headerlink" title="45. @NoArgsConstructor"></a>45. <code>@NoArgsConstructor</code></h3><h4 id="代码作用-43"><a href="#代码作用-43" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于生成无参构造函数。<code>@NoArgsConstructor</code>是Lombok框架中的一个注解，用于自动生成一个无参构造方法。在Java开发中，我们经常需要编写一些POJO类来表示数据结构。这些类通常包含一些成员变量，并且需要编写相应的构造方法。在某些情况下，我们可能需要编写一个无参构造方法，用于创建一个对象的实例。这个构造方法通常是简单的、无需参数的。为了简化这个过程，Lombok框架提供了一个<code>@NoArgsConstructor</code>注解，可以自动生成一个无参构造方法。使用<code>@NoArgsConstructor</code>注解非常简单，只需要在Java类上添加这个注解即可。在使用时，我们可以直接创建对象的实例，而不需要手动编写无参构造方法。</p>
</blockquote>
<h4 id="代码用例-43"><a href="#代码用例-43" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Long id;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> Integer age;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-43"><a href="#代码分析-43" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@NoArgsConstructor</code>注解标注在<code>User</code>类上，Lombok自动为<code>User</code>类生成了一个无参构造方法。这样在其他类中可以直接创建<code>User</code>对象的实例，无需手动编写无参构造方法，但使用该注解需要在编译器中安装Lombok插件，否则可能出现编译错误。</li>
</ul>
<h3 id="46-AllArgsConstructor"><a href="#46-AllArgsConstructor" class="headerlink" title="46. @AllArgsConstructor"></a>46. <code>@AllArgsConstructor</code></h3><h4 id="代码作用-44"><a href="#代码作用-44" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于生成全参构造函数。<code>@AllArgsConstructor</code>是Lombok框架中的一个注解，用于自动生成一个全参构造方法。在Java开发中，我们经常需要编写一些POJO类来表示数据结构。这些类通常包含一些成员变量，并且需要编写相应的构造方法。在某些情况下，我们可能需要编写一个全参构造方法，用于初始化所有成员变量。这个构造方法通常包含所有成员变量作为参数。为了简化这个过程，Lombok框架提供了一个<code>@AllArgsConstructor</code>注解，可以自动生成一个全参构造方法。使用<code>@AllArgsConstructor</code>注解非常简单，只需要在Java类上添加这个注解即可。在使用时，我们可以直接创建对象的实例，并传入相应的参数，而不需要手动编写全参构造方法。</p>
</blockquote>
<h4 id="代码用例-44"><a href="#代码用例-44" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Long id;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> Integer age;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-44"><a href="#代码分析-44" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@AllArgsConstructor</code>注解标注在<code>User</code>类上，Lombok自动为<code>User</code>类生成了一个包含<code>id</code>、<code>name</code>、<code>age</code>三个参数的全参构造方法。在其他类中创建<code>User</code>对象实例时，可以直接传入对应参数，无需手动编写全参构造方法，但需安装Lombok插件，否则可能编译出错。</li>
</ul>
<h3 id="47-Builder"><a href="#47-Builder" class="headerlink" title="47. @Builder"></a>47. <code>@Builder</code></h3><h4 id="代码作用-45"><a href="#代码作用-45" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于生成Builder模式的构造函数。<code>@Builder</code>是Lombok框架中的一个注解，用于自动生成一个Builder模式的构造器。在Java开发中，我们经常需要编写一些POJO类来表示数据结构。这些类通常包含一些成员变量，并且需要编写相应的构造方法。在某些情况下，我们可能需要编写一个Builder模式的构造器，用于方便地创建对象实例。Builder模式是一种创建对象的设计模式，它可以通过链式调用的方式设置对象的属性，并最终创建一个不可变的对象。为了简化这个过程，Lombok框架提供了一个<code>@Builder</code>注解，可以自动生成一个Builder模式的构造器。使用<code>@Builder</code>注解非常简单，只需要在Java类上添加这个注解即可。在使用时，我们可以使用链式调用的方式设置对象的属性，并最终创建一个不可变的对象。</p>
</blockquote>
<h4 id="代码用例-45"><a href="#代码用例-45" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Builder</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Long id;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> Integer age;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-45"><a href="#代码分析-45" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Builder</code>注解标注在<code>User</code>类上，Lombok自动为<code>User</code>类生成了Builder模式的构造器。这样在其他类中创建<code>User</code>对象时，可以通过链式调用的方式设置<code>id</code>、<code>name</code>、<code>age</code>等属性，最终创建一个不可变的<code>User</code>对象，但使用该注解需安装Lombok插件，否则可能编译失败。</li>
</ul>
<h3 id="48-EqualsAndHashCode"><a href="#48-EqualsAndHashCode" class="headerlink" title="48. @EqualsAndHashCode"></a>48. <code>@EqualsAndHashCode</code></h3><h4 id="代码作用-46"><a href="#代码作用-46" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于生成hashCode和equals方法。<code>@EqualsAndHashCode</code>是Lombok框架中的一个注解，用于自动生成equals()和hashCode()方法。在Java开发中，我们经常需要比较两个对象是否相等，并且需要根据对象的属性生成一个hashCode值。为了简化这个过程，Lombok框架提供了一个<code>@EqualsAndHashCode</code>注解，可以自动生成equals()和hashCode()方法。使用<code>@EqualsAndHashCode</code>注解非常简单，只需要在Java类上添加这个注解即可。在使用时，Lombok会根据类的属性自动生成equals()和hashCode()方法。如果两个对象的所有属性都相等，那么它们的equals()方法返回true，并且它们的hashCode()方法返回相同的值。</p>
</blockquote>
<h4 id="代码用例-46"><a href="#代码用例-46" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EqualsAndHashCode</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Long id;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> Integer age;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-46"><a href="#代码分析-46" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@EqualsAndHashCode</code>注解标注在<code>User</code>类上，Lombok会根据<code>User</code>类的<code>id</code>、<code>name</code>、<code>age</code>成员变量自动生成<code>equals</code>和<code>hashCode</code>方法。当比较两个<code>User</code>对象时，会根据这些属性判断是否相等并生成相应的<code>hashCode</code>值。</li>
</ul>
<h3 id="49-ToString"><a href="#49-ToString" class="headerlink" title="49. @ToString"></a>49. <code>@ToString</code></h3><h4 id="代码作用-47"><a href="#代码作用-47" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于生成toString方法。<code>@ToString</code>是Lombok框架中的一个注解，用于自动生成toString()方法。在Java开发中，我们经常需要将对象转换为字符串，以便于输出或日志记录。为了简化这个过程，Lombok框架提供了一个<code>@ToString</code>注解，可以自动生成toString()方法。使用<code>@ToString</code>注解非常简单，只需要在Java类上添加这个注解即可。在使用时，Lombok会根据类的属性自动生成toString()方法，这个方法将输出类的名称和所有属性的名称和值。如果需要排除某些属性，可以使用exclude属性来指定排除的属性。</p>
</blockquote>
<h4 id="代码用例-47"><a href="#代码用例-47" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ToString(exclude = &quot;password&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Long id;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> String password;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="代码分析-47"><a href="#代码分析-47" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@ToString(exclude = &quot;password&quot;)</code>注解标注在<code>User</code>类上，Lombok会自动为<code>User</code>类生成<code>toString</code>方法。生成的<code>toString</code>方法会输出类名以及<code>id</code>、<code>name</code>属性的名称和值，由于使用了<code>exclude = &quot;password&quot;</code>，所以<code>password</code>属性不会在<code>toString</code>方法的输出中出现。</li>
</ul>
<h3 id="50-Getter"><a href="#50-Getter" class="headerlink" title="50. @Getter"></a>50. <code>@Getter</code></h3><h4 id="代码作用-48"><a href="#代码作用-48" class="headerlink" title="代码作用"></a>代码作用</h4><blockquote>
<p>用于生成getters方法。<code>@Getter</code>是Lombok框架中的一个注解，用于自动生成getter方法。在Java开发中，我们经常需要为类的属性编写getter和setter方法。为了简化这个过程，Lombok框架提供了一个<code>@Getter</code>注解，可以自动生成getter方法。使用<code>@Getter</code>注解非常简单，只需要在Java类上添加这个注解即可。在使用时，Lombok会根据类的属性自动生成对应的getter方法。如果需要生成setter方法，可以使用<code>@Setter</code>注解。</p>
</blockquote>
<h4 id="代码用例-48"><a href="#代码用例-48" class="headerlink" title="代码用例"></a>代码用例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Long id;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> Integer age;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码分析-48"><a href="#代码分析-48" class="headerlink" title="代码分析"></a>代码分析</h4><ul>
<li><code>@Getter</code>注解标注在<code>User</code>类上，Lombok会自动为<code>User</code>类中的<code>private Long id</code>、<code>private String name</code>和<code>private Integer age</code>属性生成对应的<code>getter</code>方法，如<code>getId()</code>、<code>getName()</code>和<code>getAge()</code>，从而避免了手动编写这些方法的繁琐过程。</li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>About</title>
    <url>https://kfufys.github.io/posts/74350de7.html</url>
    <content><![CDATA[<head>
    <meta charset="UTF-8">
    <style>
        strong {
            color: #d9363f;
        }
    </style>
</head>
<body>
    <img src="https://kfufys.github.io/posts/74350de7/1.png" alt="head-img" width="1200">
    <br>
    <p><b>Hello👋</b><br>我是&ensp;<a href="https://kfufys.github.io/posts/7477.html"><strong>窦长友</strong></a>，一名摄影爱好者，编程小渣渣~~</p>
    <p>目前就读于&ensp;<a href="https://www.kfu.edu.cn"><strong>开封大学</strong></a>....</p>
    <h3>我的爱好</h3>
        <p>热衷于研究所有与计算机相关的事物，包括：</p>
        <ul>
            <li><strong>摄影修图</strong>：通过各种软件和技巧来让拍摄的照片更加完美。</li>
            <li><strong>视频编辑</strong>：对拍摄的视频素材进行剪辑、添加特效等操作，使其成为富有吸引力的视频作品。</li>
            <li><strong>PPT设计</strong>：精心构思PPT的内容结构、排版以及动画效果等，打造出高质量的演示文稿。</li>
            <li><strong>网页设计</strong>：从页面布局、色彩搭配到交互功能等方面进行设计，创建美观实用的网页。</li>
        </ul>
        <h3>我的白日梦</h3>
        <p>带着相机和好心情，与自己喜欢的人一起环游世界。</p>
        <p>祝大家在我的小站玩的高兴！😃</p>
</body>]]></content>
  </entry>
  <entry>
    <title>Node包管理器命令速查手册</title>
    <url>https://kfufys.github.io/posts/f4908e69.html</url>
    <content><![CDATA[<img src="https://kfufys.github.io/posts/f4908e69/1.jpg" alt="node.js">

<h2 id="🚀-项目初始化"><a href="#🚀-项目初始化" class="headerlink" title="🚀 项目初始化"></a>🚀 项目初始化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 初始化项目</span></span><br><span class="line">npm init [-y]</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 初始化项目</span></span><br><span class="line">pnpm init [-y]</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 初始化项目（v2+需要手动创建）</span></span><br><span class="line">yarn init [-y]</span><br></pre></td></tr></table></figure>

<h2 id="🛠️-安装依赖"><a href="#🛠️-安装依赖" class="headerlink" title="🛠️ 安装依赖"></a>🛠️ 安装依赖</h2><h3 id="安装生产依赖"><a href="#安装生产依赖" class="headerlink" title="安装生产依赖"></a>安装生产依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 安装并写入 dependencies</span></span><br><span class="line">npm install &lt;package&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 安装并写入 dependencies</span></span><br><span class="line">pnpm add &lt;package&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 安装并写入 dependencies</span></span><br><span class="line">yarn add &lt;package&gt;</span><br></pre></td></tr></table></figure>

<h3 id="安装开发依赖"><a href="#安装开发依赖" class="headerlink" title="安装开发依赖"></a>安装开发依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 安装并写入 devDependencies</span></span><br><span class="line">npm install &lt;package&gt; -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 安装并写入 devDependencies</span></span><br><span class="line">pnpm add &lt;package&gt; -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 安装并写入 devDependencies</span></span><br><span class="line">yarn add &lt;package&gt; -D</span><br></pre></td></tr></table></figure>

<h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 全局安装</span></span><br><span class="line">npm install &lt;package&gt; -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 全局安装</span></span><br><span class="line">pnpm add &lt;package&gt; -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 全局安装</span></span><br><span class="line">yarn global add &lt;package&gt;</span><br></pre></td></tr></table></figure>

<h3 id="安装全部依赖"><a href="#安装全部依赖" class="headerlink" title="安装全部依赖"></a>安装全部依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 根据 package.json 安装</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 根据 package.json 安装</span></span><br><span class="line">pnpm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 根据 package.json 安装</span></span><br><span class="line">yarn install</span><br></pre></td></tr></table></figure>

<h2 id="🔄-依赖管理"><a href="#🔄-依赖管理" class="headerlink" title="🔄 依赖管理"></a>🔄 依赖管理</h2><h3 id="更新依赖"><a href="#更新依赖" class="headerlink" title="更新依赖"></a>更新依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 更新指定包</span></span><br><span class="line">npm update &lt;package&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 更新指定包</span></span><br><span class="line">pnpm update &lt;package&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 更新指定包</span></span><br><span class="line">yarn up &lt;package&gt;</span><br></pre></td></tr></table></figure>

<h3 id="删除依赖"><a href="#删除依赖" class="headerlink" title="删除依赖"></a>删除依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 移除指定包</span></span><br><span class="line">npm uninstall &lt;package&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 移除指定包</span></span><br><span class="line">pnpm remove &lt;package&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 移除指定包</span></span><br><span class="line">yarn remove &lt;package&gt;</span><br></pre></td></tr></table></figure>

<h3 id="查看过时依赖"><a href="#查看过时依赖" class="headerlink" title="查看过时依赖"></a>查看过时依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 检查过时包</span></span><br><span class="line">npm outdated</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 检查过时包</span></span><br><span class="line">pnpm outdated</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 检查过时包</span></span><br><span class="line">yarn outdated</span><br></pre></td></tr></table></figure>

<h2 id="🏃-运行脚本"><a href="#🏃-运行脚本" class="headerlink" title="🏃 运行脚本"></a>🏃 运行脚本</h2><h3 id="执行自定义脚本"><a href="#执行自定义脚本" class="headerlink" title="执行自定义脚本"></a>执行自定义脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 运行脚本</span></span><br><span class="line">npm run &lt;script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 运行脚本</span></span><br><span class="line">pnpm run &lt;script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 运行脚本</span></span><br><span class="line">yarn run &lt;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 运行 test 脚本</span></span><br><span class="line">npm <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 运行 test 脚本</span></span><br><span class="line">pnpm <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 运行 test 脚本</span></span><br><span class="line">yarn <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="📦-依赖锁定"><a href="#📦-依赖锁定" class="headerlink" title="📦 依赖锁定"></a>📦 依赖锁定</h2><h3 id="生成锁定文件"><a href="#生成锁定文件" class="headerlink" title="生成锁定文件"></a>生成锁定文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 生成 package-lock.json</span></span><br><span class="line">npm install --package-lock</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 生成 pnpm-lock.yaml（自动生成）</span></span><br><span class="line">pnpm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 生成 yarn.lock（自动生成）</span></span><br><span class="line">yarn install</span><br></pre></td></tr></table></figure>

<h2 id="🌍-全局管理"><a href="#🌍-全局管理" class="headerlink" title="🌍 全局管理"></a>🌍 全局管理</h2><h3 id="列出全局包"><a href="#列出全局包" class="headerlink" title="列出全局包"></a>列出全局包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 查看全局安装的包</span></span><br><span class="line">npm list -g --depth=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 查看全局安装的包</span></span><br><span class="line">pnpm list -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 查看全局安装的包</span></span><br><span class="line">yarn global list</span><br></pre></td></tr></table></figure>

<h2 id="🚨-安全审计"><a href="#🚨-安全审计" class="headerlink" title="🚨 安全审计"></a>🚨 安全审计</h2><h3 id="漏洞检查"><a href="#漏洞检查" class="headerlink" title="漏洞检查"></a>漏洞检查</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 安全审计</span></span><br><span class="line">npm audit</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 安全审计</span></span><br><span class="line">pnpm audit</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 安全审计（需要插件）</span></span><br><span class="line">yarn audit</span><br></pre></td></tr></table></figure>

<h2 id="🧹-缓存清理"><a href="#🧹-缓存清理" class="headerlink" title="🧹 缓存清理"></a>🧹 缓存清理</h2><h3 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 清理缓存</span></span><br><span class="line">npm cache clean --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 清理缓存</span></span><br><span class="line">pnpm store prune</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 清理缓存</span></span><br><span class="line">yarn cache clean</span><br></pre></td></tr></table></figure>

<h2 id="📚-其他实用命令"><a href="#📚-其他实用命令" class="headerlink" title="📚 其他实用命令"></a>📚 其他实用命令</h2><h3 id="查看包信息"><a href="#查看包信息" class="headerlink" title="查看包信息"></a>查看包信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 查看包信息</span></span><br><span class="line">npm info &lt;package&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 查看包信息</span></span><br><span class="line">pnpm info &lt;package&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 查看包信息</span></span><br><span class="line">yarn info &lt;package&gt;</span><br></pre></td></tr></table></figure>

<h3 id="执行npx等效操作"><a href="#执行npx等效操作" class="headerlink" title="执行npx等效操作"></a>执行npx等效操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 执行临时包命令</span></span><br><span class="line">npx &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 执行临时包命令</span></span><br><span class="line">pnpm dlx &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 执行临时包命令</span></span><br><span class="line">yarn dlx &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="版本快捷操作"><a href="#版本快捷操作" class="headerlink" title="版本快捷操作"></a>版本快捷操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 版本自增</span></span><br><span class="line">npm version [major|minor|patch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 版本自增</span></span><br><span class="line">pnpm version [major|minor|patch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 版本自增</span></span><br><span class="line">yarn version [major|minor|patch]</span><br></pre></td></tr></table></figure>

<h2 id="🌟-工作区管理-Monorepo"><a href="#🌟-工作区管理-Monorepo" class="headerlink" title="🌟 工作区管理 (Monorepo)"></a>🌟 工作区管理 (Monorepo)</h2><h3 id="初始化-管理工作区"><a href="#初始化-管理工作区" class="headerlink" title="初始化&#x2F;管理工作区"></a>初始化&#x2F;管理工作区</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 创建工作区</span></span><br><span class="line">npm init -w ./packages/&lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 配置工作区（需创建 pnpm-workspace.yaml）</span></span><br><span class="line">pnpm add -w &lt;package&gt;  <span class="comment"># 全局安装到根目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 管理工作区（需配置 workspaces）</span></span><br><span class="line">yarn workspace &lt;workspace_name&gt; add &lt;package&gt;</span><br></pre></td></tr></table></figure>

<h2 id="🌳-依赖树分析"><a href="#🌳-依赖树分析" class="headerlink" title="🌳 依赖树分析"></a>🌳 依赖树分析</h2><h3 id="查看项目依赖结构"><a href="#查看项目依赖结构" class="headerlink" title="查看项目依赖结构"></a>查看项目依赖结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 列出嵌套依赖树</span></span><br><span class="line">npm <span class="built_in">ls</span> [--depth=N]</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 扁平化依赖展示</span></span><br><span class="line">pnpm list --depth=N</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 可视化依赖树</span></span><br><span class="line">yarn list --pattern &lt;package&gt;</span><br></pre></td></tr></table></figure>

<h2 id="🧼-深度清理"><a href="#🧼-深度清理" class="headerlink" title="🧼 深度清理"></a>🧼 深度清理</h2><h3 id="清除并重置依赖"><a href="#清除并重置依赖" class="headerlink" title="清除并重置依赖"></a>清除并重置依赖</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 删除 node_modules 并重新安装</span></span><br><span class="line"><span class="built_in">rm</span> -rf node_modules &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 强制重新构建依赖</span></span><br><span class="line">pnpm install --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 清除缓存并重装</span></span><br><span class="line">yarn cache clean &amp;&amp; yarn install</span><br></pre></td></tr></table></figure>

<h2 id="🔍-精确检查"><a href="#🔍-精确检查" class="headerlink" title="🔍 精确检查"></a>🔍 精确检查</h2><h3 id="验证依赖完整性"><a href="#验证依赖完整性" class="headerlink" title="验证依赖完整性"></a>验证依赖完整性</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 校验依赖与 lock 文件一致性</span></span><br><span class="line">npm ci         <span class="comment"># 严格模式安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 校验存储完整性</span></span><br><span class="line">pnpm store status</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 验证依赖结构</span></span><br><span class="line">yarn check --integrity</span><br></pre></td></tr></table></figure>

<h2 id="🔧-配置管理"><a href="#🔧-配置管理" class="headerlink" title="🔧 配置管理"></a>🔧 配置管理</h2><h3 id="修改镜像源"><a href="#修改镜像源" class="headerlink" title="修改镜像源"></a>修改镜像源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 切换淘宝镜像</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 切换镜像源</span></span><br><span class="line">pnpm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 切换镜像源</span></span><br><span class="line">yarn config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>

<h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 列出所有配置</span></span><br><span class="line">npm config list</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 显示当前配置</span></span><br><span class="line">pnpm config list</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 输出配置信息</span></span><br><span class="line">yarn config list</span><br></pre></td></tr></table></figure>

<h2 id="⚡️-高效操作"><a href="#⚡️-高效操作" class="headerlink" title="⚡️ 高效操作"></a>⚡️ 高效操作</h2><h3 id="并行执行命令"><a href="#并行执行命令" class="headerlink" title="并行执行命令"></a>并行执行命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 需安装第三方工具</span></span><br><span class="line">npx npm-run-all --parallel task1 task2</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 原生支持并行</span></span><br><span class="line">pnpm -r run build  <span class="comment"># 递归执行所有子项目 build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 使用 workspaces 指令</span></span><br><span class="line">yarn workspaces foreach run build</span><br></pre></td></tr></table></figure>

<h3 id="交互式更新"><a href="#交互式更新" class="headerlink" title="交互式更新"></a>交互式更新</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm |  guided 更新</span></span><br><span class="line">npm update --interactive</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 可视化选择更新</span></span><br><span class="line">pnpm update -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 需使用插件</span></span><br><span class="line">yarn upgrade-interactive</span><br></pre></td></tr></table></figure>

<h2 id="📜-许可证检查"><a href="#📜-许可证检查" class="headerlink" title="📜 许可证检查"></a>📜 许可证检查</h2><h3 id="查看依赖许可"><a href="#查看依赖许可" class="headerlink" title="查看依赖许可"></a>查看依赖许可</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 生成许可证报告</span></span><br><span class="line">npm <span class="built_in">ls</span> --json | npx license-checker</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 内置许可证检查</span></span><br><span class="line">pnpm licenses list</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 使用插件支持</span></span><br><span class="line">yarn plugin import workspace-tools &amp;&amp; yarn licenses list</span><br></pre></td></tr></table></figure>

<h2 id="🏗️-构建与发布"><a href="#🏗️-构建与发布" class="headerlink" title="🏗️ 构建与发布"></a>🏗️ 构建与发布</h2><h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 执行 build 脚本（通常配置在 package.json）</span></span><br><span class="line">npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 执行 build 脚本（支持递归构建工作区）</span></span><br><span class="line">pnpm run build</span><br><span class="line"><span class="comment"># 或工作区批量构建</span></span><br><span class="line">pnpm -r run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 执行 build 脚本（支持工作区构建）</span></span><br><span class="line">yarn build</span><br><span class="line"><span class="comment"># 或工作区批量构建</span></span><br><span class="line">yarn workspaces foreach run build</span><br></pre></td></tr></table></figure>

<h3 id="构建后本地预览"><a href="#构建后本地预览" class="headerlink" title="构建后本地预览"></a>构建后本地预览</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 使用 serve 等工具预览</span></span><br><span class="line">npx serve ./dist</span><br><span class="line"><span class="comment"># 或执行 preview 脚本（需提前配置）</span></span><br><span class="line">npm run preview</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 快速启动预览服务</span></span><br><span class="line">pnpm dlx serve ./dist</span><br><span class="line"><span class="comment"># 或工作区预览（如 Vite 项目）</span></span><br><span class="line">pnpm run preview</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 启动静态服务器</span></span><br><span class="line">yarn dlx serve ./dist</span><br><span class="line"><span class="comment"># 或执行预览脚本</span></span><br><span class="line">yarn preview</span><br></pre></td></tr></table></figure>

<h3 id="发布到-npm-仓库"><a href="#发布到-npm-仓库" class="headerlink" title="发布到 npm 仓库"></a>发布到 npm 仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 发布包（需先登录）</span></span><br><span class="line">npm login          <span class="comment"># 首次使用需登录</span></span><br><span class="line">npm publish        <span class="comment"># 发布公开包</span></span><br><span class="line">npm publish --access public  <span class="comment"># 发布作用域公开包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 发布包（需配置 registry）</span></span><br><span class="line">pnpm publish</span><br><span class="line"><span class="comment"># 工作区指定包发布</span></span><br><span class="line">pnpm -r publish --filter &lt;package_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 发布包（需配置 publishConfig）</span></span><br><span class="line">yarn login         <span class="comment"># 登录认证</span></span><br><span class="line">yarn publish       <span class="comment"># 交互式发布</span></span><br><span class="line">yarn publish --non-interactive  <span class="comment"># 静默发布</span></span><br></pre></td></tr></table></figure>

<h2 id="🧪-构建高级操作"><a href="#🧪-构建高级操作" class="headerlink" title="🧪 构建高级操作"></a>🧪 构建高级操作</h2><h3 id="带环境变量的构建"><a href="#带环境变量的构建" class="headerlink" title="带环境变量的构建"></a>带环境变量的构建</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 注入环境变量</span></span><br><span class="line">NODE_ENV=production npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 跨平台环境变量设置</span></span><br><span class="line">pnpm run build --mode production</span><br><span class="line"><span class="comment"># 或使用 dotenv 注入</span></span><br><span class="line">pnpm add -D dotenv &amp;&amp; pnpm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 使用 env-cmd 工具</span></span><br><span class="line">yarn add -D env-cmd</span><br><span class="line">yarn env-cmd -f .env.prod yarn build</span><br></pre></td></tr></table></figure>

<h3 id="构建缓存清理"><a href="#构建缓存清理" class="headerlink" title="构建缓存清理"></a>构建缓存清理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 清理构建产物</span></span><br><span class="line"><span class="built_in">rm</span> -rf ./dist &amp;&amp; npm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 强制全新构建</span></span><br><span class="line">pnpm <span class="built_in">exec</span> rimraf ./dist &amp;&amp; pnpm run build</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 清除构建缓存</span></span><br><span class="line">yarn clean &amp;&amp; yarn build</span><br></pre></td></tr></table></figure>

<h2 id="🚢-自动化发布流程"><a href="#🚢-自动化发布流程" class="headerlink" title="🚢 自动化发布流程"></a>🚢 自动化发布流程</h2><h3 id="版本号-构建-发布一键操作"><a href="#版本号-构建-发布一键操作" class="headerlink" title="版本号+构建+发布一键操作"></a>版本号+构建+发布一键操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 组合命令</span></span><br><span class="line">npm version patch &amp;&amp; npm run build &amp;&amp; npm publish</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 管道式操作</span></span><br><span class="line">pnpm version patch &amp;&amp; pnpm build &amp;&amp; pnpm publish</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 工作流命令</span></span><br><span class="line">yarn version --patch &amp;&amp; yarn build &amp;&amp; yarn publish</span><br></pre></td></tr></table></figure>

<h3 id="发布候选版本"><a href="#发布候选版本" class="headerlink" title="发布候选版本"></a>发布候选版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># npm | 带 tag 发布</span></span><br><span class="line">npm publish --tag beta</span><br><span class="line"></span><br><span class="line"><span class="comment"># pnpm | 指定发布通道</span></span><br><span class="line">pnpm publish --tag next</span><br><span class="line"></span><br><span class="line"><span class="comment"># yarn | 标记预发布版本</span></span><br><span class="line">yarn publish --tag canary</span><br></pre></td></tr></table></figure>

<p>🏷️ <em><strong>扩展技巧</strong></em>：使用 <code>npm pack</code> &#x2F; <code>pnpm pack</code> &#x2F; <code>yarn pack</code> 可生成.tgz发布包文件用于离线验证，再通过 <code>npm publish &lt;file.tgz&gt;</code> 发布</p>
<p>💡 <em><strong>提示</strong></em>：不同包管理器在安装速度和磁盘空间占用上有差异：</p>
<ul>
<li>**<code>pnpm</code>**：使用硬链接机制更节省空间</li>
<li>**<code>yarn</code>**：擅长依赖解析优化</li>
<li>**<code>npm</code>**：则是 <code>Node.js</code> 官方内置工具</li>
</ul>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>站点更新日志</title>
    <url>https://kfufys.github.io/posts/7178.html</url>
    <content><![CDATA[<img src="https://kfufys.github.io/posts/7178/1.png" alt="head-img" width="1200">

<h3 id="2024-11-16"><a href="#2024-11-16" class="headerlink" title="2024.11.16"></a>2024.11.16</h3><blockquote>
<p><strong>网站初次上线</strong></p>
<p><strong>域名</strong>：<span class="exturl" data-url="aHR0cHM6Ly9kY3l5ZC5naXRodWIuaW8vaGV4b193ZWJzaXRlcw==">https://dcyyd.github.io/hexo_websites<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>详细信息</strong>：基于 hexo和 Github搭建的静态 web blog站点，成功托管至Github Pages页，网站主题基于开源 Next 主题，并对其进行了一些优化。</p>
</blockquote>
<h3 id="2024-11-25"><a href="#2024-11-25" class="headerlink" title="2024.11.25"></a>2024.11.25</h3><blockquote>
<p><strong>网站域名更换</strong></p>
<p><strong>域名</strong>：<a href="kfufys.github.io">kfufys.github.io</a></p>
<p><strong>详细信息</strong>：因业务转型，旧域名停用，网站整体迁移至新域名 <a href="kfufys.github.io">kfufys.github.io</a> ，旧域名内容继续保留，但不再对其进行任何更新。</p>
</blockquote>
<h3 id="2024-12-02"><a href="#2024-12-02" class="headerlink" title="2024.12.02"></a>2024.12.02</h3><blockquote>
<p><strong>对网站设备适配做了一些优化</strong></p>
<p><strong>域名</strong>：<a href="kfufys.github.io">kfufys.github.io</a></p>
<p><strong>详细信息</strong>：运用响应式设计重写 CSS，不同设备屏幕下页面自适应。移动端导航栏变汉堡菜单，图片依像素密度加载，优化 touch 事件，提升多设备交互体验。</p>
</blockquote>
<h3 id="2024-12-20"><a href="#2024-12-20" class="headerlink" title="2024.12.20"></a>2024.12.20</h3><blockquote>
<p><strong>新增网站亮暗主题变换功能</strong></p>
<p><strong>域名</strong>：<a href="kfufys.github.io">kfufys.github.io</a></p>
<p><strong>详细信息</strong>：前端植入 JavaScript 脚本与 CSS 变量，实现亮暗主题切换。点右上角按钮可切换，系统还能依设备系统主题偏好预设默认主题，增强个性化。</p>
</blockquote>
<h3 id="2025-01-20"><a href="#2025-01-20" class="headerlink" title="2025.01.20"></a>2025.01.20</h3><blockquote>
<p><strong>对网站 SEO 做了一些优化</strong></p>
<p><strong>域名</strong>：<a href="kfufys.github.io">kfufys.github.io</a></p>
<p><strong>详细信息</strong>：优化页面 Title Tag 含核心关键词，更新 Meta Description 文案吸引点击，为图片添 alt 属性助搜索引擎理解，优化内链结构均衡权重。</p>
</blockquote>
<h3 id="2025-02-05"><a href="#2025-02-05" class="headerlink" title="2025.02.05"></a>2025.02.05</h3><blockquote>
<p><strong>对网站 meta 标签信息及站点 image url 进行一些优化</strong></p>
<p><strong>域名</strong>：<a href="kfufys.github.io">kfufys.github.io</a></p>
<p><strong>详细信息</strong>：优化 meta 站点描述标签及站点关键字标签，解决先前文章图片依赖图床导致加载慢及链接失效问题。</p>
</blockquote>
]]></content>
      <categories>
        <category>站点日志</category>
      </categories>
      <tags>
        <tag>website</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>基于GitHub+hexo部署静态Blog</title>
    <url>https://kfufys.github.io/posts/60795.html</url>
    <content><![CDATA[<img src="https://kfufys.github.io/posts/60795/1.png" alt="head-img" width="1200">

<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>本文详细介绍了如何使用Hexo框架搭建一个个人博客，并将其部署到GitHub Pages上。主要内容包括：</p>
<ul>
<li><strong>环境准备：</strong>安装Node.js和Git</li>
<li><strong>配置Git和GitHub：</strong>设置SSH密钥，创建GitHub仓库</li>
<li><strong>初始化Hexo项目：</strong>安装Hexo，创建新博客</li>
<li><strong>部署到GitHub Pages：</strong>配置部署设置，推送静态文件</li>
<li><strong>基本使用方法：</strong>创建新文章，本地预览，发布更新</li>
</ul>
<p>这个教程适合那些想要快速搭建个人博客，但又不想花费太多成本的人。通过使用Hexo和GitHub的免费服务，您可以轻松创建一个高效、简洁的博客网站。</p>
<h3 id="二、事前准备"><a href="#二、事前准备" class="headerlink" title="二、事前准备"></a><strong>二、事前准备</strong></h3><ol>
<li><h4 id="在线支持"><a href="#在线支持" class="headerlink" title="在线支持"></a><strong>在线支持</strong></h4><ul>
<li><a href="https://app.rainyun.com/"><strong>域名注册 | 雨云</strong></a>：（非必须，你也可以使用免费域名，或者<code>GitHub.io</code>或<code>Pages.dev</code>分配的域名也可以）</li>
<li><a href="https://github.com/"><strong>GitHub</strong></a>：（必须，你需要注册一个 GitHub 帐号）</li>
</ul>
</li>
<li><h4 id="软件支持"><a href="#软件支持" class="headerlink" title="软件支持"></a><strong>软件支持</strong></h4><ul>
<li><a href="https://blog.kingxujw.com/2024/10/07/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/#2-1-%E5%AE%89%E8%A3%85-Node"><strong>Node</strong></a>：（必须，Nodejs 是一个基于<strong>Chrome V8</strong>引擎的<strong>JS</strong>运行环境，可以用<strong>JS</strong>写服务器和前端代码。）</li>
<li><a href="https://blog.kingxujw.com/2024/10/07/%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/#2-2-%E5%AE%89%E8%A3%85-Git"><strong>Git</strong></a>：（必须，Git 是当前最先进、最主流的<strong>分布式</strong>版本控制系统，免费、开源）</li>
<li><a href="https://gohugo.io/"><strong>Hugo</strong></a>：（必须，Hugo 是用<strong>Go</strong>语言写的静态网站生成器（Static Site Generator），可以把 Markdown 文件转化成 HTML 文件）</li>
<li><a href="https://dcloud.io/hbuilderx.html"><strong>HBuilderX</strong></a>：（非必须，HBuilderX 是一款为<strong>Vue</strong>开发精心打造的超强集成开发环境（<strong>IDE</strong>））</li>
</ul>
</li>
</ol>
<h3 id="三、软件安装"><a href="#三、软件安装" class="headerlink" title="三、软件安装"></a><strong>三、软件安装</strong></h3><ol>
<li><h4 id="安装-Node"><a href="#安装-Node" class="headerlink" title="安装 Node"></a><strong>安装 Node</strong></h4><ul>
<li><p>打开<a href="https://nodejs.org/zh-cn/download/prebuilt-installer"><strong>Node.js</strong></a>官网，下载和自己系统相配的Node的安装程序，否则会出现安装问题</p>
</li>
<li><p>下载后安装，安装的目录可以使用默认目录<code>C:/Program Files/nodejs/</code></p>
</li>
<li><p>安装完成后，检查是否安装成功。在键盘按下win + R键，输入CMD，然后回车，打开CMD窗口，执行<code>node -v</code>命令，看到版本信息，则说明安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;node -v</span><br><span class="line">v20.18.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改npm源。npm下载各种模块，默认是从国处服务器下载，速度较慢，建议配置成华为云镜像源。打开CMD窗口，运行如下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://mirrors.huaweicloud.com/repository/npm/</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h4 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a><strong>安装 Git</strong></h4><ul>
<li><p>进入<a href="https://git-scm.com/downloads/win"><strong>Git</strong></a>官网下载适合你当前系统的版本</p>
</li>
<li><p>下载后傻瓜式安装Git即可，安装的目录最好使用默认目录<code>C:/Program Files/Git</code></p>
</li>
<li><p>按win + R键，输入CMD，然后回车，打开CMD窗口，执行<code>git -v</code>命令，看到版本信息，则说明安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;git -v</span><br><span class="line">git version 2.42.0.windows.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Git组件：</strong></p>
<p><strong><code>Git CMD</code></strong> 是windows 命令行的指令风格</p>
<p><strong><code>Git Bash</code></strong> 是linux系统的指令风格（建议使用）</p>
<p>**<code>Git GUI</code>**是图形化界面（新手学习不建议使用）</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="四、配置-Git-密钥并连接至-Github"><a href="#四、配置-Git-密钥并连接至-Github" class="headerlink" title="四、配置 Git 密钥并连接至 Github"></a><strong>四、配置 Git 密钥并连接至 Github</strong></h3><ol>
<li><h4 id="常用-Git-命令："><a href="#常用-Git-命令：" class="headerlink" title="常用 Git 命令："></a><strong>常用 Git 命令：</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config -l	//查看所有配置</span><br><span class="line">git config --system --list	//查看系统配置</span><br><span class="line">git config --global --list	//查看用户（全局）配置</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="配置用户名和邮箱："><a href="#配置用户名和邮箱：" class="headerlink" title="配置用户名和邮箱："></a><strong>配置用户名和邮箱：</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="配置公钥连接-Github："><a href="#配置公钥连接-Github：" class="headerlink" title="配置公钥连接 Github："></a><strong>配置公钥连接 Github：</strong></h4><ul>
<li><p><strong>生成ssh公钥</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>id_rsa</code>私钥</p>
<p><code>id_rsa.pub</code>公钥</p>
</blockquote>
</li>
</ul>
<p> 用记事本打开上述图片中的公钥<code>id_rsa.pub</code>，复制里面的内容，然后开始在github中配置ssh密钥。</p>
<ul>
<li><p><strong>将 SSH KEY 配置到 GitHub</strong>  </p>
<ul>
<li>进入github，点击右上角头像 选择<code>settings</code>，进入设置页后选择 <code>SSH and GPG keys</code>，名字随便起，公钥填到<code>Key</code>那一栏。</li>
</ul>
</li>
<li><p><strong>测试连接，输入以下命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T [email protected]</span><br></pre></td></tr></table></figure></li>
</ul>
<p> 第一次连接会提示<code>Are you sure you want to continue connecting (yes/no/[fingerprint])?</code>，输入<code>yes</code>即可<br> 出现连接到账户的信息，说明已经大功告成，至此完成了环境准备工作。
 </p>
</li>
<li><h4 id="创建GitHub-io仓库"><a href="#创建GitHub-io仓库" class="headerlink" title="创建GitHub.io仓库"></a><strong>创建GitHub.io仓库</strong></h4><ul>
<li><p>注册登录<a href="https://github.com/"><strong>GitHub</strong></a></p>
</li>
<li><p>点击右上角的<code>+</code>按钮，选择<strong>New repository</strong>，创建一个<code>&lt;用户名&gt;.github.io</code>的仓库。</p>
</li>
<li><p>仓库名字的格式必须为：<code>&lt;用户名&gt;.github.io</code> (注意：前缀必须为用户名，此为预览博客需要，后期可修改仓库名)</p>
</li>
<li><p>可见性必须选择 <code>Public</code> 方便第一次部署检查问题，点击 <strong>Creat repository</strong> 进行创建即可</p>
</li>
</ul>
</li>
</ol>
<h3 id="五、初始化-Hexo-博客"><a href="#五、初始化-Hexo-博客" class="headerlink" title="五、初始化 Hexo 博客"></a><strong>五、初始化 Hexo 博客</strong></h3><ol>
<li><p>创建一个文件夹来保存博客源码（我这里选的路径为<code>D:/Hexo-Blog</code>），在文件夹内右键鼠标，选择<code>Open Git Bash here</code></p>
</li>
<li><p>在<code>Git BASH</code>输入如下命令安装 Hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli &amp;&amp; hexo -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;hexo -v</span><br><span class="line">hexo-cli: 4.3.2</span><br><span class="line">os: win32 10.0.22631 undefined</span><br><span class="line">node: 20.18.0</span><br><span class="line">acorn: 8.12.1</span><br><span class="line">ada: 2.9.0</span><br><span class="line">ares: 1.33.1</span><br><span class="line">base64: 0.5.2</span><br><span class="line">brotli: 1.1.0</span><br><span class="line">cjs_module_lexer: 1.4.1</span><br><span class="line">cldr: 45.0</span><br><span class="line">icu: 75.1</span><br><span class="line">llhttp: 8.1.2</span><br><span class="line">modules: 115</span><br><span class="line">napi: 9</span><br><span class="line">nghttp2: 1.61.0</span><br><span class="line">nghttp3: 0.7.0</span><br><span class="line">ngtcp2: 1.1.0</span><br><span class="line">openssl: 3.0.13+quic</span><br><span class="line">simdutf: 5.5.0</span><br><span class="line">tz: 2024a</span><br><span class="line">undici: 6.19.8</span><br><span class="line">unicode: 15.1</span><br><span class="line">uv: 1.46.0</span><br><span class="line">uvwasi: 0.0.21</span><br><span class="line">v8: 11.3.244.8-node.23</span><br><span class="line">zlib: 1.3.0.1-motley-71660e1</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化 Hexo 项目安装相关依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init blog-demo //创建项目</span><br><span class="line">cd blog-demo //切换路径</span><br><span class="line">npm i //安装依赖</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化项目后，<code>blog-demo</code>有如下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blog-demo</span><br><span class="line">├── node_modules //依赖包</span><br><span class="line">├── scaffolds //生成文章的一些模板</span><br><span class="line">├── source //用来存放你的文章</span><br><span class="line">├── themes //主题</span><br><span class="line">├──.npmignore //发布时忽略的文件（可忽略）</span><br><span class="line">├── _config.landscape.yml //主题的配置文件</span><br><span class="line">├── config.yml //博客的配置文件</span><br><span class="line">└── package.json //项目名称、描述、版本、运行和开发等信息</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令行输入<code>hexo cl &amp;&amp; hexo s</code>启动项目</p>
</li>
<li><p>打开浏览器，输入地址：<a href="http://localhost:4000/"><code>http://localhost:4000/</code></a> ，看到欢迎界面，说明你的博客已经构建成功了。</p>
</li>
</ol>
<h3 id="六、将静态博客挂载到-GitHub-Pages"><a href="#六、将静态博客挂载到-GitHub-Pages" class="headerlink" title="六、将静态博客挂载到 GitHub Pages"></a><strong>六、将静态博客挂载到 GitHub Pages</strong></h3><ol>
<li><p>安装 hexo-deployer-git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>_config.yml</code> 文件<br>在blog-demo目录下的_config.yml，就是整个Hexo框架的配置文件，详细可参考官方的<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29uZmlndXJhdGlvbg==">配置描述<i class="fa fa-external-link-alt"></i></span><br>修改最后一行的配置，将repository修改为你自己的github项目地址即可，还有分支要改为<code>main</code>代表主分支（注意缩进）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:  </span><br><span class="line">    type: git</span><br><span class="line">    repository: [email protected]:kingmoon3/kingmoon3.github.io.git</span><br><span class="line">    branch: main</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改好配置后，运行如下命令，将代码部署到 GitHub（Hexo三连）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Git BASH终端</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<blockquote>
<p>**<code>hexo clean</code>**：删除之前生成的文件，可以用<code>hexo cl</code>缩写。</p>
<p>**<code>hexo generate</code>**：生成静态文章，可以用<code>hexo g</code>缩写</p>
<p>**<code>hexo deploy</code>**：部署文章，可以用<code>hexo d</code>缩写</p>
</blockquote>
</li>
</ol>
<p><em>注意：deploy时可能要你输入 username 和 password。</em></p>
<p>如果出现 **<code>INFO  Deploy done: git</code>**，则说明部署成功了。</p>
<p>稍等两分钟，打开浏览器访问：<span class="exturl" data-url="aHR0cHM6Ly/kvaDnmoRnaXRodWLnlKjmiLflkI0uZ2l0aHViLmlvLw==">https:&#x2F;&#x2F;[你的github用户名].github.io<i class="fa fa-external-link-alt"></i></span> ，这时候我们就可以看到博客内容了。</p>
<h3 id="附：GitHub网站部署常用命令："><a href="#附：GitHub网站部署常用命令：" class="headerlink" title="附：GitHub网站部署常用命令："></a>附：GitHub网站部署常用命令：</h3><ol>
<li><h4 id="Git相关："><a href="#Git相关：" class="headerlink" title="Git相关："></a>Git相关：</h4></li>
</ol>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>git init</code></td>
<td>在当前目录初始化一个Git仓库</td>
<td><code>git init my_project</code>（在<code>my_project</code>目录下初始化仓库）</td>
</tr>
<tr>
<td><code>git clone [url]</code></td>
<td>克隆远程仓库到本地</td>
<td><code>git clone https://github.com/user/repo.git</code>（克隆指定仓库）</td>
</tr>
<tr>
<td><code>git status</code></td>
<td>查看仓库中文件的状态</td>
<td>在仓库目录下执行<code>git status</code>查看文件修改、暂存等状态</td>
</tr>
<tr>
<td><code>git add [file/dir]</code></td>
<td>将文件或目录添加到暂存区</td>
<td><code>git add file.txt</code>（添加单个文件），<code>git add.</code>（添加当前目录下所有文件）</td>
</tr>
<tr>
<td><code>git commit -m &quot;[message]&quot;</code></td>
<td>提交暂存区的内容，并添加提交消息</td>
<td><code>git commit -m &quot;Update README&quot;</code>（提交并添加消息）</td>
</tr>
<tr>
<td><code>git branch</code></td>
<td>查看本地分支列表</td>
<td>执行<code>git branch</code>查看当前仓库的分支情况</td>
</tr>
<tr>
<td><code>git branch [branch - name]</code></td>
<td>创建一个新的本地分支</td>
<td><code>git branch new_branch</code>（创建名为<code>new_branch</code>的分支）</td>
</tr>
<tr>
<td><code>git checkout [branch - name]</code></td>
<td>切换到指定分支</td>
<td><code>git checkout master</code>（切换到<code>master</code>分支）</td>
</tr>
<tr>
<td><code>git merge [branch - name]</code></td>
<td>合并指定分支到当前分支</td>
<td>假设在<code>master</code>分支，<code>git merge feature_branch</code>（合并<code>feature_branch</code>）</td>
</tr>
<tr>
<td><code>git log</code></td>
<td>查看提交历史</td>
<td>执行<code>git log</code>查看之前的提交记录，包括作者、日期、消息等</td>
</tr>
<tr>
<td><code>git remote add [name] [url]</code></td>
<td>添加远程仓库</td>
<td><code>git remote add origin https://github.com/user/repo.git</code>（添加名为<code>origin</code>的远程仓库）</td>
</tr>
<tr>
<td><code>git push [remote - name] [branch - name]</code></td>
<td>将本地分支推送到远程仓库</td>
<td><code>git push origin master</code>（推送<code>master</code>分支到<code>origin</code>）</td>
</tr>
<tr>
<td><code>git pull [remote - name] [branch - name]</code></td>
<td>从远程仓库拉取并合并更新</td>
<td><code>git pull origin master</code>（拉取<code>master</code>分支更新）</td>
</tr>
<tr>
<td><code>git diff [file]</code></td>
<td>查看文件的修改差异</td>
<td><code>git diff file.txt</code>（查看<code>file.txt</code>的修改差异）</td>
</tr>
<tr>
<td><code>git stash</code></td>
<td>暂存当前工作区的修改</td>
<td>在未完成的修改状态下，执行<code>git stash</code>暂存修改</td>
</tr>
<tr>
<td><code>git stash pop</code></td>
<td>恢复暂存的修改</td>
<td>执行<code>git stash pop</code>恢复之前暂存的修改</td>
</tr>
<tr>
<td><code>git tag [tag - name]</code></td>
<td>给当前提交打标签</td>
<td><code>git tag v1.0</code>（给当前提交打<code>v1.0</code>标签）</td>
</tr>
<tr>
<td><code>git show [tag - name]</code></td>
<td>查看标签相关的提交信息</td>
<td><code>git show v1.0</code>查看<code>v1.0</code>标签对应的提交内容</td>
</tr>
</tbody></table>
<ol start="2">
<li><h4 id="Hexo相关："><a href="#Hexo相关：" class="headerlink" title="Hexo相关："></a>Hexo相关：</h4></li>
</ol>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>hexo init [folder]</code></td>
<td>初始化一个 Hexo 项目，可选参数<code>[folder]</code>指定项目文件夹名称。</td>
<td><code>hexo init my-blog</code>（在当前目录下创建名为<code>my-blog</code>的 Hexo 项目）</td>
</tr>
<tr>
<td><code>hexo new [layout] &lt;title&gt;</code></td>
<td>创建一篇新文章，<code>[layout]</code>是布局模板，<code>&lt;title&gt;</code>是文章标题。</td>
<td><code>hexo new post &quot;My New Post&quot;</code>（创建一篇新的<code>post</code>布局的文章）</td>
</tr>
<tr>
<td><code>hexo generate</code>或<code>hexo g</code></td>
<td>生成静态文件。</td>
<td>执行该命令会根据主题模板生成 HTML、CSS、JS 等静态文件到<code>public</code>目录。</td>
</tr>
<tr>
<td><code>hexo server</code>或<code>hexo s</code></td>
<td>启动本地服务器进行预览。</td>
<td>在本地浏览器中输入<code>http://localhost:4000</code>可查看生成的博客效果。</td>
</tr>
<tr>
<td><code>hexo clean</code></td>
<td>清除之前生成的静态文件和缓存。</td>
<td>当遇到生成问题或切换主题后可先执行此命令。</td>
</tr>
<tr>
<td><code>hexo deploy</code>或<code>hexo d</code></td>
<td>部署博客到指定平台。</td>
<td>配置好后执行该命令可将静态文件推送到远程仓库等部署目标。</td>
</tr>
<tr>
<td><code>hexo list &lt;type&gt;</code></td>
<td>列出特定类型的内容，如<code>post</code>（文章）、<code>page</code>（页面）等。</td>
<td><code>hexo list post</code>列出所有文章信息。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>网站部署</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>网站部署</tag>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
